###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Dec/2017  08:42:39
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Application\Library\MastConTask\DipComOperate.c
#    Command line =  
#        "F:\iar\NC136B-320
#        IC卡模块\Application\Library\MastConTask\DipComOperate.c" -D RELEASE
#        -lCN "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\DipComOperate.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\DipComOperate.o
#
###############################################################################

F:\iar\NC136B-320 IC卡模块\Application\Library\MastConTask\DipComOperate.c
      1          #include <includes.h>
      2          
      3          

   \                                 In section .bss, align 1
      4          uint8	l_led0com1flg = 0;
   \                     l_led0com1flg:
   \   00000000                      DS8 1
      5          

   \                                 In section .bss, align 4
      6          StrDipCommData	l_sDip1CommData,l_sDip2CommData;
   \                     l_sDip1CommData:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
   \                     l_sDip2CommData:
   \   00000000                      DS8 36
      7          
      8          /////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
      9          unsigned int GetDipVal(void)
     10          {
     11          	unsigned int  dipval;
     12          	dipval = g_DipVal;
   \                     GetDipVal: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable6
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x0008             MOVS     R0,R1
     13          	return dipval;
   \   00000006   0x4770             BX       LR               ;; return
     14          }
     15          //
     16          //short	GetAddSpeed(void)
     17          //{
     18          //	short addspeed;
     19          //	if(GetMyAddSpeed1())
     20          //	{
     21          //		if( GetMyAddSpeed1() )
     22          //		{
     23          //			addspeed = GetMyAddSpeed1();
     24          //		}
     25          //	}
     26          //	else
     27          //	{
     28          //		if( GetMyAddSpeed2() )
     29          //		{
     30          //			addspeed = GetMyAddSpeed2();
     31          //		}
     32          //	}
     33          //
     34          //	while(abs(addspeed) > 0x10000 )
     35          //	{
     36          //		printfcom0("\r\n addspeed %d",addspeed);
     37          //		addspeed /=10;
     38          //	}
     39          //	return addspeed;
     40          //}
     41          //
     42          //unsigned short GetSpeed(void)
     43          //{
     44          //	unsigned short speed;
     45          //	
     46          //	if(GetMySpeed1() && GetMySpeed2())
     47          //	{
     48          //		speed = (GetMySpeed1()+GetMySpeed2())/2;
     49          //	}
     50          //	else  if(GetMySpeed1() )
     51          //	{
     52          //		speed = GetMySpeed1(); 	
     53          //	}
     54          //	else if(GetMySpeed2() )
     55          //	{
     56          //		speed = GetMySpeed2(); 	
     57          //	}
     58          //	else
     59          //	{
     60          //		speed = 0;	
     61          //	}
     62          //	return	speed;
     63          //}
     64          
     65          //unsigned char GetLocoSta(void)
     66          //{
     67          //	unsigned char locosta;
     68          //	
     69          //	locosta = 1;
     70          //	return  locosta;
     71          //}
     72          
     73          ////////////////////////////////////////////
     74          //uint8	GetFramRecEndFlgDip(void)
     75          //{
     76          //	return GetCOM1EndFlg();
     77          //}
     78          
     79          ////清接收完成标志  南瑞
     80          //void	ClearFramRecEndFlgDip(void)
     81          //{
     82          //	ClearCOM1EndFlg();
     83          //}
     84          

   \                                 In section .text, align 2, keep-with-next
     85          uint16	ReadRs485DataDip(uint8 *Buf)
     86          {
   \                     ReadRs485DataDip: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     87          	return	ReadCOM1(Buf,64);
   \   00000004   0x2140             MOVS     R1,#+64
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       ReadCOM1
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
     88          }
     89          
     90          

   \                                 In section .bss, align 1
     91          uint8	l_recaddrdip = 0;
   \                     l_recaddrdip:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
     92          unsigned char GetRecaddrDip()
     93          {
     94          	return	l_recaddrdip;
   \                     GetRecaddrDip: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     95          }
     96          

   \                                 In section .bss, align 1
     97          unsigned char l_com1dip1Errflg = 0;
   \                     l_com1dip1Errflg:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     98          unsigned char l_com1dip2Errflg = 0;
   \                     l_com1dip2Errflg:
   \   00000000                      DS8 1
     99          

   \                                 In section .bss, align 1
    100          unsigned char l_com1SetModelflg = 0;
   \                     l_com1SetModelflg:
   \   00000000                      DS8 1
    101          
    102          

   \                                 In section .text, align 2, keep-with-next
    103          uint8	GetCom1Dip1ErrFlg(void)
    104          {
    105          	return	l_com1dip1Errflg;	
   \                     GetCom1Dip1ErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    106          }
    107          

   \                                 In section .text, align 2, keep-with-next
    108          uint8	GetCom1Dip2ErrFlg(void)
    109          {
    110          	return	l_com1dip2Errflg;	
   \                     GetCom1Dip2ErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_3
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    111          }
    112          

   \                                 In section .bss, align 1
    113          unsigned char l_recFlgdip = 0;
   \                     l_recFlgdip:
   \   00000000                      DS8 1

   \                                 In section .text, align 2, keep-with-next
    114          unsigned char GetRecFlgdip(void)
    115          {
    116          	return l_recFlgdip;
   \                     GetRecFlgdip: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_4
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    117          }
    118          
    119          
    120          

   \                                 In section .text, align 2, keep-with-next
    121          void DipComOperate(unsigned char *buf,unsigned int Len)		
    122          {
   \                     DipComOperate: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    123          	short			hig;
    124          	unsigned short 	den;
    125          	unsigned char	sta;
    126          	char			tmp;
    127          	static	unsigned int	dip1time,dip2time;
    128          
    129          	unsigned int   datalen = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
    130          	
    131          //	memcpy((unsigned char *)&hig,&buf[datalen],sizeof(hig));
    132          	hig = buf[datalen]*256 + buf[datalen+1]; 
   \   0000000C   0x5D30             LDRB     R0,[R6, R4]
   \   0000000E   0xF44F 0x7180      MOV      R1,#+256
   \   00000012   0x1932             ADDS     R2,R6,R4
   \   00000014   0x7852             LDRB     R2,[R2, #+1]
   \   00000016   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000001A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    133          	datalen += sizeof(hig);
   \   0000001E   0x1CB6             ADDS     R6,R6,#+2
    134          
    135          //	memcpy((unsigned char *)&den,&buf[datalen],sizeof(den));
    136          	den = buf[datalen+1]*256 + buf[datalen]; 
   \   00000020   0x1930             ADDS     R0,R6,R4
   \   00000022   0x7840             LDRB     R0,[R0, #+1]
   \   00000024   0xF44F 0x7180      MOV      R1,#+256
   \   00000028   0x5D32             LDRB     R2,[R6, R4]
   \   0000002A   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000002E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    137          	datalen += sizeof(den);
   \   00000032   0x1CB6             ADDS     R6,R6,#+2
    138          
    139          	memcpy((unsigned char *)&sta,&buf[datalen],sizeof(sta));
   \   00000034   0x2701             MOVS     R7,#+1
   \   00000036   0xEB16 0x0804      ADDS     R8,R6,R4
   \   0000003A   0xF10D 0x0901      ADD      R9,SP,#+1
   \   0000003E   0x003A             MOVS     R2,R7
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x4648             MOV      R0,R9
   \   00000044   0x.... 0x....      BL       __aeabi_memcpy
    140          	datalen += sizeof(sta);
   \   00000048   0x1C76             ADDS     R6,R6,#+1
    141          
    142            memcpy((unsigned char *)&tmp,&buf[datalen],sizeof(tmp));
   \   0000004A   0xF05F 0x0901      MOVS     R9,#+1
   \   0000004E   0xEB16 0x0A04      ADDS     R10,R6,R4
   \   00000052   0x46EB             MOV      R11,SP
   \   00000054   0x464A             MOV      R2,R9
   \   00000056   0x4651             MOV      R1,R10
   \   00000058   0x4658             MOV      R0,R11
   \   0000005A   0x.... 0x....      BL       __aeabi_memcpy
    143          	datalen += sizeof(tmp);		
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
    144          	
    145          	if(GetRecaddrDip()==0xA1)
   \   00000060   0x.... 0x....      BL       GetRecaddrDip
   \   00000064   0x28A1             CMP      R0,#+161
   \   00000066   0xD11F             BNE.N    ??DipComOperate_0
    146          	{
    147          		l_com1dip1Errflg = ~ERROR;
   \   00000068   0x20FF             MOVS     R0,#+255
   \   0000006A   0x....             LDR.N    R1,??DataTable6_2
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    148          		l_Dip1Prs 		= hig;
   \   0000006E   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000072   0x....             LDR.N    R1,??DataTable6_5
   \   00000074   0x8008             STRH     R0,[R1, #+0]
    149          		l_dip1den 		= den;
   \   00000076   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000007A   0x....             LDR.N    R1,??DataTable6_6
   \   0000007C   0x8008             STRH     R0,[R1, #+0]
    150          		l_Dip1ErrCod 	= sta;
   \   0000007E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000082   0x....             LDR.N    R1,??DataTable6_7
   \   00000084   0x7008             STRB     R0,[R1, #+0]
    151          		l_Dip1Tmp		= tmp;
   \   00000086   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000008A   0x....             LDR.N    R1,??DataTable6_8
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    152          		dip1time  		= GetSysTime(); 
   \   0000008E   0x.... 0x....      BL       GetSysTime
   \   00000092   0x....             LDR.N    R1,??DataTable6_9
   \   00000094   0x6008             STR      R0,[R1, #+0]
    153          		
    154          		memcpy((uint8 *)&l_sDip1CommData,buf,sizeof(l_sDip1CommData));
   \   00000096   0x2724             MOVS     R7,#+36
   \   00000098   0x.... 0x....      LDR.W    R8,??DataTable6_10
   \   0000009C   0x003A             MOVS     R2,R7
   \   0000009E   0x0021             MOVS     R1,R4
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       __aeabi_memcpy
    155          		//l_sDip1CommData
    156          
    157          //		if(l_Dip1ErrCod & 0x03 == 0x03)
    158          //		{
    159          //			l_Dip1Prs 
    160          //		}
    161          
    162          //		printfcom0("\r\n dip1 %d, %d, %d, %d,l_com1dip1Errflg %x",hig,den,sta,tmp,l_com1dip1Errflg);
    163          	}
   \   000000A6   0xE022             B.N      ??DipComOperate_1
    164          	else if(GetRecaddrDip()==0xA2)
   \                     ??DipComOperate_0: (+1)
   \   000000A8   0x.... 0x....      BL       GetRecaddrDip
   \   000000AC   0x28A2             CMP      R0,#+162
   \   000000AE   0xD11E             BNE.N    ??DipComOperate_1
    165          	{	
    166          		l_com1dip2Errflg = ~ERROR;
   \   000000B0   0x20FF             MOVS     R0,#+255
   \   000000B2   0x....             LDR.N    R1,??DataTable6_3
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
    167          
    168          		l_Dip2Prs 		= hig;
   \   000000B6   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   000000BA   0x....             LDR.N    R1,??DataTable6_11
   \   000000BC   0x8008             STRH     R0,[R1, #+0]
    169          		l_dip2den 		= den;
   \   000000BE   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   000000C2   0x....             LDR.N    R1,??DataTable6_12
   \   000000C4   0x8008             STRH     R0,[R1, #+0]
    170          		l_Dip2ErrCod 	= sta;
   \   000000C6   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000CA   0x....             LDR.N    R1,??DataTable6_13
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
    171          		l_Dip2Tmp			= tmp;
   \   000000CE   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   000000D2   0x....             LDR.N    R1,??DataTable6_14
   \   000000D4   0x7008             STRB     R0,[R1, #+0]
    172          		dip2time  		= GetSysTime(); 
   \   000000D6   0x.... 0x....      BL       GetSysTime
   \   000000DA   0x....             LDR.N    R1,??DataTable6_15
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    173          		
    174          		memcpy((uint8 *)&l_sDip2CommData,buf,sizeof(l_sDip2CommData));
   \   000000DE   0x2724             MOVS     R7,#+36
   \   000000E0   0x.... 0x....      LDR.W    R8,??DataTable6_16
   \   000000E4   0x003A             MOVS     R2,R7
   \   000000E6   0x0021             MOVS     R1,R4
   \   000000E8   0x4640             MOV      R0,R8
   \   000000EA   0x.... 0x....      BL       __aeabi_memcpy
    175          
    176          //		printfcom0("\r\n dip2 %d, %d, %d, %d,l_com1dip2Errflg %x",hig,den,sta,tmp,l_com1dip2Errflg);
    177          	}
    178          
    179          	if((GetSysTime() - dip1time > 1000) )
   \                     ??DipComOperate_1: (+1)
   \   000000EE   0x.... 0x....      BL       GetSysTime
   \   000000F2   0x....             LDR.N    R1,??DataTable6_9
   \   000000F4   0x6809             LDR      R1,[R1, #+0]
   \   000000F6   0x1A40             SUBS     R0,R0,R1
   \   000000F8   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000FC   0xD902             BLS.N    ??DipComOperate_2
    180          	{
    181          		l_com1dip1Errflg = ERROR;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x....             LDR.N    R1,??DataTable6_2
   \   00000102   0x7008             STRB     R0,[R1, #+0]
    182          	}
    183          	if((GetSysTime() - dip2time > 1000) )
   \                     ??DipComOperate_2: (+1)
   \   00000104   0x.... 0x....      BL       GetSysTime
   \   00000108   0x....             LDR.N    R1,??DataTable6_15
   \   0000010A   0x6809             LDR      R1,[R1, #+0]
   \   0000010C   0x1A40             SUBS     R0,R0,R1
   \   0000010E   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000112   0xD902             BLS.N    ??DipComOperate_3
    184          	{
    185          		l_com1dip2Errflg = ERROR;
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x....             LDR.N    R1,??DataTable6_3
   \   00000118   0x7008             STRB     R0,[R1, #+0]
    186          	}
    187          }
   \                     ??DipComOperate_3: (+1)
   \   0000011A   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .bss, align 4
   \                     ??dip1time:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??dip2time:
   \   00000000                      DS8 4
    188          
    189          //
    190          //
    191          //#define		OIL_BOX_MODEL_ADDR				2000	//油箱模型地址	
    192          //extern	stcModelComplex	l_sModel ;	;
    193          //void	StoreSetModelVal(stcModelComplex *comsModel,unsigned char nodeletnum)
    194          //{
    195          //	uint32		i,j,z;
    196          //	stcModel 	sModel;
    197          //	uint16 		Crc16;
    198          //	
    199          //	printfcom0("\r\n打印调整前的模型,不动点为 %d",nodeletnum);
    200          //	for(i = 0 ;i < comsModel->PotNum;i++)
    201          //	{
    202          //	  printfcom0("\r\n 高度 %d,油量 %d",comsModel->sModPot[i].HigVal,comsModel->sModPot[i].DipVal);
    203          //	}
    204          //
    205          //	for(i = 0;i < (comsModel->PotNum-1);i++)	
    206          //	{
    207          //		if(comsModel->sModPot[i].HigVal == comsModel->sModPot[i+1].HigVal)
    208          //		{
    209          //			printfcom0("\r\n comsModel->sModPot[%d].HigVal %d == comsModel->sModPot[i+1].HigVal %d",
    210          //			i,comsModel->sModPot[i].HigVal,comsModel->sModPot[i+1].HigVal);
    211          //
    212          //			z = i;
    213          //			if(nodeletnum == i)
    214          //			{				
    215          //				z++;
    216          //				printfcom0("\r\n z %d,i %d",z,i);
    217          //			}
    218          //
    219          //			for(j = z;j <(comsModel->PotNum-1);j++)
    220          //			{		
    221          //				comsModel->sModPot[j].HigVal = comsModel->sModPot[j+1].HigVal;
    222          //				comsModel->sModPot[j].DipVal = comsModel->sModPot[j+1].DipVal;				
    223          //			} 	
    224          //
    225          //			comsModel->PotNum = comsModel->PotNum -1;
    226          //
    227          //			nodeletnum<i?nodeletnum:nodeletnum--;
    228          //		}
    229          //		else if(comsModel->sModPot[i].HigVal > comsModel->sModPot[i+1].HigVal)
    230          //		{
    231          //			printfcom0("\r\n comsModel->sModPot[%d].HigVal %d > comsModel->sModPot[i+1].HigVal %d",
    232          //			i,comsModel->sModPot[i].HigVal,comsModel->sModPot[i+1].HigVal);
    233          //
    234          //			z = i;
    235          //			if(nodeletnum == i)
    236          //			{			
    237          //				z++;
    238          //				printfcom0("\r\n z %d,i %d",z,i);
    239          //
    240          //			}
    241          //			for(j = z;j <(comsModel->PotNum-1);j++)
    242          //			{		
    243          //				comsModel->sModPot[j].HigVal = comsModel->sModPot[j+1].HigVal;
    244          //				comsModel->sModPot[j].DipVal = comsModel->sModPot[j+1].DipVal;	
    245          //			}	
    246          //
    247          //			comsModel->PotNum = comsModel->PotNum -1;
    248          //
    249          //			nodeletnum<i?nodeletnum:nodeletnum--;			
    250          //		}
    251          //		else if(comsModel->sModPot[i].HigVal < comsModel->sModPot[i+1].HigVal)
    252          //		{
    253          //			if(comsModel->sModPot[i+1].HigVal - 50 < comsModel->sModPot[i].HigVal)	//单点变化最少为50L
    254          //			{
    255          //				printfcom0("\r\n comsModel->sModPot[%d].HigVal %d < comsModel->sModPot[i+1].HigVal %d",
    256          //				i,comsModel->sModPot[i].HigVal,comsModel->sModPot[i+1].HigVal);
    257          //				z = i;
    258          //				if(nodeletnum == i)
    259          //				{
    260          //					z++;
    261          //					printfcom0("\r\n z %d,i %d",z,i);
    262          //				}
    263          //				for(j = z;j <(comsModel->PotNum-1);j++)
    264          //				{		
    265          //					comsModel->sModPot[j].HigVal = comsModel->sModPot[j+1].HigVal;
    266          //					comsModel->sModPot[j].DipVal = comsModel->sModPot[j+1].DipVal;
    267          //				}  
    268          //				comsModel->PotNum = comsModel->PotNum -1;
    269          //
    270          //				nodeletnum<i?nodeletnum:nodeletnum--;				
    271          //			}
    272          //		}
    273          //	}
    274          //
    275          //
    276          //	for(i = 0;i < (comsModel->PotNum-1);i++)	
    277          //	{
    278          //		if(comsModel->sModPot[i].DipVal == comsModel->sModPot[i+1].DipVal)
    279          //		{
    280          //   			printfcom0("\r\n comsModel->sModPot[%d].DipVal %d == comsModel->sModPot[i+1].DipVal %d",
    281          //			i,comsModel->sModPot[i].DipVal,comsModel->sModPot[i+1].DipVal);
    282          //			z = i;
    283          //			if(nodeletnum == i)
    284          //			{
    285          //				z++;
    286          //				printfcom0("\r\n z %d,i %d",z,i);
    287          //			}
    288          //			for(j = z;j <(comsModel->PotNum-1);j++)
    289          //			{		
    290          //				comsModel->sModPot[j].HigVal = comsModel->sModPot[j+1].HigVal;
    291          //				comsModel->sModPot[j].DipVal = comsModel->sModPot[j+1].DipVal;
    292          //			}  	
    293          //			comsModel->PotNum = comsModel->PotNum -1;
    294          //
    295          //			nodeletnum<i?nodeletnum:nodeletnum--;
    296          //		}
    297          //		else if(comsModel->sModPot[i].DipVal > comsModel->sModPot[i+1].DipVal)
    298          //		{
    299          // 			printfcom0("\r\n comsModel->sModPot[%d].DipVal %d == comsModel->sModPot[i+1].DipVal %d",
    300          //			i,comsModel->sModPot[i].DipVal,comsModel->sModPot[i+1].DipVal);		
    301          //			z = i;
    302          //			if(nodeletnum == i)
    303          //			{
    304          //				z++;
    305          //				printfcom0("\r\n z %d,i %d",z,i);
    306          //			}
    307          //			for(j = z;j <(comsModel->PotNum-1);j++)
    308          //			{		
    309          //				comsModel->sModPot[j].HigVal = comsModel->sModPot[j+1].HigVal;
    310          //				comsModel->sModPot[j].DipVal = comsModel->sModPot[j+1].DipVal;		
    311          //			}
    312          //			comsModel->PotNum = comsModel->PotNum -1;	
    313          //
    314          //			nodeletnum<i?nodeletnum:nodeletnum--;		
    315          //		}
    316          //		else if(comsModel->sModPot[i].DipVal < comsModel->sModPot[i+1].DipVal)
    317          //		{
    318          //			if(comsModel->sModPot[i+1].DipVal - 50 < comsModel->sModPot[i].DipVal)	//单点变化最少为50L
    319          //			{
    320          //				printfcom0("\r\n comsModel->sModPot[%d].DipVal %d < comsModel->sModPot[i+1].DipVal %d",
    321          //				i,comsModel->sModPot[i].DipVal,comsModel->sModPot[i+1].DipVal);
    322          //			
    323          //				z = i;
    324          //
    325          //				if(nodeletnum == i)
    326          //				{
    327          //					z++;
    328          //					printfcom0("\r\n z %d,i %d",z,i);
    329          //				}
    330          //
    331          //				for(j = z;j <(comsModel->PotNum-1);j++)
    332          //				{		
    333          //					comsModel->sModPot[j].HigVal = comsModel->sModPot[j+1].HigVal;
    334          //					comsModel->sModPot[j].DipVal = comsModel->sModPot[j+1].DipVal;
    335          //				}	
    336          //				comsModel->PotNum = comsModel->PotNum -1;
    337          //
    338          //				nodeletnum<i?nodeletnum:nodeletnum--;				
    339          //			}
    340          //		}
    341          //	}
    342          //
    343          //
    344          ////	
    345          //	sModel.ModelNum = comsModel->ModelNum;
    346          //	if(comsModel->PotNum < 50)
    347          //	{
    348          //		sModel.PotNum = comsModel->PotNum;
    349          //	}
    350          //	else
    351          //	{
    352          //		sModel.PotNum = 50;
    353          //	}
    354          //	sModel.StartHight = comsModel->StartHight;
    355          //
    356          //	memcpy((uint8 *)sModel.sModPot,(uint8 *)comsModel->sModPot,sizeof(sModel.sModPot));
    357          //	if(comsModel->PotNum > 50)
    358          //	{
    359          //		sModel.sModPot[49].DipVal = comsModel->sModPot[comsModel->PotNum  -1].DipVal;	
    360          //		sModel.sModPot[49].HigVal = comsModel->sModPot[comsModel->PotNum  -1].HigVal;
    361          //	}
    362          //
    363          //	Crc16 = GetCrc16Check((uint8 *)&sModel,sizeof(sModel) - 2);
    364          //	
    365          //	sModel.CrcCheck  	= Crc16;	
    366          //
    367          //  	WriteFM24CL64(OIL_BOX_MODEL_ADDR,(uint8 *)&sModel, sizeof(sModel));
    368          //
    369          //	printfcom0("\r\n打印调整后的模型,不动点为 %d,comsModel->PotNum %d",nodeletnum,comsModel->PotNum);
    370          //	for(i = 0 ;i < comsModel->PotNum;i++)
    371          //	{
    372          //	  printfcom0("\r\n 高度 %d,油量 %d",comsModel->sModPot[i].HigVal,comsModel->sModPot[i].DipVal);
    373          //	}
    374          //
    375          //}
    376          
    377          extern	stcModelComplex	l_sModel;
    378          
    379          //uint8	l_setmodelflg = 0;
    380          //uint8	GetSetModelFlg(void)
    381          //{
    382          //	return	l_setmodelflg;
    383          ////}
    384          //void	DipModelSet	(unsigned char *buf,unsigned int Len)		
    385          //{
    386          //	short			hig;
    387          //	unsigned short 	den;
    388          //	unsigned short	valadd;
    389          //	unsigned short	setnum;
    390          //	static	unsigned short   firstmodelsetval = 0;
    391          //	static	unsigned short   firstaddval = 0;
    392          //	static	short	lsthig = 0;
    393          //	static  short	lstval = 0;
    394          //	uint32	i,j;
    395          //	uint32	portnum;
    396          //	static	char	addflg = 0;
    397          //
    398          ////	static	unsigned int	dip1time,dip2time;
    399          //
    400          //	unsigned int   datalen = 0;
    401          //		
    402          ////	memcpy((unsigned char *)&hig,&buf[datalen],sizeof(hig));
    403          //	hig = buf[datalen]*256 + buf[datalen+1]; 
    404          //	datalen += sizeof(hig);
    405          //
    406          ////	memcpy((unsigned char *)&den,&buf[datalen],sizeof(den));
    407          //	den = buf[datalen]*256 + buf[datalen+1]; 
    408          //	datalen += sizeof(den);
    409          //
    410          ////	memcpy((unsigned char *)&valadd,&buf[datalen],sizeof(valadd));
    411          //	valadd = buf[datalen]*256 + buf[datalen+1]; 
    412          //	datalen += sizeof(valadd);
    413          //
    414          ////  memcpy((unsigned char *)&setnum,&buf[datalen],sizeof(setnum));
    415          //	setnum = buf[datalen]*256 + buf[datalen+1]; 
    416          //	datalen += sizeof(setnum);		
    417          //	
    418          //	if(GetRecaddrDip()==0xA5)
    419          //	{
    420          //		l_setmodelflg = 1;
    421          //		printfcom0("\r\n Set %d, %d, %d, %d,l_com1dip1Errflg %x",hig,den,valadd,setnum);
    422          //		
    423          //		if(setnum == 0)
    424          //		{
    425          //			firstmodelsetval = 0;
    426          //			if(g_DipVal>valadd)
    427          //			{
    428          //				firstmodelsetval = g_DipVal-valadd;
    429          //				firstaddval      = valadd;
    430          //			}
    431          //			else
    432          //			{
    433          //				firstmodelsetval = valadd;	
    434          //				firstaddval      = valadd;
    435          //			}
    436          //			addflg = 0;
    437          //			DisplaySet(150,2,"SET_%d",setnum);
    438          //		   	printfcom0("\r\n 校准零点校准");
    439          //			GetMathModelPara((stcModelComplex *)&l_sModel,0);		//模型参数	
    440          //			
    441          //			portnum = l_sModel.PotNum;
    442          //			
    443          //			if(portnum > 199)
    444          //			{
    445          //				portnum = 199;	
    446          //			}
    447          //
    448          //			printfcom0("\r\n portnum %d",portnum);
    449          //			for(i = portnum;i>0;i--)
    450          //			{
    451          //				if(hig < l_sModel.sModPot[i-1].HigVal)
    452          //				{
    453          //					l_sModel.sModPot[i].HigVal =  l_sModel.sModPot[i-1].HigVal;
    454          //					l_sModel.sModPot[i].DipVal =  l_sModel.sModPot[i-1].DipVal;
    455          //
    456          //					if(i == 1)
    457          //					{
    458          //						l_sModel.sModPot[i-1].HigVal = hig;
    459          //						l_sModel.sModPot[i-1].DipVal = firstmodelsetval;
    460          //						l_sModel.PotNum++;
    461          //
    462          //						StoreSetModelVal((stcModelComplex *)&l_sModel,i-1);
    463          //					}
    464          //
    465          //					//printfcom0("\r\n i-1 %d",i-1);
    466          //
    467          //					printfcom0("\r\n hig %d < l_sModel.sModPot[i-1].HigVal %d,l_sModel.PotNum %d",
    468          //											hig,l_sModel.sModPot[i-1].HigVal,l_sModel.PotNum);
    469          //				}
    470          //				else if(hig == l_sModel.sModPot[i-1].HigVal)
    471          //				{
    472          //					l_sModel.sModPot[i-1].DipVal = firstmodelsetval;
    473          //					for(j=i;j<portnum-1;j++)
    474          //					{
    475          //						l_sModel.sModPot[i].HigVal =  l_sModel.sModPot[i+1].HigVal;
    476          //						l_sModel.sModPot[i].DipVal =  l_sModel.sModPot[i+1].DipVal;
    477          //					} 
    478          //
    479          //					printfcom0("\r\n i-1 %d",i-1);
    480          //
    481          //					printfcom0("\r\n hig %d = l_sModel.sModPot[i-1].HigVal %d,l_sModel.PotNum %d",hig,l_sModel.sModPot[i-1].HigVal,l_sModel.PotNum);
    482          //
    483          //					StoreSetModelVal((stcModelComplex *)&l_sModel,i-1);
    484          //					break;
    485          //				}
    486          //				else
    487          //				{
    488          //					l_sModel.sModPot[i].HigVal =  hig;
    489          //					l_sModel.sModPot[i].DipVal =  firstmodelsetval;
    490          //
    491          //					l_sModel.PotNum ++;
    492          //					
    493          //					printfcom0("\r\n i %d",i);
    494          //
    495          //					printfcom0("\r\n hig %d > l_sModel.sModPot[i-1].HigVal %d,l_sModel.PotNum %d",hig,l_sModel.sModPot[i-1].HigVal,l_sModel.PotNum);
    496          //
    497          //					StoreSetModelVal((stcModelComplex *)&l_sModel,i);
    498          //					break;
    499          //				}
    500          //			}
    501          //		}
    502          //		else  if(setnum != 0xffff)	   //非起点
    503          //		{
    504          //			DisplaySet(150,2,"SET_%d",setnum);
    505          //
    506          //			GetMathModelPara((stcModelComplex *)&l_sModel,0);		//模型参数	
    507          //			
    508          //			portnum = l_sModel.PotNum;
    509          //			
    510          //			if(portnum > 199)
    511          //			{
    512          //				portnum = 199;	
    513          //			}
    514          //			
    515          //			if(abs(valadd-lstval)<50 ||abs(hig-lsthig)<50)
    516          //			{
    517          //				printfcom0("\r\n 增量过小 valadd %d,lstval %d,hig %d,lsthig %d",valadd,lstval,hig,lsthig);
    518          //				return;
    519          //			}
    520          //
    521          //			printfcom0("\r\n portnum %d",portnum);
    522          //			for(i = portnum;i>0;i--)
    523          //			{
    524          //				if(hig < l_sModel.sModPot[i-1].HigVal)
    525          //				{
    526          //					l_sModel.sModPot[i].HigVal =  l_sModel.sModPot[i-1].HigVal;
    527          //					l_sModel.sModPot[i].DipVal =  l_sModel.sModPot[i-1].DipVal;
    528          //					
    529          //					if(i == 1)
    530          //					{
    531          //						l_sModel.sModPot[i-1].HigVal = hig;
    532          //						if(hig > lsthig)
    533          //						{
    534          //							l_sModel.sModPot[i-1].DipVal = firstmodelsetval + (valadd - firstaddval);
    535          //							printfcom0("\r\n 上油校准");
    536          //						}
    537          //						else
    538          //						{
    539          //							l_sModel.sModPot[i-1].DipVal = firstmodelsetval - (valadd - firstaddval);
    540          //							printfcom0("\r\n 卸油校准");
    541          //						}
    542          //						l_sModel.PotNum ++;
    543          //					}
    544          //
    545          //					printfcom0("\r\n hig %d > l_sModel.sModPot[i-1].HigVal %d,l_sModel.PotNum %d",hig,l_sModel.sModPot[i-1].HigVal,l_sModel.PotNum);
    546          //
    547          //				}
    548          //				else if(hig == l_sModel.sModPot[i-1].HigVal)
    549          //				{
    550          //					if(hig > lsthig)
    551          //					{
    552          //						l_sModel.sModPot[i-1].DipVal = firstmodelsetval + (valadd - firstaddval);
    553          //						printfcom0("\r\n 上油校准");
    554          //					}
    555          //					else
    556          //					{
    557          //						l_sModel.sModPot[i-1].DipVal = firstmodelsetval - (valadd - firstaddval);
    558          //						printfcom0("\r\n 卸油校准");
    559          //					}
    560          //
    561          //					for(j=i;j<portnum-1;j++)
    562          //					{
    563          //						l_sModel.sModPot[i].HigVal =  l_sModel.sModPot[i+1].HigVal;
    564          //						l_sModel.sModPot[i].DipVal =  l_sModel.sModPot[i+1].DipVal;
    565          //					} 
    566          //
    567          //					printfcom0("\r\n hig %d = l_sModel.sModPot[i-1].HigVal %d,l_sModel.PotNum %d",hig,l_sModel.sModPot[i-1].HigVal,l_sModel.PotNum);
    568          //
    569          //					StoreSetModelVal((stcModelComplex *)&l_sModel,i-1);
    570          //					break;
    571          //				}
    572          //				else
    573          //				{
    574          //
    575          //					l_sModel.sModPot[i].HigVal =  hig;
    576          //					if(hig > lsthig)
    577          //					{
    578          //						l_sModel.sModPot[i].DipVal = firstmodelsetval + (valadd - firstaddval);
    579          //						printfcom0("\r\n 上油校准");
    580          //					}
    581          //					else
    582          //					{
    583          //						l_sModel.sModPot[i].DipVal = firstmodelsetval - (valadd - firstaddval);
    584          //						printfcom0("\r\n 卸油校准");
    585          //					}
    586          //
    587          //					l_sModel.PotNum ++;
    588          //
    589          //					printfcom0("\r\n hig %d < l_sModel.sModPot[i-1].HigVal %d,l_sModel.PotNum %d",hig,l_sModel.sModPot[i-1].HigVal,l_sModel.PotNum);
    590          //
    591          //					StoreSetModelVal((stcModelComplex *)&l_sModel,i);
    592          //					break;
    593          //				}
    594          //			}
    595          //		}
    596          //
    597          //		lsthig = hig;
    598          //		lstval = valadd;
    599          //
    600          //	}
    601          //}
    602          //
    603          //unsigned char sentendflgdip = 0;
    604          //void HostScanDip(void)
    605          //{
    606          //	static	unsigned char 	tmp = 0;
    607          //	static	unsigned int 	time = 0;
    608          //	unsigned char 		 	ScanAddrList[9]={0xA1,0xA2,0xA3,0xA5};
    609          //	unsigned char   		buf[12];
    610          //	unsigned char 			datalen;
    611          //	
    612          //	unsigned int            dipval;
    613          //	short                   addspeed;
    614          //	unsigned short			speed;
    615          //	unsigned char           locosta;
    616          //	unsigned char           tmpbuf[3]={0};
    617          //	
    618          //	if(		GetSysTime() - time > 50 
    619          //		|| (GetRecFlgdip() && (GetSysTime() - time > 10))
    620          //		)
    621          //	{
    622          //		time 	= GetSysTime(); 
    623          //		datalen = 0;
    624          //		
    625          ////		dipval = g_DipVal;	  	//
    626          //
    627          //#ifdef	CVISOFT
    628          //		dipval = GetDipVal();
    629          //		memcpy(&buf[datalen],(unsigned char *)&dipval,sizeof(dipval));
    630          //		datalen += sizeof(dipval);
    631          //		
    632          //		addspeed = GetAddSpeed();
    633          //		memcpy(&buf[datalen],(unsigned char *)&addspeed,sizeof(addspeed));
    634          //		datalen += sizeof(addspeed);
    635          //		
    636          //		speed = GetSpeed();
    637          //		memcpy(&buf[datalen],(unsigned char *)&speed,sizeof(speed));
    638          //		datalen += sizeof(speed);
    639          //		
    640          //		locosta = GetMyLocoWorkState();
    641          //		memcpy(&buf[datalen],(unsigned char *)&locosta,sizeof(locosta));
    642          //		datalen += sizeof(locosta);
    643          //
    644          //		memcpy(&buf[datalen],tmpbuf,sizeof(tmpbuf));
    645          //		datalen += sizeof(tmpbuf);
    646          //#endif		
    647          //		dipval = GetDipVal();
    648          //		//memcpy(&buf[datalen],(unsigned char *)&dipval,sizeof(dipval));
    649          //		buf[datalen] 	= dipval>>24;
    650          //		buf[datalen+1] 	= dipval>>16;
    651          //		buf[datalen+2] 	= dipval>>8;
    652          //		buf[datalen+3] 	= dipval>>0;
    653          //
    654          //		datalen += sizeof(dipval);
    655          //		
    656          //		addspeed = GetAddSpeed();
    657          ////		memcpy(&buf[datalen],(unsigned char *)&addspeed,sizeof(addspeed));
    658          //		buf[datalen] 	= addspeed>>8;
    659          //		buf[datalen+1] 	= addspeed>>0;
    660          //
    661          //		datalen += sizeof(addspeed);
    662          //		
    663          //		speed = GetSpeed();
    664          ////		memcpy(&buf[datalen],(unsigned char *)&speed,sizeof(speed));
    665          //		buf[datalen] 	= speed>>8;
    666          //		buf[datalen+1] 	= speed>>0;
    667          //
    668          //		datalen += sizeof(speed);
    669          //		
    670          //		locosta = GetMyLocoWorkState();
    671          //		memcpy(&buf[datalen],(unsigned char *)&locosta,sizeof(locosta));
    672          //		datalen += sizeof(locosta);
    673          //
    674          //		memcpy(&buf[datalen],tmpbuf,sizeof(tmpbuf));
    675          //		datalen += sizeof(tmpbuf);
    676          //
    677          //		DataSend_CSNR(0x80,ScanAddrList[tmp%4],(unsigned char *)&buf,datalen);
    678          //
    679          //		tmp++;
    680          //		sentendflgdip = 1;
    681          //		l_recFlgdip 	= 0;
    682          //		DelayX10ms(1);
    683          //	}
    684          //}
    685          
    686          //
    687          //void  CSNR_RecDealDip(void)     												//主机
    688          //{
    689          //	unsigned char		RecBuf[64] = {0};								//接收缓冲区
    690          //	unsigned char		DataBuf[64] = {0};								//
    691          //	unsigned int		RecLen;		
    692          //	unsigned int		DataLen = 16;
    693          //	static	uint32		rectime = 0;
    694          //	static	uint8		errtimes;
    695          //	static	uint32		errtime;		
    696          //			
    697          //	if( GetFramRecEndFlgDip() == 1 && sentendflgdip == 1)						//有新的帧尾，进行数据处理	  ////////////////////////
    698          //	{
    699          //		rectime = GetSysTime();
    700          //		errtimes = 0;
    701          //
    702          ////		l_led0com1flg = COM_LED_REC;
    703          //		l_recFlgdip = 1;
    704          //		sentendflgdip = 0;  
    705          //																										//发送指令后，等待接收
    706          //		RecLen 	= ReadRs485DataDip(RecBuf);
    707          //		
    708          //		ClearFramRecEndFlgDip();												//清标志，可重新取数
    709          //		
    710          //		if(RecLen < 10)
    711          //			return ;
    712          //		
    713          //		l_recaddrdip = CSNR_GetData(RecBuf,RecLen,DataBuf,(unsigned char*)&DataLen); 
    714          //	
    715          ////	数据转发，如果数据未按通讯协议要求，则从串口2、3发出。		
    716          //		if(l_recaddrdip == 0)
    717          //		{
    718          //			SendCOM2(RecBuf,RecLen);
    719          //			SendCOM3(RecBuf,RecLen);
    720          //			return	;
    721          //		}
    722          //		
    723          //		switch(l_recaddrdip)
    724          //		{
    725          //			case 0xA1: 
    726          //						l_led0com1flg =  COM_LED_DATA;
    727          //					   	DipComOperate(DataBuf,DataLen); 				//读卡器对接收的信息进行处理 
    728          //				break;
    729          //				
    730          //			case 0xA2: 
    731          //						l_led0com1flg =  COM_LED_DATA;
    732          //					   	DipComOperate(DataBuf,DataLen); 				//读卡器对接收的信息进行处理 
    733          //				break;
    734          //
    735          //			case 0xA5: 
    736          //						l_led0com1flg =  COM_LED_DATA;
    737          //					 //  	DipModelSet(DataBuf,DataLen); 				//读卡器对接收的信息进行处理 
    738          //				break;
    739          //
    740          //			default: ;
    741          //		}
    742          //	}
    743          //	else
    744          //	{
    745          //		if(GetSysTime() - rectime > 100)
    746          //		{
    747          //			if(GetSysTime() - errtime > 100 )
    748          //			{
    749          //					errtimes++;
    750          //			    errtime	= GetSysTime();
    751          //			}
    752          //			if(errtimes	> 3)
    753          //			{
    754          //				l_led0com1flg	= 0; 
    755          //	
    756          //				l_com1dip1Errflg = ERROR;
    757          //				l_com1dip2Errflg = ERROR;
    758          //			}
    759          //		}
    760          //	}
    761          //}
    762          

   \                                 In section .text, align 2, keep-with-next
    763          uint8	GetLed0Com1Flg(void)
    764          {
    765          	return	 l_led0com1flg;
   \                     GetLed0Com1Flg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_17
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    766          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     g_DipVal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     l_recaddrdip

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     l_com1dip1Errflg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     l_com1dip2Errflg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     l_recFlgdip

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     l_Dip1Prs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     l_dip1den

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     l_Dip1ErrCod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     l_Dip1Tmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     ??dip1time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     l_sDip1CommData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     l_Dip2Prs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     l_dip2den

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x........         DC32     l_Dip2ErrCod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     l_Dip2Tmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x........         DC32     ??dip2time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     l_sDip2CommData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x........         DC32     l_led0com1flg
    767          
    768          
    769          extern  uint8  GetCOM1Data(void);
    770          //
    771          //void Diptask(void)
    772          //{
    773          //    static  int     time;
    774          //
    775          //    HostScanDip();                  //读油量
    776          //    
    777          //    CSNR_RecDealDip();              //接收处理
    778          //
    779          ////	if(GetSysTime() - time > 200)   //2s一次
    780          ////    {
    781          ////        SendReadPowerCode();        //读电量
    782          ////        time = GetSysTime();
    783          ////    }
    784          //    
    785          //    GetCOM1Data();                  //取电量数据
    786          //    
    787          ////    MathPower();                    //计算电量
    788          //}

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   DipComOperate
        48   -> GetRecaddrDip
        48   -> GetSysTime
        48   -> __aeabi_memcpy
       0   GetCom1Dip1ErrFlg
       0   GetCom1Dip2ErrFlg
       0   GetDipVal
       0   GetLed0Com1Flg
       0   GetRecFlgdip
       0   GetRecaddrDip
       8   ReadRs485DataDip
         8   -> ReadCOM1


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     286  DipComOperate
       6  GetCom1Dip1ErrFlg
       6  GetCom1Dip2ErrFlg
       8  GetDipVal
       6  GetLed0Com1Flg
       6  GetRecFlgdip
       6  GetRecaddrDip
      16  ReadRs485DataDip
       4  dip1time
       4  dip2time
       1  l_com1SetModelflg
       1  l_com1dip1Errflg
       1  l_com1dip2Errflg
       1  l_led0com1flg
       1  l_recFlgdip
       1  l_recaddrdip
      36  l_sDip1CommData
      36  l_sDip2CommData

 
  86 bytes in section .bss
 412 bytes in section .text
 
 412 bytes of CODE memory
  86 bytes of DATA memory

Errors: none
Warnings: none

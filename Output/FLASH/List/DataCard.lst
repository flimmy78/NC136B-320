###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Dec/2017  08:42:39
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Application\Library\CardOperations\DataCard.c
#    Command line =  
#        "F:\iar\NC136B-320
#        IC卡模块\Application\Library\CardOperations\DataCard.c" -D RELEASE
#        -lCN "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\DataCard.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\DataCard.o
#
###############################################################################

F:\iar\NC136B-320 IC卡模块\Application\Library\CardOperations\DataCard.c
      1          //#include 	"config.h"
      2          //#include 	"String.h"
      3          //#include	"Globe.h"
      4          //#include	"HardDrive.h"
      5          //#include	"StoreRec.h"
      6          //#include	"CpuDrive.h"
      7          //#include	"FramStore.h"
      8          //#include	"OperateCard.h"
      9          //#include	"stdlib.h" 
     10          
     11          #include    "includes.h"  
     12          #include	"Card.h"
     13          #include	"OperateCard.h"
     14          #include	"app_ctrl.h"
     15          
     16          //#include	"flash.h"
     17          
     18          #define		CARD_BUF_LEN		1024			//IC卡处理缓冲区大小	
     19          uint8 FRAM_StoreRecNumMgr(StrRecNumMgr  *SRecNumMgr);
     20          
     21          
     22          //----------------------------------------------------------------------
     23          //函数名称:  	uint32_t  GetWritePageLen(uint32_t Start, uint32_t WriteLen,uint32_t MaxWriteLen)
     24          //函数功能:  	求写将要完成下页写长度
     25          //入口参数:   	StartAddr:IC卡起始写地址;FinishLen:已写地址,MaxWriteLen:要写地址
     26          //出口参数:   	
     27          //说明:                 
     28          //-----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     29          uint32_t  GetWritePageLen(uint32_t StartAddr, uint32_t FinishLen,uint32_t MaxWriteLen)
     30          {
   \                     GetWritePageLen: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
     31              uint32_t  	PageSize;
     32              uint32_t  	PageSegLen;
     33              uint32_t  	NoWriteLen;
     34          	
     35          	PageSize = GetCardPageSize();
   \   0000000A   0x.... 0x....      BL       GetCardPageSize
   \   0000000E   0x0007             MOVS     R7,R0
     36          	
     37              PageSegLen = PageSize - ((StartAddr + FinishLen) % PageSize);		//从首往尾写
   \   00000010   0x1928             ADDS     R0,R5,R4
   \   00000012   0x1A39             SUBS     R1,R7,R0
   \   00000014   0xFBB0 0xF0F7      UDIV     R0,R0,R7
   \   00000018   0xFB07 0x1000      MLA      R0,R7,R0,R1
   \   0000001C   0x4680             MOV      R8,R0
     38              
     39              NoWriteLen = MaxWriteLen - FinishLen;
   \   0000001E   0x1B70             SUBS     R0,R6,R5
   \   00000020   0x4681             MOV      R9,R0
     40              
     41              if( PageSegLen < NoWriteLen)
   \   00000022   0x45C8             CMP      R8,R9
   \   00000024   0xD201             BCS.N    ??GetWritePageLen_0
     42              {
     43                  return PageSegLen;
   \   00000026   0x4640             MOV      R0,R8
   \   00000028   0xE000             B.N      ??GetWritePageLen_1
     44              }
     45              else
     46              {
     47                  return  NoWriteLen;
   \                     ??GetWritePageLen_0: (+1)
   \   0000002A   0x4648             MOV      R0,R9
   \                     ??GetWritePageLen_1: (+1)
   \   0000002C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
     48              }
     49          }
     50          
     51          //----------------------------------------------------------------------
     52          //函数名称:  	stcFlshRec    FlshRecToCardRec( stcFlshRec   sFlshRec)
     53          //函数功能:  	将油尺记录FLASH转化为IC卡记录
     54          //入口参数:   	FLASH记录
     55          //出口参数:   	IC卡记录
     56          //说明:                 
     57          //-----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     58          stcFlshRec    FlshRecToCardRec( stcFlshRec   sFlshRec)
     59          {
   \                     FlshRecToCardRec: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB5F0             PUSH     {R4-R7,LR}
   \   00000004   0xB0A0             SUB      SP,SP,#+128
   \   00000006   0x0004             MOVS     R4,R0
     60          	stcFlshRec  sCardRec;		
     61          	memcpy((uint8_t *)&sCardRec,(uint8_t *)&sFlshRec,sizeof(sCardRec));
   \   00000008   0x2580             MOVS     R5,#+128
   \   0000000A   0xAE25             ADD      R6,SP,#+148
   \   0000000C   0x466F             MOV      R7,SP
   \   0000000E   0x002A             MOVS     R2,R5
   \   00000010   0x0031             MOVS     R1,R6
   \   00000012   0x0038             MOVS     R0,R7
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
     62          	
     63          	return	sCardRec;
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x2280             MOVS     R2,#+128
   \   0000001E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000022   0xB020             ADD      SP,SP,#+128
   \   00000024   0xBCF0             POP      {R4-R7}
   \   00000026   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
     64          }
     65          
     66          //extern	void	SysHoldTast(void);
     67          
     68          //----------------------------------------------------------------------
     69          //函数名称:  	void    ReadCardDisplay(uint8_t	 Sct)
     70          //函数功能:  	将油尺记录FLASH转化为IC卡记录
     71          //入口参数:   	FLASH记录
     72          //出口参数:   	IC卡记录
     73          //说明:                 
     74          //-----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     75          void    ReadCardDisplay(uint8_t	 Sct)
     76          {
   \                     ReadCardDisplay: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     77          	uint8_t	i = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     78          	
     79              //	if(GetSysTime() % 100 < 12)
     80          	{
     81          		i = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0005             MOVS     R5,R0
     82          		while(i < 10 )
   \                     ??ReadCardDisplay_0: (+1)
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x2D0A             CMP      R5,#+10
   \   0000000E   0xDA0B             BGE.N    ??ReadCardDisplay_1
     83          		{
     84          			DisplaySet(10,2,"%u  %u",Sct,i);
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x9500             STR      R5,[SP, #+0]
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x0023             MOVS     R3,R4
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable2
   \   0000001C   0x2102             MOVS     R1,#+2
   \   0000001E   0x200A             MOVS     R0,#+10
   \   00000020   0x.... 0x....      BL       DisplaySet
     85          			i++;
   \   00000024   0x1C6D             ADDS     R5,R5,#+1
   \   00000026   0xE7F0             B.N      ??ReadCardDisplay_0
     86          		}
     87          		
     88          		//OnLed(WRITE_CARD_LED,10,5,5);
     89          	}													//xitong 
     90          }
   \                     ??ReadCardDisplay_1: (+1)
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     91          
     92          //----------------------------------------------------------------------
     93          //函数名称:  	uint8_t  StoreCardRec(uint32_t   FlshStartRecNum,uint32_t	FlshRecCnt,uint32_t	CardStartAddr )
     94          //函数功能:  	存IC卡记录
     95          //入口参数:   	FlshStartRecNum:起始Flsh记录号,FlshRecCnt:记录个数,StartCardRecAddr:IC卡起始地址
     96          //出口参数:   	
     97          //说明:                 
     98          //-----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     99          uint8_t  StoreCardRec(uint32_t   FlshStartRecNum,uint32_t	FlshRecCnt,uint32_t	CardStartAddr,uint32_t	WriteTimes )
    100          {
   \                     StoreCardRec: (+1)
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \   00000004   0xF5AD 0x6D91      SUB      SP,SP,#+1160
   \   00000008   0x0014             MOVS     R4,R2
    101          	uint8_t				CardBuf[1024];
    102          	uint32_t			FlshRecNum;											//Flsh记录流水号
    103          	uint32_t			MaxWriteLen;										//最大要写卡长度
    104          	uint32_t			FinishLen = 0;										//已写长度
   \   0000000A   0x2500             MOVS     R5,#+0
    105          	uint32_t			WritePageLen;	
    106          	uint32_t			NextRecCardAddr;
    107          	uint32_t			BufWriteLen = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    108          	
    109          	stcFlshRec		sFlshRec;
    110          	
    111          	FlshRecNum	= FlshStartRecNum;
   \   0000000E   0xF8DD 0x0488      LDR      R0,[SP, #+1160]
   \   00000012   0x4680             MOV      R8,R0
    112          	MaxWriteLen = FlshRecCnt * sizeof(sFlshRec);					
   \   00000014   0xF8DD 0x048C      LDR      R0,[SP, #+1164]
   \   00000018   0x2180             MOVS     R1,#+128
   \   0000001A   0x4348             MULS     R0,R1,R0
   \   0000001C   0x9000             STR      R0,[SP, #+0]
    113              
    114          	BufWriteLen = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0007             MOVS     R7,R0
    115          	while( FinishLen < MaxWriteLen)
   \                     ??StoreCardRec_0: (+1)
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x4285             CMP      R5,R0
   \   00000026   0xD232             BCS.N    ??StoreCardRec_1
    116          	{
    117          		ReadFlshRec((stcFlshRec *)&sFlshRec,FlshRecNum++);
   \   00000028   0x4641             MOV      R1,R8
   \   0000002A   0xA802             ADD      R0,SP,#+8
   \   0000002C   0x.... 0x....      BL       ReadFlshRec
   \   00000030   0xF118 0x0801      ADDS     R8,R8,#+1
    118                  
    119          		WritePageLen = GetWritePageLen(CardStartAddr,FinishLen,MaxWriteLen);
   \   00000034   0x9A00             LDR      R2,[SP, #+0]
   \   00000036   0x0029             MOVS     R1,R5
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       GetWritePageLen
   \   0000003E   0x0006             MOVS     R6,R0
    120                  
    121          		memcpy(&CardBuf[BufWriteLen],(uint8_t *)&sFlshRec,sizeof(sFlshRec));
   \   00000040   0xF05F 0x0980      MOVS     R9,#+128
   \   00000044   0xF10D 0x0A08      ADD      R10,SP,#+8
   \   00000048   0xA822             ADD      R0,SP,#+136
   \   0000004A   0xEB17 0x0B00      ADDS     R11,R7,R0
   \   0000004E   0x464A             MOV      R2,R9
   \   00000050   0x4651             MOV      R1,R10
   \   00000052   0x4658             MOV      R0,R11
   \   00000054   0x.... 0x....      BL       __aeabi_memcpy
    122          		BufWriteLen += sizeof(sFlshRec);
   \   00000058   0x3780             ADDS     R7,R7,#+128
    123                  
    124          		if(WritePageLen == BufWriteLen || WritePageLen < BufWriteLen)
   \   0000005A   0x42BE             CMP      R6,R7
   \   0000005C   0xD001             BEQ.N    ??StoreCardRec_2
   \   0000005E   0x42BE             CMP      R6,R7
   \   00000060   0xD20F             BCS.N    ??StoreCardRec_3
    125          		{
    126          			NextRecCardAddr = CardStartAddr + FinishLen;				//IC卡下一地址
   \                     ??StoreCardRec_2: (+1)
   \   00000062   0x1928             ADDS     R0,R5,R4
   \   00000064   0x9001             STR      R0,[SP, #+4]
    127                      
    128             			WriteCard(NextRecCardAddr,CardBuf,WritePageLen);      		//写卡
   \   00000066   0x0032             MOVS     R2,R6
   \   00000068   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000006A   0xA922             ADD      R1,SP,#+136
   \   0000006C   0x9801             LDR      R0,[SP, #+4]
   \   0000006E   0x.... 0x....      BL       WriteCard
    129               		
    130               		FinishLen += WritePageLen;									//将要完成写长度
   \   00000072   0x1975             ADDS     R5,R6,R5
    131                      
    132               		ReadCardDisplay(WriteTimes);								//指示正在读卡
   \   00000074   0xF8DD 0x0490      LDR      R0,[SP, #+1168]
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x.... 0x....      BL       ReadCardDisplay
    133                      
    134          			BufWriteLen = 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x0007             MOVS     R7,R0
    135          		}
    136          		if(GetPlugFlg() == NO_PLUG_IN_CARD)								//拨卡退出
   \                     ??StoreCardRec_3: (+1)
   \   00000082   0x.... 0x....      BL       GetPlugFlg
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD1CB             BNE.N    ??StoreCardRec_0
    137          		{
    138          			return FALSE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??StoreCardRec_4
    139          		}
    140          	}
    141              
    142          	return TRUE;
   \                     ??StoreCardRec_1: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??StoreCardRec_4: (+1)
   \   00000090   0xF20D 0x4D94      ADDW     SP,SP,#+1172
   \   00000094   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    143          }
    144          
    145          //-------------------------------------------------------------------------------------------------
    146          //函数名称:             uint32_t	GetReadFlshRecCnt(uint32_t ZoneMaxRecNum)	   
    147          //函数功能:             取分区应读取的记录数
    148          //入口参数:             分区最大记录数
    149          //出口参数:             记录数
    150          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    151          uint32_t	GetReadFlshRecCnt(uint32_t NoReadRecNum,uint32_t ZoneMaxRecNum)
    152          {	
   \                     GetReadFlshRecCnt: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    153          	uint32_t	FlshMaxRec;
    154          	
    155          	FlshMaxRec = (FLSH_MAX_SIZE)/(sizeof(stcFlshRec));
   \   00000002   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000006   0x0003             MOVS     R3,R0
    156          	
    157          	////printfcom0("\r\n FlshMaxRec %d",FlshMaxRec);
    158          	if(NoReadRecNum >= ZoneMaxRecNum)
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xD305             BCC.N    ??GetReadFlshRecCnt_0
    159          	{
    160          		if(ZoneMaxRecNum > FlshMaxRec)
   \   0000000C   0x428B             CMP      R3,R1
   \   0000000E   0xD201             BCS.N    ??GetReadFlshRecCnt_1
    161          		{
    162          			return	FlshMaxRec;
   \   00000010   0x0018             MOVS     R0,R3
   \   00000012   0xE006             B.N      ??GetReadFlshRecCnt_2
    163          		}
    164          		
    165          		return	ZoneMaxRecNum;
   \                     ??GetReadFlshRecCnt_1: (+1)
   \   00000014   0x0008             MOVS     R0,R1
   \   00000016   0xE004             B.N      ??GetReadFlshRecCnt_2
    166          	}
    167          	else
    168          	{
    169          		if(NoReadRecNum > FlshMaxRec)
   \                     ??GetReadFlshRecCnt_0: (+1)
   \   00000018   0x4293             CMP      R3,R2
   \   0000001A   0xD201             BCS.N    ??GetReadFlshRecCnt_3
    170          		{
    171          			return	FlshMaxRec;
   \   0000001C   0x0018             MOVS     R0,R3
   \   0000001E   0xE000             B.N      ??GetReadFlshRecCnt_2
    172          		}
    173                  
    174          		return	NoReadRecNum;
   \                     ??GetReadFlshRecCnt_3: (+1)
   \   00000020   0x0010             MOVS     R0,R2
   \                     ??GetReadFlshRecCnt_2: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    175          	}
    176          }
    177          

   \                                 In section .data, align 1
    178          uint8_t	l_UnFihCardEvtFlg = NO_ERROR;
   \                     l_UnFihCardEvtFlg:
   \   00000000   0x01               DC8 1
    179          //uint8_t	l_WriteFlgErrCardEvtFlg = NO_ERROR;
    180          
    181          void	DataDensityCard(stcCardFlg *	sCardFlg);
    182          

   \                                 In section .bss, align 4
    183          stcDeviceInfo 	sDeviceInfo;
   \                     sDeviceInfo:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
    184          stcFixInfo		sFixInfo;						
   \                     sFixInfo:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
    185          stcCardIndex	sCardIndex;
   \                     sCardIndex:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
    186          uint8			CardBuf[1024];
   \                     CardBuf:
   \   00000000                      DS8 1024
    187          

   \                                 In section .text, align 2, keep-with-next
    188          void	DataCard(uint8_t copyflg)
    189          {
   \                     DataCard: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
    190          	uint32		FlshRecCnt;	
    191          	uint32		FlshStartRecNum;
    192          //	uint32		CardEndAddr;
    193          	uint32		CardStartAddr;
    194          	uint32		CardMaxRecNum;
    195          	uint32		NoReadRecNum;
    196          	uint16		WriteCardTimes;
    197          	uint32 		CardAddrTmp;
    198              uint32      storeCardRead;
    199          
    200          	//计算地址
    201          	CardAddrTmp = 	CARD_FLG_ADDR+
    202                              sizeof(stcCardID)+
    203                              sizeof(stcCardType)+
    204                              sizeof(stcCardPara)+
    205          					sizeof(stcCardIndex)*100;
   \   00000006   0xF640 0x505C      MOVW     R0,#+3420
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    206          	
    207          	//读取已有IC卡文件数
    208          	ReadCard(CardAddrTmp,(uint8 *)&WriteCardTimes,sizeof(WriteCardTimes));	
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x9801             LDR      R0,[SP, #+4]
   \   00000012   0x.... 0x....      BL       ReadCard
    209              
    210          	//计算数据文件开始地址。
    211          	if(WriteCardTimes == 0 || WriteCardTimes >= 100 ) {
   \   00000016   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??DataCard_0
   \   0000001E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000022   0x2864             CMP      R0,#+100
   \   00000024   0xDB0A             BLT.N    ??DataCard_1
    212          		CardStartAddr = CARD_DATA_ADDR;
   \                     ??DataCard_0: (+1)
   \   00000026   0xF44F 0x50A0      MOV      R0,#+5120
   \   0000002A   0x0004             MOVS     R4,R0
    213          		if(WriteCardTimes > 100)
   \   0000002C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000030   0x2865             CMP      R0,#+101
   \   00000032   0xDB16             BLT.N    ??DataCard_2
    214          			WriteCardTimes = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   0000003A   0xE012             B.N      ??DataCard_2
    215          	} else {
    216          		CardAddrTmp = 	CARD_FLG_ADDR+
    217                                  sizeof(stcCardID)+
    218                                  sizeof(stcCardType)+
    219                                  sizeof(stcCardPara)+
    220          						sizeof(stcCardIndex)*(WriteCardTimes-1);
   \                     ??DataCard_1: (+1)
   \   0000003C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000040   0x0140             LSLS     R0,R0,#+5
   \   00000042   0x30BC             ADDS     R0,R0,#+188
   \   00000044   0x9001             STR      R0,[SP, #+4]
    221          		
    222          		ReadCard(CardAddrTmp,(uint8 *)&sCardIndex,sizeof(stcCardIndex));
   \   00000046   0x2220             MOVS     R2,#+32
   \   00000048   0x....             LDR.N    R1,??DataTable2_1
   \   0000004A   0x9801             LDR      R0,[SP, #+4]
   \   0000004C   0x.... 0x....      BL       ReadCard
    223                  
    224          		CardStartAddr 	= sCardIndex.EndAddr;
   \   00000050   0x....             LDR.N    R0,??DataTable2_1
   \   00000052   0x6980             LDR      R0,[R0, #+24]
   \   00000054   0x0004             MOVS     R4,R0
    225          		
    226          		if(CardStartAddr < CARD_DATA_ADDR) {
   \   00000056   0xF5B4 0x5FA0      CMP      R4,#+5120
   \   0000005A   0xD202             BCS.N    ??DataCard_2
    227          			CardStartAddr = CARD_DATA_ADDR;
   \   0000005C   0xF44F 0x50A0      MOV      R0,#+5120
   \   00000060   0x0004             MOVS     R4,R0
    228          		}
    229          	}
    230              
    231          	//计算写卡索引地址
    232          	CardAddrTmp = 	CARD_FLG_ADDR+
    233                              sizeof(stcCardID)+
    234                              sizeof(stcCardType)+
    235                              sizeof(stcCardPara)+
    236          					sizeof(stcCardIndex)*WriteCardTimes;
   \                     ??DataCard_2: (+1)
   \   00000062   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000066   0x0140             LSLS     R0,R0,#+5
   \   00000068   0x30DC             ADDS     R0,R0,#+220
   \   0000006A   0x9001             STR      R0,[SP, #+4]
    237              
    238          	ReadCard(CardAddrTmp,(uint8 *)&sCardIndex,sizeof(stcCardIndex));
   \   0000006C   0x2220             MOVS     R2,#+32
   \   0000006E   0x....             LDR.N    R1,??DataTable2_1
   \   00000070   0x9801             LDR      R0,[SP, #+4]
   \   00000072   0x.... 0x....      BL       ReadCard
    239              
    240              
    241          	//计算记录条数
    242          	if(Ctrl.sRecNumMgr.IcRead >= Ctrl.sRecNumMgr.CardRead) {
   \   00000076   0x....             LDR.N    R0,??DataTable2_2
   \   00000078   0x6880             LDR      R0,[R0, #+8]
   \   0000007A   0x....             LDR.N    R1,??DataTable2_2
   \   0000007C   0x6909             LDR      R1,[R1, #+16]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD322             BCC.N    ??DataCard_3
    243          		NoReadRecNum	= 		Ctrl.sRecNumMgr.IcRead -
    244                                       	Ctrl.sRecNumMgr.CardRead;  //Flsh的未读记录长度
   \   00000082   0x....             LDR.N    R0,??DataTable2_2
   \   00000084   0x6880             LDR      R0,[R0, #+8]
   \   00000086   0x....             LDR.N    R1,??DataTable2_2
   \   00000088   0x6909             LDR      R1,[R1, #+16]
   \   0000008A   0x1A40             SUBS     R0,R0,R1
   \   0000008C   0x9004             STR      R0,[SP, #+16]
    245                  
    246          		if(copyflg == 1)
   \   0000008E   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD102             BNE.N    ??DataCard_4
    247          			NoReadRecNum = Ctrl.sRecNumMgr.IcRead;			//copy卡
   \   00000096   0x....             LDR.N    R0,??DataTable2_2
   \   00000098   0x6880             LDR      R0,[R0, #+8]
   \   0000009A   0x9004             STR      R0,[SP, #+16]
    248                  
    249                  if(NoReadRecNum < 2)                                //没有新数据记录
   \                     ??DataCard_4: (+1)
   \   0000009C   0x9804             LDR      R0,[SP, #+16]
   \   0000009E   0x2802             CMP      R0,#+2
   \   000000A0   0xD209             BCS.N    ??DataCard_5
    250                  {
    251                      Ctrl.sRunPara.CardType     = DATA_CARD_ERR;    //指示卡错误
   \   000000A2   0xF44F 0x4000      MOV      R0,#+32768
   \   000000A6   0x....             LDR.N    R1,??DataTable2_2
   \   000000A8   0xF8C1 0x00B0      STR      R0,[R1, #+176]
    252                      Ctrl.sRunPara.CardErrData  = 0x04;             //模块无新数据记录
   \   000000AC   0x2004             MOVS     R0,#+4
   \   000000AE   0x....             LDR.N    R1,??DataTable2_2
   \   000000B0   0xF881 0x00B4      STRB     R0,[R1, #+180]
    253                      return;
   \   000000B4   0xE0E2             B.N      ??DataCard_6
    254                  }
    255          	} else {
    256          		Ctrl.sRecNumMgr.CardRead = Ctrl.sRecNumMgr.IcRead;	//序号异常，重新幅值
    257          		NoReadRecNum = 0;
    258                  
    259                  Ctrl.sRunPara.CardType     = DATA_CARD_ERR;    //指示卡错误
    260                  Ctrl.sRunPara.CardErrData  = 0x02;             //记录序号错误。数据重新存储
    261          		return;
    262          	}
    263              
    264          	//取IC卡未写空间长度
    265          	CardMaxRecNum	= GetToEndLen(CardStartAddr) / sizeof(stcFlshRec);	
   \                     ??DataCard_5: (+1)
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       GetToEndLen
   \   000000BC   0x09C0             LSRS     R0,R0,#+7
   \   000000BE   0x9005             STR      R0,[SP, #+20]
    266              
    267              //IC卡可写数据长度小于5条，则范围IC卡已满标识，退出卡操作
    268              if(CardMaxRecNum < 5){
   \   000000C0   0x9805             LDR      R0,[SP, #+20]
   \   000000C2   0x2805             CMP      R0,#+5
   \   000000C4   0xD21A             BCS.N    ??DataCard_7
   \   000000C6   0xE00F             B.N      ??DataCard_8
   \                     ??DataCard_3: (+1)
   \   000000C8   0x....             LDR.N    R0,??DataTable2_2
   \   000000CA   0x6880             LDR      R0,[R0, #+8]
   \   000000CC   0x....             LDR.N    R1,??DataTable2_2
   \   000000CE   0x6108             STR      R0,[R1, #+16]
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x9004             STR      R0,[SP, #+16]
   \   000000D4   0xF44F 0x4000      MOV      R0,#+32768
   \   000000D8   0x....             LDR.N    R1,??DataTable2_2
   \   000000DA   0xF8C1 0x00B0      STR      R0,[R1, #+176]
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0x....             LDR.N    R1,??DataTable2_2
   \   000000E2   0xF881 0x00B4      STRB     R0,[R1, #+180]
   \   000000E6   0xE0C9             B.N      ??DataCard_6
    269                  Ctrl.sRunPara.CardType     = DATA_CARD_ERR;    //指示卡错误
   \                     ??DataCard_8: (+1)
   \   000000E8   0xF44F 0x4000      MOV      R0,#+32768
   \   000000EC   0x....             LDR.N    R1,??DataTable2_2
   \   000000EE   0xF8C1 0x00B0      STR      R0,[R1, #+176]
    270                  Ctrl.sRunPara.CardErrData  = 0x03;             //IC卡已满 
   \   000000F2   0x2003             MOVS     R0,#+3
   \   000000F4   0x....             LDR.N    R1,??DataTable2_2
   \   000000F6   0xF881 0x00B4      STRB     R0,[R1, #+180]
    271                  return;
   \   000000FA   0xE0BF             B.N      ??DataCard_6
    272              }
    273          	//要写数据长度，根据空检大小，剩余记录号，IC卡余量计算。	
    274          	FlshRecCnt 		= GetReadFlshRecCnt(NoReadRecNum,CardMaxRecNum);	
   \                     ??DataCard_7: (+1)
   \   000000FC   0x9905             LDR      R1,[SP, #+20]
   \   000000FE   0x9804             LDR      R0,[SP, #+16]
   \   00000100   0x.... 0x....      BL       GetReadFlshRecCnt
   \   00000104   0x9006             STR      R0,[SP, #+24]
    275              
    276          	//计算开始记录号
    277          	FlshStartRecNum = Ctrl.sRecNumMgr.IcRead  - FlshRecCnt ;
   \   00000106   0x....             LDR.N    R0,??DataTable2_2
   \   00000108   0x6880             LDR      R0,[R0, #+8]
   \   0000010A   0x9906             LDR      R1,[SP, #+24]
   \   0000010C   0x1A40             SUBS     R0,R0,R1
   \   0000010E   0x0005             MOVS     R5,R0
    278              storeCardRead   = Ctrl.sRecNumMgr.IcRead;
   \   00000110   0x....             LDR.N    R0,??DataTable2_2
   \   00000112   0x6880             LDR      R0,[R0, #+8]
   \   00000114   0x9008             STR      R0,[SP, #+32]
    279              /********************************************
    280              *	开始写数据
    281              */
    282          	uint32      MaxWriteLen;							//最大要写卡长度
    283          	uint32      FinishLen = 0;							//已写长度
   \   00000116   0x2700             MOVS     R7,#+0
    284          	uint32      WritePageLen;	
    285          	uint32      NextRecCardAddr;
    286          	uint32      BufWriteLen = 0;
   \   00000118   0x2600             MOVS     R6,#+0
    287              
    288          	MaxWriteLen = FlshRecCnt * sizeof(stcFlshRec);				//总数据长度			
   \   0000011A   0x9806             LDR      R0,[SP, #+24]
   \   0000011C   0x2180             MOVS     R1,#+128
   \   0000011E   0x4348             MULS     R0,R1,R0
   \   00000120   0x9002             STR      R0,[SP, #+8]
    289              
    290          	BufWriteLen = 0;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x0006             MOVS     R6,R0
    291              int writepagetimes = 0;
   \   00000126   0xF05F 0x0800      MOVS     R8,#+0
    292          	while( FinishLen < MaxWriteLen) 	{						//写完退出
   \                     ??DataCard_9: (+1)
   \   0000012A   0x9802             LDR      R0,[SP, #+8]
   \   0000012C   0x4287             CMP      R7,R0
   \   0000012E   0xD24F             BCS.N    ??DataCard_10
    293          	
    294          		ReadFlshRec((stcFlshRec *)&Ctrl.sRec,FlshStartRecNum++);//从flash中读出数据
   \   00000130   0x0029             MOVS     R1,R5
   \   00000132   0x....             LDR.N    R0,??DataTable2_3
   \   00000134   0x.... 0x....      BL       ReadFlshRec
   \   00000138   0x1C6D             ADDS     R5,R5,#+1
    295                  
    296                  if(Ctrl.sRec.StoreCnt == 0xffffffff)
   \   0000013A   0x....             LDR.N    R0,??DataTable2_2
   \   0000013C   0x6A00             LDR      R0,[R0, #+32]
   \   0000013E   0xF110 0x0F01      CMN      R0,#+1
   \   00000142   0xD101             BNE.N    ??DataCard_11
    297                     Ctrl.sRec.StoreCnt  =  FlshStartRecNum;
   \   00000144   0x....             LDR.N    R0,??DataTable2_2
   \   00000146   0x6205             STR      R5,[R0, #+32]
    298                  
    299          		WritePageLen = GetWritePageLen(	CardStartAddr,			//开始地址
    300                                                  FinishLen,				//已完成长度
    301                                                  MaxWriteLen);			//最大数据长度
   \                     ??DataCard_11: (+1)
   \   00000148   0x9A02             LDR      R2,[SP, #+8]
   \   0000014A   0x0039             MOVS     R1,R7
   \   0000014C   0x0020             MOVS     R0,R4
   \   0000014E   0x.... 0x....      BL       GetWritePageLen
   \   00000152   0x9003             STR      R0,[SP, #+12]
    302                  
    303          		memcpy(&CardBuf[BufWriteLen],(uint8_t *)&Ctrl.sRec,sizeof(stcFlshRec));
   \   00000154   0xF05F 0x0980      MOVS     R9,#+128
   \   00000158   0x.... 0x....      LDR.W    R10,??DataTable2_3
   \   0000015C   0x....             LDR.N    R0,??DataTable2_4
   \   0000015E   0xEB16 0x0B00      ADDS     R11,R6,R0
   \   00000162   0x464A             MOV      R2,R9
   \   00000164   0x4651             MOV      R1,R10
   \   00000166   0x4658             MOV      R0,R11
   \   00000168   0x.... 0x....      BL       __aeabi_memcpy
    304          		BufWriteLen += sizeof(stcFlshRec);
   \   0000016C   0x3680             ADDS     R6,R6,#+128
    305                  
    306          		if(WritePageLen == BufWriteLen || WritePageLen < BufWriteLen) {
   \   0000016E   0x9803             LDR      R0,[SP, #+12]
   \   00000170   0x42B0             CMP      R0,R6
   \   00000172   0xD002             BEQ.N    ??DataCard_12
   \   00000174   0x9803             LDR      R0,[SP, #+12]
   \   00000176   0x42B0             CMP      R0,R6
   \   00000178   0xD2D7             BCS.N    ??DataCard_9
    307          			NextRecCardAddr = CardStartAddr + FinishLen;        //IC卡下一地址
   \                     ??DataCard_12: (+1)
   \   0000017A   0x1938             ADDS     R0,R7,R4
   \   0000017C   0x9007             STR      R0,[SP, #+28]
    308                      
    309             			WriteCard(NextRecCardAddr,CardBuf,WritePageLen);    //写卡
   \   0000017E   0x9A03             LDR      R2,[SP, #+12]
   \   00000180   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000182   0x....             LDR.N    R1,??DataTable2_4
   \   00000184   0x9807             LDR      R0,[SP, #+28]
   \   00000186   0x.... 0x....      BL       WriteCard
    310               		
    311               		FinishLen += WritePageLen;                          //将要完成写长度
   \   0000018A   0x9803             LDR      R0,[SP, #+12]
   \   0000018C   0x19C7             ADDS     R7,R0,R7
    312                      
    313          			BufWriteLen = 0;
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0x0006             MOVS     R6,R0
    314                      
    315          			Ctrl.sRunPara.CardType = DATA_CARD_DIS;            //IC卡指示
   \   00000192   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000196   0x....             LDR.N    R1,??DataTable2_2
   \   00000198   0xF8C1 0x00B0      STR      R0,[R1, #+176]
    316                      
    317                      writepagetimes++;
   \   0000019C   0xF118 0x0801      ADDS     R8,R8,#+1
    318                      if(writepagetimes % 10 == 0) {
   \   000001A0   0x200A             MOVS     R0,#+10
   \   000001A2   0xFB98 0xF1F0      SDIV     R1,R8,R0
   \   000001A6   0xFB00 0x8011      MLS      R0,R0,R1,R8
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD10B             BNE.N    ??DataCard_13
    319                          OSSetWdtFlag(( OS_FLAGS     ) WDT_FLAG_DUMP); 
   \   000001AE   0x2002             MOVS     R0,#+2
   \   000001B0   0x.... 0x....      BL       OSSetWdtFlag
    320                          OS_ERR  os_err;
    321                          BSP_LED_Toggle(8);
   \   000001B4   0x2008             MOVS     R0,#+8
   \   000001B6   0x.... 0x....      BL       BSP_LED_Toggle
    322                          
    323                          OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.CommEvtFlagGrp,
    324                                     ( OS_FLAGS      )COMM_EVT_FLAG_PLUG_CARD,
    325                                     ( OS_OPT        )OS_OPT_POST_FLAG_SET,
    326                                     ( OS_ERR       *)&os_err);
   \   000001BA   0xAB0B             ADD      R3,SP,#+44
   \   000001BC   0x2200             MOVS     R2,#+0
   \   000001BE   0x2140             MOVS     R1,#+64
   \   000001C0   0x....             LDR.N    R0,??DataTable2_5
   \   000001C2   0x.... 0x....      BL       OSFlagPost
    327          
    328                      }
    329                      
    330                      //没有ic卡也要退出
    331                      if(ReadIC_SWT() == 0)
   \                     ??DataCard_13: (+1)
   \   000001C6   0x.... 0x....      BL       ReadIC_SWT
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD1AD             BNE.N    ??DataCard_9
    332                          return;
   \   000001CE   0xE055             B.N      ??DataCard_6
    333          		}
    334          	}
    335              if ( writepagetimes ) {
   \                     ??DataCard_10: (+1)
   \   000001D0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001D4   0xD009             BEQ.N    ??DataCard_14
    336                  OS_ERR  os_err;
    337                  BSP_LED_Toggle(8);
   \   000001D6   0x2008             MOVS     R0,#+8
   \   000001D8   0x.... 0x....      BL       BSP_LED_Toggle
    338                  
    339                  OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.CommEvtFlagGrp,
    340                             ( OS_FLAGS      )COMM_EVT_FLAG_PLUG_CARD,
    341                             ( OS_OPT        )OS_OPT_POST_FLAG_SET,
    342                             ( OS_ERR       *)&os_err);
   \   000001DC   0xF10D 0x0302      ADD      R3,SP,#+2
   \   000001E0   0x2200             MOVS     R2,#+0
   \   000001E2   0x2140             MOVS     R1,#+64
   \   000001E4   0x....             LDR.N    R0,??DataTable2_5
   \   000001E6   0x.... 0x....      BL       OSFlagPost
    343          
    344               }
    345          	/********************************************
    346          	*	 IC卡完成，修改索引页
    347          	*/
    348              //sCardIndex.LocoNum      = Ctrl.sRec.LocoNum;
    349              memcpy((uint8 *)&sCardIndex.LocoNum,(uint8 *)&Ctrl.sRec.LocoNum,sizeof(sCardIndex.LocoNum));
   \                     ??DataCard_14: (+1)
   \   000001EA   0x2002             MOVS     R0,#+2
   \   000001EC   0x900A             STR      R0,[SP, #+40]
   \   000001EE   0x....             LDR.N    R0,??DataTable2_6
   \   000001F0   0x9009             STR      R0,[SP, #+36]
   \   000001F2   0x.... 0x....      LDR.W    R9,??DataTable2_7
   \   000001F6   0x9A0A             LDR      R2,[SP, #+40]
   \   000001F8   0x9909             LDR      R1,[SP, #+36]
   \   000001FA   0x4648             MOV      R0,R9
   \   000001FC   0x.... 0x....      BL       __aeabi_memcpy
    350              //sCardIndex.LocoType     = Ctrl.sRec.LocoTyp;
    351              memcpy((uint8 *)&sCardIndex.LocoType,(uint8 *)&Ctrl.sRec.LocoTyp,sizeof(Ctrl.sRec.LocoTyp));
   \   00000200   0xF05F 0x0901      MOVS     R9,#+1
   \   00000204   0x.... 0x....      LDR.W    R10,??DataTable2_8
   \   00000208   0x.... 0x....      LDR.W    R11,??DataTable2_1
   \   0000020C   0x464A             MOV      R2,R9
   \   0000020E   0x4651             MOV      R1,R10
   \   00000210   0x4658             MOV      R0,R11
   \   00000212   0x.... 0x....      BL       __aeabi_memcpy
    352          
    353          	sCardIndex.StartAddr	    = CardStartAddr;
   \   00000216   0x....             LDR.N    R0,??DataTable2_1
   \   00000218   0x6144             STR      R4,[R0, #+20]
    354          	sCardIndex.EndAddr 		    = CardStartAddr + MaxWriteLen;
   \   0000021A   0x9802             LDR      R0,[SP, #+8]
   \   0000021C   0x1900             ADDS     R0,R0,R4
   \   0000021E   0x....             LDR.N    R1,??DataTable2_1
   \   00000220   0x6188             STR      R0,[R1, #+24]
    355          	sCardIndex.RecLen		    = MaxWriteLen;
   \   00000222   0x9802             LDR      R0,[SP, #+8]
   \   00000224   0x....             LDR.N    R1,??DataTable2_1
   \   00000226   0x8388             STRH     R0,[R1, #+28]
    356          	sCardIndex.RecNum		    = MaxWriteLen/(sizeof(stcFlshRec));
   \   00000228   0x9802             LDR      R0,[SP, #+8]
   \   0000022A   0x09C0             LSRS     R0,R0,#+7
   \   0000022C   0x....             LDR.N    R1,??DataTable2_1
   \   0000022E   0x83C8             STRH     R0,[R1, #+30]
    357          	WriteCardTimes++;									
   \   00000230   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000234   0x1C40             ADDS     R0,R0,#+1
   \   00000236   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    358                  
    359          	CardAddrTmp =	CARD_FLG_ADDR+
    360                              sizeof(stcCardID)+
    361                              sizeof(stcCardType)+
    362                              sizeof(stcCardPara)+
    363          					sizeof(stcCardIndex)*100; 
   \   0000023A   0xF640 0x505C      MOVW     R0,#+3420
   \   0000023E   0x9001             STR      R0,[SP, #+4]
    364          	
    365          	WriteCard(CardAddrTmp,(uint8 *)&WriteCardTimes,sizeof(WriteCardTimes));	
   \   00000240   0x2202             MOVS     R2,#+2
   \   00000242   0x4669             MOV      R1,SP
   \   00000244   0x9801             LDR      R0,[SP, #+4]
   \   00000246   0x.... 0x....      BL       WriteCard
    366              
    367          	CardAddrTmp = 	CARD_FLG_ADDR+
    368                              sizeof(stcCardID)+
    369                              sizeof(stcCardType)+
    370                              sizeof(stcCardPara)+
    371          					sizeof(stcCardIndex)*(WriteCardTimes-1);
   \   0000024A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000024E   0x0140             LSLS     R0,R0,#+5
   \   00000250   0x30BC             ADDS     R0,R0,#+188
   \   00000252   0x9001             STR      R0,[SP, #+4]
    372          	
    373          	WriteCard(CardAddrTmp,(uint8_t *)&sCardIndex,sizeof(stcCardIndex));
   \   00000254   0x2220             MOVS     R2,#+32
   \   00000256   0x....             LDR.N    R1,??DataTable2_1
   \   00000258   0x9801             LDR      R0,[SP, #+4]
   \   0000025A   0x.... 0x....      BL       WriteCard
    374              
    375          	if(copyflg == 0) {
   \   0000025E   0xF89D 0x0030      LDRB     R0,[SP, #+48]
   \   00000262   0x2800             CMP      R0,#+0
   \   00000264   0xD105             BNE.N    ??DataCard_15
    376                  //Ctrl.sRecNumMgr.CardRead   = Ctrl.sRecNumMgr.GrsRead; //已读记录号
    377                  Ctrl.sRecNumMgr.CardRead   = storeCardRead; //已读记录号
   \   00000266   0x9808             LDR      R0,[SP, #+32]
   \   00000268   0x....             LDR.N    R1,??DataTable2_2
   \   0000026A   0x6108             STR      R0,[R1, #+16]
    378                  
    379          		FRAM_StoreRecNumMgr((StrRecNumMgr * )&Ctrl.sRecNumMgr);
   \   0000026C   0x....             LDR.N    R0,??DataTable2_9
   \   0000026E   0x.... 0x....      BL       FRAM_StoreRecNumMgr
    380          	}
    381          	
    382          	Ctrl.sRunPara.CardType = DATA_CARD_FIN;					//IC卡结束
   \                     ??DataCard_15: (+1)
   \   00000272   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000276   0x....             LDR.N    R1,??DataTable2_2
   \   00000278   0xF8C1 0x00B0      STR      R0,[R1, #+176]
    383          } 
   \                     ??DataCard_6: (+1)
   \   0000027C   0xB00D             ADD      SP,SP,#+52
   \   0000027E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    384          
    385          uint32  GetRecNumAddr(uint32 FlshRecNum);
    386          uint8 ReadFlsh(uint32 Addr,uint8 *buf,uint32 Len);
    387          
    388          
    389          ////-------------------------------------------------------------------------------
    390          ////oˉêy??3?:        	stcFlshRec	ReadFlshRec(uint32	FlshRecNum)
    391          ////oˉêy1|?ü:       	?á???¨á÷??o?μ?FLSH????
    392          ////è??ú2?êy:        	?T
    393          ////3??ú2?êy:      	???¨á÷??o?μ?Flsh????
    394          ////-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    395          uint8	ReadFlshRec(stcFlshRec * sFlshRec,uint32	FlshRecNum)
    396          {
   \                     ReadFlshRec: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    397          	uint32		FlshAddr;
    398          	
    399              if(FlshRecNum==0xffffffff)      //记录号异常，退出
   \   00000006   0xF115 0x0F01      CMN      R5,#+1
   \   0000000A   0xD101             BNE.N    ??ReadFlshRec_0
    400                  return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00D             B.N      ??ReadFlshRec_1
    401              
    402          	FlshAddr = GetRecNumAddr( FlshRecNum );						
   \                     ??ReadFlshRec_0: (+1)
   \   00000010   0x0028             MOVS     R0,R5
   \   00000012   0x.... 0x....      BL       GetRecNumAddr
   \   00000016   0x0006             MOVS     R6,R0
    403              
    404          	if(ReadFlsh(FlshAddr,(uint8 *)sFlshRec,sizeof(stcFlshRec)))
   \   00000018   0x2280             MOVS     R2,#+128
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       ReadFlsh
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??ReadFlshRec_2
    405          	{
    406          		return 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE000             B.N      ??ReadFlshRec_1
    407          	}
    408          	
    409          	return	0;
   \                     ??ReadFlshRec_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??ReadFlshRec_1: (+1)
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    410          }
    411          
    412          
    413          extern  stcCardFlg	l_sCardFlg;
    414          extern	uint16	l_CardType;
    415          
    416          extern	uint32_t		l_CardPageSize;	
    417          extern	uint32_t		l_CardPageNum;
    418          //-------------------------------------------------------------------------------------------------
    419          //函数名称:             uint32_t	GetCardMaxRecNum(void)
    420          //函数功能:             取一张IC卡最大能存最大的数据记录数
    421          //入口参数:             整个卡结构体
    422          //出口参数:             是否成功
    423          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    424          uint32_t	GetCardMaxRecNum(void)
    425          {
    426          	uint32_t	RecNum;
    427          	
    428          	RecNum = (l_CardPageNum*l_CardPageSize - CARD_DATA_ADDR)/ sizeof(stcFlshRec);
   \                     GetCardMaxRecNum: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable2_10
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x....             LDR.N    R2,??DataTable2_11
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x4351             MULS     R1,R2,R1
   \   0000000A   0xF5B1 0x51A0      SUBS     R1,R1,#+5120
   \   0000000E   0x09C9             LSRS     R1,R1,#+7
   \   00000010   0x0008             MOVS     R0,R1
    429          	
    430          	return	RecNum;
   \   00000012   0x4770             BX       LR               ;; return
    431          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     sCardIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     Ctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     Ctrl+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     CardBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     Ctrl+0x275

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     Ctrl+0x2E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     sCardIndex+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     Ctrl+0x2C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x........         DC32     Ctrl+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x........         DC32     l_CardPageNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x........         DC32     l_CardPageSize

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x25 0x75          DC8 "%u  %u"
   \              0x20 0x20    
   \              0x25 0x75    
   \              0x00         
   \   00000007   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      88   DataCard
        88   -> BSP_LED_Toggle
        88   -> FRAM_StoreRecNumMgr
        88   -> GetReadFlshRecCnt
        88   -> GetToEndLen
        88   -> GetWritePageLen
        88   -> OSFlagPost
        88   -> OSSetWdtFlag
        88   -> ReadCard
        88   -> ReadFlshRec
        88   -> ReadIC_SWT
        88   -> WriteCard
        88   -> __aeabi_memcpy
     160   FlshRecToCardRec
       160   -> __aeabi_memcpy
       160   -> __aeabi_memcpy4
       0   GetCardMaxRecNum
       0   GetReadFlshRecCnt
      32   GetWritePageLen
        32   -> GetCardPageSize
      16   ReadCardDisplay
        16   -> DisplaySet
      16   ReadFlshRec
        16   -> GetRecNumAddr
        16   -> ReadFlsh
    1208   StoreCardRec
      1208   -> GetPlugFlg
      1208   -> GetWritePageLen
      1208   -> ReadCardDisplay
      1208   -> ReadFlshRec
      1208   -> WriteCard
      1208   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       8  ?_0
    1024  CardBuf
     642  DataCard
      42  FlshRecToCardRec
      20  GetCardMaxRecNum
      36  GetReadFlshRecCnt
      48  GetWritePageLen
      42  ReadCardDisplay
      46  ReadFlshRec
     152  StoreCardRec
       1  l_UnFihCardEvtFlg
      32  sCardIndex
      40  sDeviceInfo
      28  sFixInfo

 
 1 124 bytes in section .bss
     1 byte  in section .data
     8 bytes in section .rodata
 1 076 bytes in section .text
 
 1 076 bytes of CODE  memory
     8 bytes of CONST memory
 1 125 bytes of DATA  memory

Errors: none
Warnings: 1

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Dec/2017  08:42:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_mutex.c
#    Command line =  
#        "F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_mutex.c" -D
#        RELEASE -lCN "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\os_mutex.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\os_mutex.o
#
###############################################################################

F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_mutex.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   MUTEX MANAGEMENT
     10          *
     11          * File    : OS_MUTEX.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_mutex__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
     44          /*
     45          ************************************************************************************************************************
     46          *                                                   CREATE A MUTEX
     47          *
     48          * Description: This function creates a mutex.
     49          *
     50          * Arguments  : p_mutex       is a pointer to the mutex to initialize.  Your application is responsible for allocating
     51          *                            storage for the mutex.
     52          *
     53          *              p_name        is a pointer to the name you would like to give the mutex.
     54          *
     55          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     56          *
     57          *                                OS_ERR_NONE                    If the call was successful
     58          *                                OS_ERR_CREATE_ISR              If you called this function from an ISR
     59          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the mutex after you called
     60          *                                                                 OSSafetyCriticalStart()
     61          *                                OS_ERR_OBJ_PTR_NULL            If 'p_mutex' is a NULL pointer
     62          *
     63          * Returns    : none
     64          *
     65          * Note(s)    : none
     66          ************************************************************************************************************************
     67          */
     68          

   \                                 In section .text, align 2, keep-with-next
     69          void  OSMutexCreate (OS_MUTEX  *p_mutex,
     70                               CPU_CHAR  *p_name,
     71                               OS_ERR    *p_err)
     72          {
   \                     OSMutexCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     73              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
     74          
     75          
     76          #ifdef OS_SAFETY_CRITICAL
     77              if (p_err == DEF_NULL) {
     78                  OS_SAFETY_CRITICAL_EXCEPTION();
     79                  return;
     80              }
     81          #endif
     82          
     83          #ifdef OS_SAFETY_CRITICAL_IEC61508
     84              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     85                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     86                  return;
     87              }
     88          #endif
     89          
     90          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
     91              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSMutexCreate_0
     92                 *p_err = OS_ERR_CREATE_ISR;
   \   00000014   0xF642 0x60E1      MOVW     R0,#+12001
   \   00000018   0x8030             STRH     R0,[R6, #+0]
     93                  return;
   \   0000001A   0xE02C             B.N      ??OSMutexCreate_1
     94              }
     95          #endif
     96          
     97          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
     98              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexCreate_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD103             BNE.N    ??OSMutexCreate_2
     99                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8030             STRH     R0,[R6, #+0]
    100                  return;
   \   00000026   0xE026             B.N      ??OSMutexCreate_1
    101              }
    102          #endif
    103          
    104              CPU_CRITICAL_ENTER();
   \                     ??OSMutexCreate_2: (+1)
   \   00000028   0x.... 0x....      BL       CPU_SR_Save
   \   0000002C   0x0007             MOVS     R7,R0
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStart
    105          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    106              p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;            /* Mark the data structure as a mutex                   */
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable7_2  ;; 0x5854554d
   \   00000036   0x6020             STR      R0,[R4, #+0]
    107          #endif
    108          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    109              p_mutex->NamePtr           =  p_name;
   \   00000038   0x6065             STR      R5,[R4, #+4]
    110          #else
    111              (void)p_name;
    112          #endif
    113              p_mutex->MutexGrpNextPtr   = DEF_NULL;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6220             STR      R0,[R4, #+32]
    114              p_mutex->OwnerTCBPtr       = DEF_NULL;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6260             STR      R0,[R4, #+36]
    115              p_mutex->OwnerNestingCtr   = 0u;                            /* Mutex is available                                   */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF884 0x0028      STRB     R0,[R4, #+40]
    116          #if (OS_CFG_TS_EN == DEF_ENABLED)
    117              p_mutex->TS                = 0u;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x62E0             STR      R0,[R4, #+44]
    118          #endif
    119              OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
   \   0000004C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000050   0x.... 0x....      BL       OS_PendListInit
    120          
    121          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    122              OS_MutexDbgListAdd(p_mutex);
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       OS_MutexDbgListAdd
    123              OSMutexQty++;
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   0000005E   0x8800             LDRH     R0,[R0, #+0]
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   00000066   0x8008             STRH     R0,[R1, #+0]
    124          #endif
    125          
    126              OS_TRACE_MUTEX_CREATE(p_mutex, p_name);
    127              CPU_CRITICAL_EXIT();
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x0038             MOVS     R0,R7
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
    128             *p_err = OS_ERR_NONE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x8030             STRH     R0,[R6, #+0]
    129          }
   \                     ??OSMutexCreate_1: (+1)
   \   00000076   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    130          
    131          
    132          /*
    133          ************************************************************************************************************************
    134          *                                                   DELETE A MUTEX
    135          *
    136          * Description: This function deletes a mutex and readies all tasks pending on the mutex.
    137          *
    138          * Arguments  : p_mutex       is a pointer to the mutex to delete
    139          *
    140          *              opt           determines delete options as follows:
    141          *
    142          *                                OS_OPT_DEL_NO_PEND          Delete mutex ONLY if no task pending
    143          *                                OS_OPT_DEL_ALWAYS           Deletes the mutex even if tasks are waiting.
    144          *                                                            In this case, all the tasks pending will be readied.
    145          *
    146          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    147          *
    148          *                                OS_ERR_NONE                    The call was successful and the mutex was deleted
    149          *                                OS_ERR_DEL_ISR                 If you attempted to delete the mutex from an ISR
    150          *                                OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the mutex after you called
    151          *                                                                 OSStart()
    152          *                                OS_ERR_OBJ_PTR_NULL            If 'p_mutex' is a NULL pointer
    153          *                                OS_ERR_OBJ_TYPE                If 'p_mutex' is not pointing to a mutex
    154          *                                OS_ERR_OPT_INVALID             An invalid option was specified
    155          *                                OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    156          *                                OS_ERR_TASK_WAITING            One or more tasks were waiting on the mutex
    157          *
    158          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    159          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    160          *
    161          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the mutex MUST
    162          *                 check the return code of OSMutexPend().
    163          *
    164          *              2) Because ALL tasks pending on the mutex will be readied, you MUST be careful in applications where the
    165          *                 mutex is used for mutual exclusion because the resource(s) will no longer be guarded by the mutex.
    166          ************************************************************************************************************************
    167          */
    168          
    169          #if (OS_CFG_MUTEX_DEL_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    170          OS_OBJ_QTY  OSMutexDel (OS_MUTEX  *p_mutex,
    171                                  OS_OPT     opt,
    172                                  OS_ERR    *p_err)
    173          {
   \                     OSMutexDel: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    174              OS_OBJ_QTY     nbr_tasks;
    175              OS_PEND_LIST  *p_pend_list;
    176              OS_TCB        *p_tcb;
    177              OS_TCB        *p_tcb_owner;
    178              CPU_TS         ts;
    179          #if (OS_CFG_MUTEX_EN == DEF_ENABLED)
    180              OS_PRIO        prio_new;
    181          #endif
    182              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    183          
    184          
    185          #ifdef OS_SAFETY_CRITICAL
    186              if (p_err == DEF_NULL) {
    187                  OS_SAFETY_CRITICAL_EXCEPTION();
    188                  return (0u);
    189              }
    190          #endif
    191          
    192              OS_TRACE_MUTEX_DEL_ENTER(p_mutex, opt);
    193          
    194          #ifdef OS_SAFETY_CRITICAL_IEC61508
    195              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    196                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    197                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    198                  return (0u);
    199              }
    200          #endif
    201          
    202          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    203              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to delete a mutex from an ISR            */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??OSMutexDel_0
    204                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_DEL_ISR);
    205                 *p_err = OS_ERR_DEL_ISR;
   \   0000001A   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    206                  return (0u);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE09F             B.N      ??OSMutexDel_1
    207              }
    208          #endif
    209          
    210          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    211              if (OSRunning != OS_STATE_OS_RUNNING) {
    212                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    213                 *p_err = OS_ERR_OS_NOT_RUNNING;
    214                  return (0u);
    215              }
    216          #endif
    217          
    218          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    219              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexDel_0: (+1)
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD104             BNE.N    ??OSMutexDel_2
    220                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    221                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000028   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002C   0x8030             STRH     R0,[R6, #+0]
    222                  return (0u);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE098             B.N      ??OSMutexDel_1
    223              }
    224          #endif
    225          
    226          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    227              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexDel_2: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable7_2  ;; 0x5854554d
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD004             BEQ.N    ??OSMutexDel_3
    228                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OBJ_TYPE);
    229                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000003C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000040   0x8030             STRH     R0,[R6, #+0]
    230                  return (0u);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE08E             B.N      ??OSMutexDel_1
    231              }
    232          #endif
    233          
    234              CPU_CRITICAL_ENTER();
   \                     ??OSMutexDel_3: (+1)
   \   00000046   0x.... 0x....      BL       CPU_SR_Save
   \   0000004A   0x4683             MOV      R11,R0
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStart
    235              p_pend_list = &p_mutex->PendList;
   \   00000050   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000054   0x4680             MOV      R8,R0
    236              nbr_tasks   = 0u;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x0007             MOVS     R7,R0
    237              switch (opt) {
   \   0000005A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD002             BEQ.N    ??OSMutexDel_4
   \   00000060   0x2D01             CMP      R5,#+1
   \   00000062   0xD029             BEQ.N    ??OSMutexDel_5
   \   00000064   0xE074             B.N      ??OSMutexDel_6
    238                  case OS_OPT_DEL_NO_PEND:                                /* Delete mutex only if no task waiting                 */
    239                       if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSMutexDel_4: (+1)
   \   00000066   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD11B             BNE.N    ??OSMutexDel_7
    240          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    241                           OS_MutexDbgListRemove(p_mutex);
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       OS_MutexDbgListRemove
    242                           OSMutexQty--;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   00000078   0x8800             LDRH     R0,[R0, #+0]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   00000080   0x8008             STRH     R0,[R1, #+0]
    243          #endif
    244                           OS_TRACE_MUTEX_DEL(p_mutex);
    245                           if (p_mutex->OwnerTCBPtr != DEF_NULL) {        /* Does the mutex belong to a task?                     */
   \   00000082   0x6A60             LDR      R0,[R4, #+36]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD003             BEQ.N    ??OSMutexDel_8
    246                               OS_MutexGrpRemove(p_mutex->OwnerTCBPtr, p_mutex); /* yes, remove it from the task group.           */
   \   00000088   0x0021             MOVS     R1,R4
   \   0000008A   0x6A60             LDR      R0,[R4, #+36]
   \   0000008C   0x.... 0x....      BL       OS_MutexGrpRemove
    247                           }
    248                           OS_MutexClr(p_mutex);
   \                     ??OSMutexDel_8: (+1)
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       OS_MutexClr
    249                           CPU_CRITICAL_EXIT();
   \   00000096   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x.... 0x....      BL       CPU_SR_Restore
    250                          *p_err = OS_ERR_NONE;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x8030             STRH     R0,[R6, #+0]
   \   000000A4   0xE007             B.N      ??OSMutexDel_9
    251                       } else {
    252                           CPU_CRITICAL_EXIT();
   \                     ??OSMutexDel_7: (+1)
   \   000000A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AA   0x4658             MOV      R0,R11
   \   000000AC   0x.... 0x....      BL       CPU_SR_Restore
    253                          *p_err = OS_ERR_TASK_WAITING;
   \   000000B0   0xF247 0x105F      MOVW     R0,#+29023
   \   000000B4   0x8030             STRH     R0,[R6, #+0]
    254                       }
    255                       break;
   \                     ??OSMutexDel_9: (+1)
   \   000000B6   0xE053             B.N      ??OSMutexDel_10
    256          
    257                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the mutex                              */
    258          #if (OS_CFG_TS_EN == DEF_ENABLED)
    259                       ts = OS_TS_GET();                                  /* Get timestamp                                        */
   \                     ??OSMutexDel_5: (+1)
   \   000000B8   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000BC   0x9000             STR      R0,[SP, #+0]
    260          #else
    261                       ts = 0u;
    262          #endif
    263                       while (p_pend_list->HeadPtr != DEF_NULL) {         /* Remove all tasks from the pend list                  */
   \                     ??OSMutexDel_11: (+1)
   \   000000BE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD009             BEQ.N    ??OSMutexDel_12
    264                           p_tcb = p_pend_list->HeadPtr;
   \   000000C6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000CA   0x9001             STR      R0,[SP, #+4]
    265                           OS_PendAbort(p_tcb,
    266                                        ts,
    267                                        OS_STATUS_PEND_DEL);
   \   000000CC   0x2202             MOVS     R2,#+2
   \   000000CE   0x9900             LDR      R1,[SP, #+0]
   \   000000D0   0x9801             LDR      R0,[SP, #+4]
   \   000000D2   0x.... 0x....      BL       OS_PendAbort
    268                           nbr_tasks++;
   \   000000D6   0x1C7F             ADDS     R7,R7,#+1
   \   000000D8   0xE7F1             B.N      ??OSMutexDel_11
    269                       }
    270          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    271                       OS_MutexDbgListRemove(p_mutex);
   \                     ??OSMutexDel_12: (+1)
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       OS_MutexDbgListRemove
    272                       OSMutexQty--;
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   000000E4   0x8800             LDRH     R0,[R0, #+0]
   \   000000E6   0x1E40             SUBS     R0,R0,#+1
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   000000EC   0x8008             STRH     R0,[R1, #+0]
    273          #endif
    274                       OS_TRACE_MUTEX_DEL(p_mutex);
    275                       p_tcb_owner = p_mutex->OwnerTCBPtr;
   \   000000EE   0x6A60             LDR      R0,[R4, #+36]
   \   000000F0   0x4681             MOV      R9,R0
    276                       if (p_tcb_owner != DEF_NULL) {                     /* Does the mutex belong to a task?                     */
   \   000000F2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F6   0xD003             BEQ.N    ??OSMutexDel_13
    277                           OS_MutexGrpRemove(p_tcb_owner, p_mutex);       /* yes, remove it from the task group.                  */
   \   000000F8   0x0021             MOVS     R1,R4
   \   000000FA   0x4648             MOV      R0,R9
   \   000000FC   0x.... 0x....      BL       OS_MutexGrpRemove
    278                       }
    279          
    280          
    281                       if (p_tcb_owner != DEF_NULL) {                     /* Did we had to change the prio of owner?              */
   \                     ??OSMutexDel_13: (+1)
   \   00000100   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000104   0xD017             BEQ.N    ??OSMutexDel_14
    282                           if (p_tcb_owner->Prio != p_tcb_owner->BasePrio) {
   \   00000106   0xF899 0x003F      LDRB     R0,[R9, #+63]
   \   0000010A   0xF899 0x1040      LDRB     R1,[R9, #+64]
   \   0000010E   0x4288             CMP      R0,R1
   \   00000110   0xD011             BEQ.N    ??OSMutexDel_14
    283                               prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \   00000112   0x4648             MOV      R0,R9
   \   00000114   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   00000118   0x4682             MOV      R10,R0
    284                               prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
   \   0000011A   0xF899 0x0040      LDRB     R0,[R9, #+64]
   \   0000011E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000122   0x4550             CMP      R0,R10
   \   00000124   0xD202             BCS.N    ??OSMutexDel_15
   \   00000126   0xF899 0xA040      LDRB     R10,[R9, #+64]
   \   0000012A   0xE7FF             B.N      ??OSMutexDel_16
    285                               OS_TaskChangePrio(p_tcb_owner, prio_new);
   \                     ??OSMutexDel_15: (+1)
   \                     ??OSMutexDel_16: (+1)
   \   0000012C   0x4651             MOV      R1,R10
   \   0000012E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000130   0x4648             MOV      R0,R9
   \   00000132   0x.... 0x....      BL       OS_TaskChangePrio
    286                               OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    287                           }
    288                       }
    289          
    290                       OS_MutexClr(p_mutex);
   \                     ??OSMutexDel_14: (+1)
   \   00000136   0x0020             MOVS     R0,R4
   \   00000138   0x.... 0x....      BL       OS_MutexClr
    291                       CPU_CRITICAL_EXIT();
   \   0000013C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000140   0x4658             MOV      R0,R11
   \   00000142   0x.... 0x....      BL       CPU_SR_Restore
    292                       OSSched();                                         /* Find highest priority task ready to run              */
   \   00000146   0x.... 0x....      BL       OSSched
    293                      *p_err = OS_ERR_NONE;
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x8030             STRH     R0,[R6, #+0]
    294                       break;
   \   0000014E   0xE007             B.N      ??OSMutexDel_10
    295          
    296                  default:
    297                       CPU_CRITICAL_EXIT();
   \                     ??OSMutexDel_6: (+1)
   \   00000150   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000154   0x4658             MOV      R0,R11
   \   00000156   0x.... 0x....      BL       CPU_SR_Restore
    298                      *p_err = OS_ERR_OPT_INVALID;
   \   0000015A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000015E   0x8030             STRH     R0,[R6, #+0]
    299                       break;
    300              }
    301              OS_TRACE_MUTEX_DEL_EXIT(*p_err);
    302              return (nbr_tasks);
   \                     ??OSMutexDel_10: (+1)
   \   00000160   0x0038             MOVS     R0,R7
   \   00000162   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexDel_1: (+1)
   \   00000164   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    303          }
    304          #endif
    305          
    306          
    307          /*
    308          ************************************************************************************************************************
    309          *                                                    PEND ON MUTEX
    310          *
    311          * Description: This function waits for a mutex.
    312          *
    313          * Arguments  : p_mutex       is a pointer to the mutex
    314          *
    315          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    316          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    317          *                            0, however, your task will wait forever at the specified mutex or, until the resource
    318          *                            becomes available.
    319          *
    320          *              opt           determines whether the user wants to block if the mutex is not available or not:
    321          *
    322          *                                OS_OPT_PEND_BLOCKING
    323          *                                OS_OPT_PEND_NON_BLOCKING
    324          *
    325          *              p_ts          is a pointer to a variable that will receive the timestamp of when the mutex was posted or
    326          *                            pend aborted or the mutex deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you
    327          *                            will not get the timestamp.  In other words, passing a NULL pointer is valid and indicates
    328          *                            that you don't need the timestamp.
    329          *
    330          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    331          *
    332          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    333          *                                OS_ERR_MUTEX_OWNER        If calling task already owns the mutex
    334          *                                OS_ERR_MUTEX_OVF          Mutex nesting counter overflowed
    335          *                                OS_ERR_OBJ_DEL            If 'p_mutex' was deleted
    336          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    337          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    338          *                                OS_ERR_OPT_INVALID        If you didn't specify a valid option
    339          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    340          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    341          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    342          *                                                          would lead to a suspension
    343          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the mutex was not
    344          *                                                          available
    345          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    346          *                                OS_ERR_STATUS_INVALID     If the pend status has an invalid value
    347          *                                OS_ERR_TIMEOUT            The mutex was not received within the specified timeout
    348          *
    349          * Returns    : none
    350          *
    351          * Note(s)    : none
    352          ************************************************************************************************************************
    353          */
    354          

   \                                 In section .text, align 2, keep-with-next
    355          void  OSMutexPend (OS_MUTEX  *p_mutex,
    356                             OS_TICK    timeout,
    357                             OS_OPT     opt,
    358                             CPU_TS    *p_ts,
    359                             OS_ERR    *p_err)
    360          {
   \                     OSMutexPend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    361              OS_TCB  *p_tcb;
    362              CPU_SR_ALLOC();
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
    363          
    364          
    365          #if (OS_CFG_TS_EN == DEF_DISABLED)
    366              (void)p_ts;                                                 /* Prevent compiler warning for not using 'ts'          */
    367          #endif
    368          
    369          #ifdef OS_SAFETY_CRITICAL
    370              if (p_err == DEF_NULL) {
    371                  OS_SAFETY_CRITICAL_EXCEPTION();
    372                  return;
    373              }
    374          #endif
    375          
    376              OS_TRACE_MUTEX_PEND_ENTER(p_mutex, timeout, opt, p_ts);
    377          
    378          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    379              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD004             BEQ.N    ??OSMutexPend_0
    380                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    381                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_PEND_ISR);
    382                 *p_err = OS_ERR_PEND_ISR;
   \   0000001E   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000022   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    383                  return;
   \   00000026   0xE0F1             B.N      ??OSMutexPend_1
    384              }
    385          #endif
    386          
    387          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    388              if (OSRunning != OS_STATE_OS_RUNNING) {
    389                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    390                 *p_err = OS_ERR_OS_NOT_RUNNING;
    391                  return;
    392              }
    393          #endif
    394          
    395          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    396              if (p_mutex == DEF_NULL) {                                  /* Validate arguments                                   */
   \                     ??OSMutexPend_0: (+1)
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD104             BNE.N    ??OSMutexPend_2
    397                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    398                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    399                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000002C   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000030   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    400                  return;
   \   00000034   0xE0EA             B.N      ??OSMutexPend_1
    401              }
    402              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPend_2: (+1)
   \   00000036   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ.N    ??OSMutexPend_3
   \   0000003E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000042   0xD105             BNE.N    ??OSMutexPend_4
    403                  case OS_OPT_PEND_BLOCKING:
    404                  case OS_OPT_PEND_NON_BLOCKING:
    405                       break;
    406          
    407                  default:
    408                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    409                       OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OPT_INVALID);
    410                      *p_err = OS_ERR_OPT_INVALID;
    411                       return;
    412              }
    413          #endif
    414          
    415          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    416              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPend_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable7_2  ;; 0x5854554d
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD105             BNE.N    ??OSMutexPend_5
   \   0000004E   0xE009             B.N      ??OSMutexPend_6
   \                     ??OSMutexPend_4: (+1)
   \   00000050   0xF645 0x6025      MOVW     R0,#+24101
   \   00000054   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000058   0xE0D8             B.N      ??OSMutexPend_1
    417                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    418                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OBJ_TYPE);
    419                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSMutexPend_5: (+1)
   \   0000005A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000005E   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    420                  return;
   \   00000062   0xE0D3             B.N      ??OSMutexPend_1
    421              }
    422          #endif
    423          
    424              CPU_CRITICAL_ENTER();
   \                     ??OSMutexPend_6: (+1)
   \   00000064   0x.... 0x....      BL       CPU_SR_Save
   \   00000068   0x4682             MOV      R10,R0
   \   0000006A   0x.... 0x....      BL       CPU_IntDisMeasStart
    425              if (p_mutex->OwnerNestingCtr == 0u) {                       /* Resource available?                                  */
   \   0000006E   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD119             BNE.N    ??OSMutexPend_7
    426                  p_mutex->OwnerTCBPtr     = OSTCBCurPtr;                 /* Yes, caller may proceed                              */
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x6260             STR      R0,[R4, #+36]
    427                  p_mutex->OwnerNestingCtr = 1u;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF884 0x0028      STRB     R0,[R4, #+40]
    428          #if (OS_CFG_TS_EN == DEF_ENABLED)
    429                  if (p_ts != DEF_NULL) {
   \   00000084   0x2F00             CMP      R7,#+0
   \   00000086   0xD001             BEQ.N    ??OSMutexPend_8
    430                     *p_ts = p_mutex->TS;
   \   00000088   0x6AE0             LDR      R0,[R4, #+44]
   \   0000008A   0x6038             STR      R0,[R7, #+0]
    431                  }
    432          #endif
    433                  OS_MutexGrpAdd(OSTCBCurPtr, p_mutex);                   /* Add mutex to owner's group                           */
   \                     ??OSMutexPend_8: (+1)
   \   0000008C   0x0021             MOVS     R1,R4
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x.... 0x....      BL       OS_MutexGrpAdd
    434                  CPU_CRITICAL_EXIT();
   \   00000098   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009C   0x4650             MOV      R0,R10
   \   0000009E   0x.... 0x....      BL       CPU_SR_Restore
    435                  OS_TRACE_MUTEX_PEND(p_mutex);
    436                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_NONE);
    437                 *p_err = OS_ERR_NONE;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    438                  return;
   \   000000A8   0xE0B0             B.N      ??OSMutexPend_1
    439              }
    440          
    441              if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {                  /* See if current task is already the owner of the mutex*/
   \                     ??OSMutexPend_7: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x6A61             LDR      R1,[R4, #+36]
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD120             BNE.N    ??OSMutexPend_9
    442                  if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)-1) {
   \   000000B6   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   000000BA   0x28FF             CMP      R0,#+255
   \   000000BC   0xD109             BNE.N    ??OSMutexPend_10
    443                      CPU_CRITICAL_EXIT();
   \   000000BE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C2   0x4650             MOV      R0,R10
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
    444                      OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    445                      OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_MUTEX_OVF);
    446                     *p_err = OS_ERR_MUTEX_OVF;
   \   000000C8   0xF245 0x7084      MOVW     R0,#+22404
   \   000000CC   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    447                      return;
   \   000000D0   0xE09C             B.N      ??OSMutexPend_1
    448                  }
    449                  p_mutex->OwnerNestingCtr++;
   \                     ??OSMutexPend_10: (+1)
   \   000000D2   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   000000D6   0x1C40             ADDS     R0,R0,#+1
   \   000000D8   0xF884 0x0028      STRB     R0,[R4, #+40]
    450          #if (OS_CFG_TS_EN == DEF_ENABLED)
    451                  if (p_ts != DEF_NULL) {
   \   000000DC   0x2F00             CMP      R7,#+0
   \   000000DE   0xD001             BEQ.N    ??OSMutexPend_11
    452                     *p_ts = p_mutex->TS;
   \   000000E0   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E2   0x6038             STR      R0,[R7, #+0]
    453                  }
    454          #endif
    455                  CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_11: (+1)
   \   000000E4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E8   0x4650             MOV      R0,R10
   \   000000EA   0x.... 0x....      BL       CPU_SR_Restore
    456                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    457                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_MUTEX_OWNER);
    458                 *p_err = OS_ERR_MUTEX_OWNER;                             /* Indicate that current task already owns the mutex    */
   \   000000EE   0xF245 0x7082      MOVW     R0,#+22402
   \   000000F2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    459                  return;
   \   000000F6   0xE089             B.N      ??OSMutexPend_1
    460              }
    461          
    462              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSMutexPend_9: (+1)
   \   000000F8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000FA   0x0430             LSLS     R0,R6,#+16
   \   000000FC   0xD50D             BPL.N    ??OSMutexPend_12
    463                  CPU_CRITICAL_EXIT();
   \   000000FE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000102   0x4650             MOV      R0,R10
   \   00000104   0x.... 0x....      BL       CPU_SR_Restore
    464          #if (OS_CFG_TS_EN == DEF_ENABLED)
    465                  if (p_ts != DEF_NULL) {
   \   00000108   0x2F00             CMP      R7,#+0
   \   0000010A   0xD001             BEQ.N    ??OSMutexPend_13
    466                     *p_ts = 0u;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x6038             STR      R0,[R7, #+0]
    467                  }
    468          #endif
    469                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    470                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    471                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \                     ??OSMutexPend_13: (+1)
   \   00000110   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000114   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    472                  return;
   \   00000118   0xE078             B.N      ??OSMutexPend_1
    473              } else {
    474                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSMutexPend_12: (+1)
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \   0000011E   0x7800             LDRB     R0,[R0, #+0]
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xD00D             BEQ.N    ??OSMutexPend_14
    475                      CPU_CRITICAL_EXIT();
   \   00000124   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000128   0x4650             MOV      R0,R10
   \   0000012A   0x.... 0x....      BL       CPU_SR_Restore
    476          #if (OS_CFG_TS_EN == DEF_ENABLED)
    477                      if (p_ts != DEF_NULL) {
   \   0000012E   0x2F00             CMP      R7,#+0
   \   00000130   0xD001             BEQ.N    ??OSMutexPend_15
    478                         *p_ts = 0u;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x6038             STR      R0,[R7, #+0]
    479                      }
    480          #endif
    481                      OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    482                      OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    483                     *p_err = OS_ERR_SCHED_LOCKED;
   \                     ??OSMutexPend_15: (+1)
   \   00000136   0xF646 0x5063      MOVW     R0,#+28003
   \   0000013A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    484                      return;
   \   0000013E   0xE065             B.N      ??OSMutexPend_1
    485                  }
    486              }
    487          
    488              p_tcb = p_mutex->OwnerTCBPtr;                               /* Point to the TCB of the Mutex owner                  */
   \                     ??OSMutexPend_14: (+1)
   \   00000140   0x6A60             LDR      R0,[R4, #+36]
   \   00000142   0x4681             MOV      R9,R0
    489              if (p_tcb->Prio > OSTCBCurPtr->Prio) {                      /* See if mutex owner has a lower priority than current */
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0xF890 0x003F      LDRB     R0,[R0, #+63]
   \   0000014E   0xF899 0x103F      LDRB     R1,[R9, #+63]
   \   00000152   0x4288             CMP      R0,R1
   \   00000154   0xD207             BCS.N    ??OSMutexPend_16
    490                  OS_TaskChangePrio(p_tcb, OSTCBCurPtr->Prio);
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0xF890 0x103F      LDRB     R1,[R0, #+63]
   \   00000160   0x4648             MOV      R0,R9
   \   00000162   0x.... 0x....      BL       OS_TaskChangePrio
    491                  OS_TRACE_MUTEX_TASK_PRIO_INHERIT(p_tcb, p_tcb->Prio);
    492              }
    493          
    494              OS_Pend((OS_PEND_OBJ *)((void *)p_mutex),                   /* Block task pending on Mutex                          */
    495                       OS_TASK_PEND_ON_MUTEX,
    496                       timeout);
   \                     ??OSMutexPend_16: (+1)
   \   00000166   0x002A             MOVS     R2,R5
   \   00000168   0x2104             MOVS     R1,#+4
   \   0000016A   0x0020             MOVS     R0,R4
   \   0000016C   0x.... 0x....      BL       OS_Pend
    497          
    498              CPU_CRITICAL_EXIT();
   \   00000170   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000174   0x4650             MOV      R0,R10
   \   00000176   0x.... 0x....      BL       CPU_SR_Restore
    499              OS_TRACE_MUTEX_PEND_BLOCK(p_mutex);
    500              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   0000017A   0x.... 0x....      BL       OSSched
    501          
    502              CPU_CRITICAL_ENTER();
   \   0000017E   0x.... 0x....      BL       CPU_SR_Save
   \   00000182   0x4682             MOV      R10,R0
   \   00000184   0x.... 0x....      BL       CPU_IntDisMeasStart
    503              switch (OSTCBCurPtr->PendStatus) {
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD005             BEQ.N    ??OSMutexPend_17
   \   00000196   0x2802             CMP      R0,#+2
   \   00000198   0xD023             BEQ.N    ??OSMutexPend_18
   \   0000019A   0xD30D             BCC.N    ??OSMutexPend_19
   \   0000019C   0x2803             CMP      R0,#+3
   \   0000019E   0xD017             BEQ.N    ??OSMutexPend_20
   \   000001A0   0xE02B             B.N      ??OSMutexPend_21
    504                  case OS_STATUS_PEND_OK:                                 /* We got the mutex                                     */
    505          #if (OS_CFG_TS_EN == DEF_ENABLED)
    506                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_17: (+1)
   \   000001A2   0x2F00             CMP      R7,#+0
   \   000001A4   0xD004             BEQ.N    ??OSMutexPend_22
    507                          *p_ts = OSTCBCurPtr->TS;
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x6D00             LDR      R0,[R0, #+80]
   \   000001AE   0x6038             STR      R0,[R7, #+0]
    508                       }
    509          #endif
    510                       OS_TRACE_MUTEX_PEND(p_mutex);
    511                      *p_err = OS_ERR_NONE;
   \                     ??OSMutexPend_22: (+1)
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    512                       break;
   \   000001B6   0xE024             B.N      ??OSMutexPend_23
    513          
    514                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    515          #if (OS_CFG_TS_EN == DEF_ENABLED)
    516                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_19: (+1)
   \   000001B8   0x2F00             CMP      R7,#+0
   \   000001BA   0xD004             BEQ.N    ??OSMutexPend_24
    517                          *p_ts = OSTCBCurPtr->TS;
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000001C0   0x6800             LDR      R0,[R0, #+0]
   \   000001C2   0x6D00             LDR      R0,[R0, #+80]
   \   000001C4   0x6038             STR      R0,[R7, #+0]
    518                       }
    519          #endif
    520                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    521                      *p_err = OS_ERR_PEND_ABORT;
   \                     ??OSMutexPend_24: (+1)
   \   000001C6   0xF246 0x10A9      MOVW     R0,#+25001
   \   000001CA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    522                       break;
   \   000001CE   0xE018             B.N      ??OSMutexPend_23
    523          
    524                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get mutex within timeout     */
    525          #if (OS_CFG_TS_EN == DEF_ENABLED)
    526                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_20: (+1)
   \   000001D0   0x2F00             CMP      R7,#+0
   \   000001D2   0xD001             BEQ.N    ??OSMutexPend_25
    527                          *p_ts = 0u;
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0x6038             STR      R0,[R7, #+0]
    528                       }
    529          #endif
    530                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    531                      *p_err = OS_ERR_TIMEOUT;
   \                     ??OSMutexPend_25: (+1)
   \   000001D8   0xF247 0x20D9      MOVW     R0,#+29401
   \   000001DC   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    532                       break;
   \   000001E0   0xE00F             B.N      ??OSMutexPend_23
    533          
    534                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    535          #if (OS_CFG_TS_EN == DEF_ENABLED)
    536                       if (p_ts != DEF_NULL) {
   \                     ??OSMutexPend_18: (+1)
   \   000001E2   0x2F00             CMP      R7,#+0
   \   000001E4   0xD004             BEQ.N    ??OSMutexPend_26
    537                          *p_ts = OSTCBCurPtr->TS;
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \   000001EC   0x6D00             LDR      R0,[R0, #+80]
   \   000001EE   0x6038             STR      R0,[R7, #+0]
    538                       }
    539          #endif
    540                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    541                      *p_err = OS_ERR_OBJ_DEL;
   \                     ??OSMutexPend_26: (+1)
   \   000001F0   0xF645 0x50C2      MOVW     R0,#+24002
   \   000001F4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    542                       break;
   \   000001F8   0xE003             B.N      ??OSMutexPend_23
    543          
    544                  default:
    545                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    546                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSMutexPend_21: (+1)
   \   000001FA   0xF646 0x602E      MOVW     R0,#+28206
   \   000001FE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    547                       break;
    548              }
    549              CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_23: (+1)
   \   00000202   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000206   0x4650             MOV      R0,R10
   \   00000208   0x.... 0x....      BL       CPU_SR_Restore
    550              OS_TRACE_MUTEX_PEND_EXIT(*p_err);
    551          }
   \                     ??OSMutexPend_1: (+1)
   \   0000020C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    552          
    553          
    554          /*
    555          ************************************************************************************************************************
    556          *                                               ABORT WAITING ON A MUTEX
    557          *
    558          * Description: This function aborts & readies any tasks currently waiting on a mutex.  This function should be used
    559          *              to fault-abort the wait on the mutex, rather than to normally signal the mutex via OSMutexPost().
    560          *
    561          * Arguments  : p_mutex       is a pointer to the mutex
    562          *
    563          *              opt           determines the type of ABORT performed:
    564          *
    565          *                                OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the mutex
    566          *                                OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the mutex
    567          *                                OS_OPT_POST_NO_SCHED         Do not call the scheduler
    568          *
    569          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    570          *
    571          *                                OS_ERR_NONE               At least one task waiting on the mutex was readied and
    572          *                                                          informed of the aborted wait; check return value for the
    573          *                                                          number of tasks whose wait on the mutex was aborted
    574          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    575          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    576          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    577          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    578          *                                OS_ERR_PEND_ABORT_ISR     If you attempted to call this function from an ISR
    579          *                                OS_ERR_PEND_ABORT_NONE    No task were pending
    580          *
    581          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    582          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    583          *
    584          * Note(s)    : none
    585          ************************************************************************************************************************
    586          */
    587          
    588          #if (OS_CFG_MUTEX_PEND_ABORT_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    589          OS_OBJ_QTY  OSMutexPendAbort (OS_MUTEX  *p_mutex,
    590                                        OS_OPT     opt,
    591                                        OS_ERR    *p_err)
    592          {
   \                     OSMutexPendAbort: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    593              OS_PEND_LIST  *p_pend_list;
    594              OS_TCB        *p_tcb;
    595              OS_TCB        *p_tcb_owner;
    596              CPU_TS         ts;
    597              OS_OBJ_QTY     nbr_tasks;
    598              OS_PRIO        prio_new;
    599              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    600          
    601          
    602          #ifdef OS_SAFETY_CRITICAL
    603              if (p_err == DEF_NULL) {
    604                  OS_SAFETY_CRITICAL_EXCEPTION();
    605                  return ((OS_OBJ_QTY)0u);
    606              }
    607          #endif
    608          
    609          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    610              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   00000010   0x....             LDR.N    R0,??DataTable7_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSMutexPendAbort_0
    611                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000018   0xF246 0x10AA      MOVW     R0,#+25002
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
    612                  return (0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE086             B.N      ??OSMutexPendAbort_1
    613              }
    614          #endif
    615          
    616          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    617              if (OSRunning != OS_STATE_OS_RUNNING) {
    618                 *p_err = OS_ERR_OS_NOT_RUNNING;
    619                  return (0u);
    620              }
    621          #endif
    622          
    623          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    624              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexPendAbort_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSMutexPendAbort_2
    625                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    626                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE07F             B.N      ??OSMutexPendAbort_1
    627              }
    628              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPendAbort_2: (+1)
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??OSMutexPendAbort_3
   \   00000038   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003C   0xD005             BEQ.N    ??OSMutexPendAbort_3
   \   0000003E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000042   0xD002             BEQ.N    ??OSMutexPendAbort_3
   \   00000044   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000048   0xD104             BNE.N    ??OSMutexPendAbort_4
    629                  case OS_OPT_PEND_ABORT_1:
    630                  case OS_OPT_PEND_ABORT_ALL:
    631                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    632                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    633                       break;
    634          
    635                  default:
    636                      *p_err =  OS_ERR_OPT_INVALID;
    637                       return (0u);
    638              }
    639          #endif
    640          
    641          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    642              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPendAbort_3: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x....             LDR.N    R1,??DataTable7_2  ;; 0x5854554d
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD105             BNE.N    ??OSMutexPendAbort_5
   \   00000052   0xE009             B.N      ??OSMutexPendAbort_6
   \                     ??OSMutexPendAbort_4: (+1)
   \   00000054   0xF645 0x6025      MOVW     R0,#+24101
   \   00000058   0x8030             STRH     R0,[R6, #+0]
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE068             B.N      ??OSMutexPendAbort_1
    643                 *p_err =  OS_ERR_OBJ_TYPE;
   \                     ??OSMutexPendAbort_5: (+1)
   \   0000005E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000062   0x8030             STRH     R0,[R6, #+0]
    644                  return (0u);
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE063             B.N      ??OSMutexPendAbort_1
    645              }
    646          #endif
    647          
    648              CPU_CRITICAL_ENTER();
   \                     ??OSMutexPendAbort_6: (+1)
   \   00000068   0x.... 0x....      BL       CPU_SR_Save
   \   0000006C   0x4683             MOV      R11,R0
   \   0000006E   0x.... 0x....      BL       CPU_IntDisMeasStart
    649              p_pend_list = &p_mutex->PendList;
   \   00000072   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000076   0x9000             STR      R0,[SP, #+0]
    650              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on mutex?                           */
   \   00000078   0x9800             LDR      R0,[SP, #+0]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD109             BNE.N    ??OSMutexPendAbort_7
    651                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    652                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   0000008A   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000008E   0x8030             STRH     R0,[R6, #+0]
    653                  return (0u);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE04D             B.N      ??OSMutexPendAbort_1
    654              }
    655          
    656              nbr_tasks = 0u;
   \                     ??OSMutexPendAbort_7: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x4681             MOV      R9,R0
    657          #if (OS_CFG_TS_EN == DEF_ENABLED)
    658              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
   \   00000098   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000009C   0x9001             STR      R0,[SP, #+4]
    659          #else
    660              ts        = 0u;
    661          #endif
    662              while (p_pend_list->HeadPtr != DEF_NULL) {
   \                     ??OSMutexPendAbort_8: (+1)
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD036             BEQ.N    ??OSMutexPendAbort_9
    663                  p_tcb = p_pend_list->HeadPtr;
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x0007             MOVS     R7,R0
    664          
    665                  OS_PendAbort(p_tcb,
    666                               ts,
    667                               OS_STATUS_PEND_ABORT);
   \   000000AC   0x2201             MOVS     R2,#+1
   \   000000AE   0x9901             LDR      R1,[SP, #+4]
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0x.... 0x....      BL       OS_PendAbort
    668                  p_tcb_owner = p_mutex->OwnerTCBPtr;
   \   000000B6   0x6A60             LDR      R0,[R4, #+36]
   \   000000B8   0x4680             MOV      R8,R0
    669                  prio_new    = p_tcb_owner->Prio;
   \   000000BA   0xF898 0x003F      LDRB     R0,[R8, #+63]
   \   000000BE   0x4682             MOV      R10,R0
    670                  if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
    671                      (p_tcb_owner->Prio == p_tcb->Prio)) {               /* Has the owner inherited a priority?                  */
   \   000000C0   0xF898 0x003F      LDRB     R0,[R8, #+63]
   \   000000C4   0xF898 0x1040      LDRB     R1,[R8, #+64]
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xD012             BEQ.N    ??OSMutexPendAbort_10
   \   000000CC   0xF898 0x003F      LDRB     R0,[R8, #+63]
   \   000000D0   0xF897 0x103F      LDRB     R1,[R7, #+63]
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD10C             BNE.N    ??OSMutexPendAbort_10
    672                      prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000DE   0x4682             MOV      R10,R0
    673                      prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
   \   000000E0   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000E4   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000E8   0x4550             CMP      R0,R10
   \   000000EA   0xD202             BCS.N    ??OSMutexPendAbort_11
   \   000000EC   0xF898 0xA040      LDRB     R10,[R8, #+64]
   \   000000F0   0xE7FF             B.N      ??OSMutexPendAbort_10
    674                  }
    675          
    676                  if(prio_new != p_tcb_owner->Prio) {
   \                     ??OSMutexPendAbort_11: (+1)
   \                     ??OSMutexPendAbort_10: (+1)
   \   000000F2   0xF898 0x003F      LDRB     R0,[R8, #+63]
   \   000000F6   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000FA   0x4582             CMP      R10,R0
   \   000000FC   0xD004             BEQ.N    ??OSMutexPendAbort_12
    677                      OS_TaskChangePrio(p_tcb_owner, prio_new);
   \   000000FE   0x4651             MOV      R1,R10
   \   00000100   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0x.... 0x....      BL       OS_TaskChangePrio
    678                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    679                  }
    680          
    681                  nbr_tasks++;
   \                     ??OSMutexPendAbort_12: (+1)
   \   00000108   0xF119 0x0901      ADDS     R9,R9,#+1
    682                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   0000010C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000010E   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000112   0xD0C4             BEQ.N    ??OSMutexPendAbort_8
    683                      break;                                              /* No                                                   */
    684                  }
    685              }
    686              CPU_CRITICAL_EXIT();
   \                     ??OSMutexPendAbort_9: (+1)
   \   00000114   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000118   0x4658             MOV      R0,R11
   \   0000011A   0x.... 0x....      BL       CPU_SR_Restore
    687          
    688              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   0000011E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000120   0x0428             LSLS     R0,R5,#+16
   \   00000122   0xD401             BMI.N    ??OSMutexPendAbort_13
    689                  OSSched();                                              /* Run the scheduler                                    */
   \   00000124   0x.... 0x....      BL       OSSched
    690              }
    691          
    692             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPendAbort_13: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x8030             STRH     R0,[R6, #+0]
    693              return (nbr_tasks);
   \   0000012C   0x4648             MOV      R0,R9
   \   0000012E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexPendAbort_1: (+1)
   \   00000130   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    694          }
    695          #endif
    696          
    697          
    698          /*
    699          ************************************************************************************************************************
    700          *                                                   POST TO A MUTEX
    701          *
    702          * Description: This function signals a mutex.
    703          *
    704          * Arguments  : p_mutex       is a pointer to the mutex
    705          *
    706          *              opt           is an option you can specify to alter the behavior of the post.  The choices are:
    707          *
    708          *                                OS_OPT_POST_NONE        No special option selected
    709          *                                OS_OPT_POST_NO_SCHED    If you don't want the scheduler to be called after the post.
    710          *
    711          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    712          *
    713          *                                OS_ERR_NONE               The call was successful and the mutex was signaled
    714          *                                OS_ERR_MUTEX_NESTING      Mutex owner nested its use of the mutex
    715          *                                OS_ERR_MUTEX_NOT_OWNER    If the task posting is not the Mutex owner
    716          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    717          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    718          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    719          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    720          *                                OS_ERR_POST_ISR           If you attempted to post from an ISR
    721          *
    722          * Returns    : none
    723          *
    724          * Note(s)    : none
    725          ************************************************************************************************************************
    726          */
    727          

   \                                 In section .text, align 2, keep-with-next
    728          void  OSMutexPost (OS_MUTEX  *p_mutex,
    729                             OS_OPT     opt,
    730                             OS_ERR    *p_err)
    731          {
   \                     OSMutexPost: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    732              OS_PEND_LIST  *p_pend_list;
    733              OS_TCB        *p_tcb;
    734              CPU_TS         ts;
    735              OS_PRIO        prio_new;
    736              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    737          
    738          
    739          #ifdef OS_SAFETY_CRITICAL
    740              if (p_err == DEF_NULL) {
    741                  OS_SAFETY_CRITICAL_EXCEPTION();
    742                  return;
    743              }
    744          #endif
    745          
    746              OS_TRACE_MUTEX_POST_ENTER(p_mutex, opt);
    747          
    748          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    749              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??OSMutexPost_0
    750                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    751                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_POST_ISR);
    752                 *p_err = OS_ERR_POST_ISR;
   \   00000016   0xF246 0x200E      MOVW     R0,#+25102
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
    753                  return;
   \   0000001C   0xE0B1             B.N      ??OSMutexPost_1
    754              }
    755          #endif
    756          
    757          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    758              if (OSRunning != OS_STATE_OS_RUNNING) {
    759                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    760                 *p_err = OS_ERR_OS_NOT_RUNNING;
    761                  return;
    762              }
    763          #endif
    764          
    765          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    766              if (p_mutex == DEF_NULL) {                                  /* Validate 'p_mutex'                                   */
   \                     ??OSMutexPost_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD103             BNE.N    ??OSMutexPost_2
    767                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    768                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    769                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8030             STRH     R0,[R6, #+0]
    770                  return;
   \   00000028   0xE0AB             B.N      ??OSMutexPost_1
    771              }
    772              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPost_2: (+1)
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD002             BEQ.N    ??OSMutexPost_3
   \   00000032   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000036   0xD104             BNE.N    ??OSMutexPost_4
    773                  case OS_OPT_POST_NONE:
    774                  case OS_OPT_POST_NO_SCHED:
    775                       break;
    776          
    777                  default:
    778                       OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    779                       OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OPT_INVALID);
    780                      *p_err =  OS_ERR_OPT_INVALID;
    781                       return;
    782              }
    783          #endif
    784          
    785          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    786              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPost_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x....             LDR.N    R1,??DataTable7_2  ;; 0x5854554d
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD104             BNE.N    ??OSMutexPost_5
   \   00000040   0xE007             B.N      ??OSMutexPost_6
   \                     ??OSMutexPost_4: (+1)
   \   00000042   0xF645 0x6025      MOVW     R0,#+24101
   \   00000046   0x8030             STRH     R0,[R6, #+0]
   \   00000048   0xE09B             B.N      ??OSMutexPost_1
    787                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    788                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OBJ_TYPE);
    789                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSMutexPost_5: (+1)
   \   0000004A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004E   0x8030             STRH     R0,[R6, #+0]
    790                  return;
   \   00000050   0xE097             B.N      ??OSMutexPost_1
    791              }
    792          #endif
    793          
    794              CPU_CRITICAL_ENTER();
   \                     ??OSMutexPost_6: (+1)
   \   00000052   0x.... 0x....      BL       CPU_SR_Save
   \   00000056   0x4683             MOV      R11,R0
   \   00000058   0x.... 0x....      BL       CPU_IntDisMeasStart
    795              if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {                  /* Make sure the mutex owner is releasing the mutex     */
   \   0000005C   0x....             LDR.N    R0,??DataTable7_4
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x6A61             LDR      R1,[R4, #+36]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD008             BEQ.N    ??OSMutexPost_7
    796                  CPU_CRITICAL_EXIT();
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006A   0x4658             MOV      R0,R11
   \   0000006C   0x.... 0x....      BL       CPU_SR_Restore
    797                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    798                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_MUTEX_NOT_OWNER);
    799                 *p_err = OS_ERR_MUTEX_NOT_OWNER;
   \   00000070   0xF245 0x7081      MOVW     R0,#+22401
   \   00000074   0x8030             STRH     R0,[R6, #+0]
    800                  return;
   \   00000076   0xE084             B.N      ??OSMutexPost_1
    801              }
    802          
    803              OS_TRACE_MUTEX_POST(p_mutex);
    804          
    805          #if (OS_CFG_TS_EN == DEF_ENABLED)
    806              ts          = OS_TS_GET();                                  /* Get timestamp                                        */
   \                     ??OSMutexPost_7: (+1)
   \   00000078   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000007C   0x4681             MOV      R9,R0
    807              p_mutex->TS = ts;
   \   0000007E   0xF8C4 0x902C      STR      R9,[R4, #+44]
    808          #else
    809              ts          = 0u;
    810          #endif
    811              p_mutex->OwnerNestingCtr--;                                 /* Decrement owner's nesting counter                    */
   \   00000082   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0xF884 0x0028      STRB     R0,[R4, #+40]
    812              if (p_mutex->OwnerNestingCtr > 0u) {                        /* Are we done with all nestings?                       */
   \   0000008C   0xF894 0x0028      LDRB     R0,[R4, #+40]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD008             BEQ.N    ??OSMutexPost_8
    813                  CPU_CRITICAL_EXIT();                                     /* No                                                   */
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000098   0x4658             MOV      R0,R11
   \   0000009A   0x.... 0x....      BL       CPU_SR_Restore
    814                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_MUTEX_NESTING);
    815                 *p_err = OS_ERR_MUTEX_NESTING;
   \   0000009E   0xF245 0x7083      MOVW     R0,#+22403
   \   000000A2   0x8030             STRH     R0,[R6, #+0]
    816                  return;
   \   000000A4   0xE06D             B.N      ??OSMutexPost_1
    817              }
    818          
    819              OS_MutexGrpRemove(OSTCBCurPtr, p_mutex);                    /* Remove mutex from owner's group                      */
   \                     ??OSMutexPost_8: (+1)
   \   000000A6   0x0021             MOVS     R1,R4
   \   000000A8   0x....             LDR.N    R0,??DataTable7_4
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x.... 0x....      BL       OS_MutexGrpRemove
    820          
    821              p_pend_list = &p_mutex->PendList;
   \   000000B0   0xF114 0x0008      ADDS     R0,R4,#+8
   \   000000B4   0x0007             MOVS     R7,R0
    822              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on mutex?                           */
   \   000000B6   0x6838             LDR      R0,[R7, #+0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD10C             BNE.N    ??OSMutexPost_9
    823                  p_mutex->OwnerTCBPtr     = DEF_NULL;                    /* No                                                   */
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x6260             STR      R0,[R4, #+36]
    824                  p_mutex->OwnerNestingCtr = 0u;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF884 0x0028      STRB     R0,[R4, #+40]
    825                  CPU_CRITICAL_EXIT();
   \   000000C6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000CA   0x4658             MOV      R0,R11
   \   000000CC   0x.... 0x....      BL       CPU_SR_Restore
    826                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_NONE);
    827                 *p_err = OS_ERR_NONE;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x8030             STRH     R0,[R6, #+0]
    828                  return;
   \   000000D4   0xE055             B.N      ??OSMutexPost_1
    829              }
    830                                                                          /* Yes                                                  */
    831              if (OSTCBCurPtr->Prio != OSTCBCurPtr->BasePrio) {           /* Has owner inherited a priority?                      */
   \                     ??OSMutexPost_9: (+1)
   \   000000D6   0x....             LDR.N    R0,??DataTable7_4
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0xF890 0x003F      LDRB     R0,[R0, #+63]
   \   000000DE   0x....             LDR.N    R1,??DataTable7_4
   \   000000E0   0x6809             LDR      R1,[R1, #+0]
   \   000000E2   0xF891 0x1040      LDRB     R1,[R1, #+64]
   \   000000E6   0x4288             CMP      R0,R1
   \   000000E8   0xD02C             BEQ.N    ??OSMutexPost_10
    832                  prio_new = OS_MutexGrpPrioFindHighest(OSTCBCurPtr);     /* Yes, find highest priority pending                   */
   \   000000EA   0x....             LDR.N    R0,??DataTable7_4
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000F2   0x4682             MOV      R10,R0
    833                  prio_new = (prio_new > OSTCBCurPtr->BasePrio) ? OSTCBCurPtr->BasePrio : prio_new;
   \   000000F4   0x....             LDR.N    R0,??DataTable7_4
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000000FC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000100   0x4550             CMP      R0,R10
   \   00000102   0xD204             BCS.N    ??OSMutexPost_11
   \   00000104   0x....             LDR.N    R0,??DataTable7_4
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0xF890 0xA040      LDRB     R10,[R0, #+64]
   \   0000010C   0xE7FF             B.N      ??OSMutexPost_12
    834                  if (prio_new > OSTCBCurPtr->Prio) {
   \                     ??OSMutexPost_11: (+1)
   \                     ??OSMutexPost_12: (+1)
   \   0000010E   0x....             LDR.N    R0,??DataTable7_4
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF890 0x003F      LDRB     R0,[R0, #+63]
   \   00000116   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000011A   0x4550             CMP      R0,R10
   \   0000011C   0xD212             BCS.N    ??OSMutexPost_10
    835                      OS_RdyListRemove(OSTCBCurPtr);
   \   0000011E   0x....             LDR.N    R0,??DataTable7_4
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x.... 0x....      BL       OS_RdyListRemove
    836                      OSTCBCurPtr->Prio = prio_new;                       /* Lower owner's priority back to its original one      */
   \   00000126   0x....             LDR.N    R0,??DataTable7_4
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0xF880 0xA03F      STRB     R10,[R0, #+63]
    837                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(OSTCBCurPtr, prio_new);
    838                      OS_PrioInsert(prio_new);
   \   0000012E   0x4650             MOV      R0,R10
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000132   0x.... 0x....      BL       OS_PrioInsert
    839                      OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority           */
   \   00000136   0x....             LDR.N    R0,??DataTable7_4
   \   00000138   0x6800             LDR      R0,[R0, #+0]
   \   0000013A   0x.... 0x....      BL       OS_RdyListInsertTail
    840                      OSPrioCur         = prio_new;
   \   0000013E   0x....             LDR.N    R0,??DataTable7_6
   \   00000140   0xF880 0xA000      STRB     R10,[R0, #+0]
    841                  }
    842              }
    843                                                                          /* Get TCB from head of pend list                       */
    844              p_tcb                    = p_pend_list->HeadPtr;
   \                     ??OSMutexPost_10: (+1)
   \   00000144   0x6838             LDR      R0,[R7, #+0]
   \   00000146   0x4680             MOV      R8,R0
    845              p_mutex->OwnerTCBPtr     = p_tcb;                           /* Give mutex to new owner                              */
   \   00000148   0xF8C4 0x8024      STR      R8,[R4, #+36]
    846              p_mutex->OwnerNestingCtr = 1u;
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x0028      STRB     R0,[R4, #+40]
    847              OS_MutexGrpAdd(p_tcb, p_mutex);
   \   00000152   0x0021             MOVS     R1,R4
   \   00000154   0x4640             MOV      R0,R8
   \   00000156   0x.... 0x....      BL       OS_MutexGrpAdd
    848                                                                          /* Post to mutex                                        */
    849              OS_Post((OS_PEND_OBJ *)p_mutex,
    850                                     p_tcb,
    851                                     DEF_NULL,
    852                                     0u,
    853                                     ts);
   \   0000015A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000015E   0x2300             MOVS     R3,#+0
   \   00000160   0x2200             MOVS     R2,#+0
   \   00000162   0x4641             MOV      R1,R8
   \   00000164   0x0020             MOVS     R0,R4
   \   00000166   0x.... 0x....      BL       OS_Post
    854          
    855              CPU_CRITICAL_EXIT();
   \   0000016A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016E   0x4658             MOV      R0,R11
   \   00000170   0x.... 0x....      BL       CPU_SR_Restore
    856          
    857              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000174   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000176   0x0428             LSLS     R0,R5,#+16
   \   00000178   0xD401             BMI.N    ??OSMutexPost_13
    858                  OSSched();                                              /* Run the scheduler                                    */
   \   0000017A   0x.... 0x....      BL       OSSched
    859              }
    860              OS_TRACE_MUTEX_POST_EXIT(OS_ERR_NONE);
    861             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPost_13: (+1)
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x8030             STRH     R0,[R6, #+0]
    862          }
   \                     ??OSMutexPost_1: (+1)
   \   00000182   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    863          
    864          
    865          /*
    866          ************************************************************************************************************************
    867          *                                            CLEAR THE CONTENTS OF A MUTEX
    868          *
    869          * Description: This function is called by OSMutexDel() to clear the contents of a mutex
    870          *
    871          
    872          * Argument(s): p_mutex      is a pointer to the mutex to clear
    873          *              -------
    874          *
    875          * Returns    : none
    876          *
    877          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    878          ************************************************************************************************************************
    879          */
    880          

   \                                 In section .text, align 2, keep-with-next
    881          void  OS_MutexClr (OS_MUTEX  *p_mutex)
    882          {
   \                     OS_MutexClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    883          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    884              p_mutex->Type              =  OS_OBJ_TYPE_NONE;             /* Mark the data structure as a NONE                    */
   \   00000004   0x....             LDR.N    R0,??DataTable7_7  ;; 0x454e4f4e
   \   00000006   0x6020             STR      R0,[R4, #+0]
    885          #endif
    886          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    887              p_mutex->NamePtr           = (CPU_CHAR *)((void *)"?MUTEX");
   \   00000008   0x....             LDR.N    R0,??DataTable7_8
   \   0000000A   0x6060             STR      R0,[R4, #+4]
    888          #endif
    889              p_mutex->MutexGrpNextPtr   = DEF_NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6220             STR      R0,[R4, #+32]
    890              p_mutex->OwnerTCBPtr       = DEF_NULL;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x6260             STR      R0,[R4, #+36]
    891              p_mutex->OwnerNestingCtr   = 0u;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0028      STRB     R0,[R4, #+40]
    892          #if (OS_CFG_TS_EN == DEF_ENABLED)
    893              p_mutex->TS                = 0u;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x62E0             STR      R0,[R4, #+44]
    894          #endif
    895              OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
   \   0000001E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000022   0x.... 0x....      BL       OS_PendListInit
    896          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    897          
    898          
    899          /*
    900          ************************************************************************************************************************
    901          *                                          ADD/REMOVE MUTEX TO/FROM DEBUG LIST
    902          *
    903          * Description: These functions are called by uC/OS-III to add or remove a mutex to/from the debug list.
    904          *
    905          * Arguments  : p_mutex     is a pointer to the mutex to add/remove
    906          *
    907          * Returns    : none
    908          *
    909          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    910          ************************************************************************************************************************
    911          */
    912          
    913          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    914          void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
    915          {
    916              p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \                     OS_MutexDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable7  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
    917              p_mutex->DbgPrevPtr               = DEF_NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    918              if (OSMutexDbgListPtr == DEF_NULL) {
   \   00000008   0x....             LDR.N    R1,??DataTable7_9
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_MutexDbgListAdd_0
    919                  p_mutex->DbgNextPtr           = DEF_NULL;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_MutexDbgListAdd_1
    920              } else {
    921                  p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
   \                     ??OS_MutexDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable7_9
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    922                  OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
   \   0000001C   0x....             LDR.N    R1,??DataTable7_9
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    923              }
    924              OSMutexDbgListPtr                 =  p_mutex;
   \                     ??OS_MutexDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable7_9
   \   00000024   0x6008             STR      R0,[R1, #+0]
    925          }
   \   00000026   0x4770             BX       LR               ;; return
    926          
    927          

   \                                 In section .text, align 2, keep-with-next
    928          void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
    929          {
    930              OS_MUTEX  *p_mutex_next;
    931              OS_MUTEX  *p_mutex_prev;
    932          
    933          
    934              p_mutex_prev = p_mutex->DbgPrevPtr;
   \                     OS_MutexDbgListRemove: (+1)
   \   00000000   0x6943             LDR      R3,[R0, #+20]
   \   00000002   0x001A             MOVS     R2,R3
    935              p_mutex_next = p_mutex->DbgNextPtr;
   \   00000004   0x6983             LDR      R3,[R0, #+24]
   \   00000006   0x0019             MOVS     R1,R3
    936          
    937              if (p_mutex_prev == DEF_NULL) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD108             BNE.N    ??OS_MutexDbgListRemove_0
    938                  OSMutexDbgListPtr = p_mutex_next;
   \   0000000C   0x....             LDR.N    R3,??DataTable7_9
   \   0000000E   0x6019             STR      R1,[R3, #+0]
    939                  if (p_mutex_next != DEF_NULL) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??OS_MutexDbgListRemove_1
    940                      p_mutex_next->DbgPrevPtr = DEF_NULL;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x614B             STR      R3,[R1, #+20]
    941                  }
    942                  p_mutex->DbgNextPtr = DEF_NULL;
   \                     ??OS_MutexDbgListRemove_1: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x6183             STR      R3,[R0, #+24]
   \   0000001C   0xE00C             B.N      ??OS_MutexDbgListRemove_2
    943          
    944              } else if (p_mutex_next == DEF_NULL) {
   \                     ??OS_MutexDbgListRemove_0: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OS_MutexDbgListRemove_3
    945                  p_mutex_prev->DbgNextPtr = DEF_NULL;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x6193             STR      R3,[R2, #+24]
    946                  p_mutex->DbgPrevPtr      = DEF_NULL;
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x6143             STR      R3,[R0, #+20]
   \   0000002A   0xE005             B.N      ??OS_MutexDbgListRemove_2
    947          
    948              } else {
    949                  p_mutex_prev->DbgNextPtr =  p_mutex_next;
   \                     ??OS_MutexDbgListRemove_3: (+1)
   \   0000002C   0x6191             STR      R1,[R2, #+24]
    950                  p_mutex_next->DbgPrevPtr =  p_mutex_prev;
   \   0000002E   0x614A             STR      R2,[R1, #+20]
    951                  p_mutex->DbgNextPtr      = DEF_NULL;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x6183             STR      R3,[R0, #+24]
    952                  p_mutex->DbgPrevPtr      = DEF_NULL;
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x6143             STR      R3,[R0, #+20]
    953              }
    954          }
   \                     ??OS_MutexDbgListRemove_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    955          #endif
    956          
    957          
    958          /*
    959          ************************************************************************************************************************
    960          *                                               MUTEX GROUP ADD
    961          *
    962          * Description: This function is called by the kernel to add a mutex to a task's mutex group.
    963          *
    964          
    965          * Argument(s): p_tcb        is a pointer to the tcb of the task to give the mutex to.
    966          *
    967          *              p_mutex      is a point to the mutex to add to the group.
    968          *
    969          *
    970          * Returns    : none
    971          *
    972          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    973          ************************************************************************************************************************
    974          */
    975          

   \                                 In section .text, align 2, keep-with-next
    976          void  OS_MutexGrpAdd (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
    977          {
    978              p_mutex->MutexGrpNextPtr = p_tcb->MutexGrpHeadPtr;      /* The mutex grp is not sorted add to head of list.       */
   \                     OS_MutexGrpAdd: (+1)
   \   00000000   0x6C42             LDR      R2,[R0, #+68]
   \   00000002   0x620A             STR      R2,[R1, #+32]
    979              p_tcb->MutexGrpHeadPtr   = p_mutex;
   \   00000004   0x6441             STR      R1,[R0, #+68]
    980          }
   \   00000006   0x4770             BX       LR               ;; return
    981          
    982          
    983          /*
    984          ************************************************************************************************************************
    985          *                                              MUTEX GROUP REMOVE
    986          *
    987          * Description: This function is called by the kernel to remove a mutex to a task's mutex group.
    988          *
    989          
    990          * Argument(s): p_tcb        is a pointer to the tcb of the task to remove the mutex from.
    991          *
    992          *              p_mutex      is a point to the mutex to remove from the group.
    993          *
    994          *
    995          * Returns    : none
    996          *
    997          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    998          ************************************************************************************************************************
    999          */
   1000          

   \                                 In section .text, align 2, keep-with-next
   1001          void  OS_MutexGrpRemove (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
   1002          {
   1003              OS_MUTEX  **pp_mutex;
   1004          
   1005              pp_mutex = &p_tcb->MutexGrpHeadPtr;
   \                     OS_MutexGrpRemove: (+1)
   \   00000000   0xF110 0x0344      ADDS     R3,R0,#+68
   \   00000004   0x001A             MOVS     R2,R3
   1006          
   1007              while(*pp_mutex != p_mutex) {
   \                     ??OS_MutexGrpRemove_0: (+1)
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0x428B             CMP      R3,R1
   \   0000000A   0xD002             BEQ.N    ??OS_MutexGrpRemove_1
   1008                  pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x3220             ADDS     R2,R2,#+32
   \   00000010   0xE7F9             B.N      ??OS_MutexGrpRemove_0
   1009              }
   1010          
   1011              *pp_mutex = (*pp_mutex)->MutexGrpNextPtr;
   \                     ??OS_MutexGrpRemove_1: (+1)
   \   00000012   0x6813             LDR      R3,[R2, #+0]
   \   00000014   0x6A1B             LDR      R3,[R3, #+32]
   \   00000016   0x6013             STR      R3,[R2, #+0]
   1012          }
   \   00000018   0x4770             BX       LR               ;; return
   1013          
   1014          
   1015          /*
   1016          ************************************************************************************************************************
   1017          *                                              MUTEX FIND HIGHEST PENDING
   1018          *
   1019          * Description: This function is called by the kernel to find the highest task pending on any mutex from a group.
   1020          *
   1021          
   1022          * Argument(s): p_tcb        is a pointer to the tcb of the task to process.
   1023          *
   1024          *
   1025          * Returns    : Highest priority pending or OS_CFG_PRIO_MAX - 1u if none found.
   1026          *
   1027          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1028          ************************************************************************************************************************
   1029          */
   1030          

   \                                 In section .text, align 2, keep-with-next
   1031          OS_PRIO  OS_MutexGrpPrioFindHighest (OS_TCB  *p_tcb)
   1032          {
   \                     OS_MutexGrpPrioFindHighest: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
   1033              OS_MUTEX  **pp_mutex;
   1034              OS_PRIO     highest_prio;
   1035              OS_PRIO     prio;
   1036              OS_TCB     *p_head;
   1037          
   1038          
   1039              highest_prio = (OS_PRIO)(OS_CFG_PRIO_MAX - 1u);
   \   00000004   0x251F             MOVS     R5,#+31
   \   00000006   0x0028             MOVS     R0,R5
   1040              pp_mutex = &p_tcb->MutexGrpHeadPtr;
   \   00000008   0xF111 0x0544      ADDS     R5,R1,#+68
   \   0000000C   0x002A             MOVS     R2,R5
   1041          
   1042              while(*pp_mutex != DEF_NULL) {
   \                     ??OS_MutexGrpPrioFindHighest_0: (+1)
   \   0000000E   0x6815             LDR      R5,[R2, #+0]
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD00F             BEQ.N    ??OS_MutexGrpPrioFindHighest_1
   1043                  p_head = (*pp_mutex)->PendList.HeadPtr;
   \   00000014   0x6815             LDR      R5,[R2, #+0]
   \   00000016   0x68AD             LDR      R5,[R5, #+8]
   \   00000018   0x002C             MOVS     R4,R5
   1044                  if (p_head != DEF_NULL) {
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD007             BEQ.N    ??OS_MutexGrpPrioFindHighest_2
   1045                      prio = p_head->Prio;
   \   0000001E   0xF894 0x503F      LDRB     R5,[R4, #+63]
   \   00000022   0x002B             MOVS     R3,R5
   1046                      if(prio < highest_prio) {
   \   00000024   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x4283             CMP      R3,R0
   \   0000002A   0xD200             BCS.N    ??OS_MutexGrpPrioFindHighest_2
   1047                          highest_prio = prio;
   \   0000002C   0x0018             MOVS     R0,R3
   1048                      }
   1049                  }
   1050                  pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
   \                     ??OS_MutexGrpPrioFindHighest_2: (+1)
   \   0000002E   0x6812             LDR      R2,[R2, #+0]
   \   00000030   0x3220             ADDS     R2,R2,#+32
   \   00000032   0xE7EC             B.N      ??OS_MutexGrpPrioFindHighest_0
   1051              }
   1052          
   1053              return (highest_prio);
   \                     ??OS_MutexGrpPrioFindHighest_1: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xBC30             POP      {R4,R5}
   \   00000038   0x4770             BX       LR               ;; return
   1054          }
   1055          
   1056          
   1057          /*
   1058          ************************************************************************************************************************
   1059          *                                               MUTEX GROUP POST ALL
   1060          *
   1061          * Description: This function is called by the kernel to post (release) all the mutex from a group. Used when deleting
   1062          *              a task.
   1063          *
   1064          
   1065          * Argument(s): p_tcb        is a pointer to the tcb of the task to process.
   1066          *
   1067          *
   1068          * Returns    : none.
   1069          *
   1070          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1071          ************************************************************************************************************************
   1072          */
   1073          

   \                                 In section .text, align 2, keep-with-next
   1074          void  OS_MutexGrpPostAll (OS_TCB  *p_tcb)
   1075          {
   \                     OS_MutexGrpPostAll: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1076              OS_MUTEX      *p_mutex;
   1077              OS_MUTEX      *p_mutex_next;
   1078              CPU_TS         ts;
   1079              OS_PEND_LIST  *p_pend_list;
   1080              OS_TCB        *p_tcb_new;
   1081          
   1082          
   1083              p_mutex = p_tcb->MutexGrpHeadPtr;
   \   00000006   0x6C60             LDR      R0,[R4, #+68]
   \   00000008   0x0005             MOVS     R5,R0
   1084          
   1085              while(p_mutex != DEF_NULL) {
   \                     ??OS_MutexGrpPostAll_0: (+1)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD02A             BEQ.N    ??OS_MutexGrpPostAll_1
   1086          
   1087                  OS_TRACE_MUTEX_POST(p_mutex);
   1088          
   1089                  p_mutex_next = p_mutex->MutexGrpNextPtr;
   \   0000000E   0x6A28             LDR      R0,[R5, #+32]
   \   00000010   0x0006             MOVS     R6,R0
   1090          #if (OS_CFG_TS_EN == DEF_ENABLED)
   1091                  ts           = OS_TS_GET();                             /* Get timestamp                                        */
   \   00000012   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000016   0x0007             MOVS     R7,R0
   1092                  p_mutex->TS  = ts;
   \   00000018   0x62EF             STR      R7,[R5, #+44]
   1093          #else
   1094                  ts           = 0u;
   1095          #endif
   1096                  OS_MutexGrpRemove(p_tcb,  p_mutex);                     /* Remove mutex from owner's group                      */
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       OS_MutexGrpRemove
   1097          
   1098                  p_pend_list = &p_mutex->PendList;
   \   00000022   0xF115 0x0008      ADDS     R0,R5,#+8
   \   00000026   0x4680             MOV      R8,R0
   1099                  if (p_pend_list->HeadPtr == DEF_NULL) {                 /* Any task waiting on mutex?                           */
   \   00000028   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD105             BNE.N    ??OS_MutexGrpPostAll_2
   1100                      p_mutex->OwnerNestingCtr = 0u;                      /* Decrement owner's nesting counter                    */
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF885 0x0028      STRB     R0,[R5, #+40]
   1101                      p_mutex->OwnerTCBPtr     = DEF_NULL;                /* No                                                   */
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6268             STR      R0,[R5, #+36]
   \   0000003A   0xE011             B.N      ??OS_MutexGrpPostAll_3
   1102                  } else {
   1103                                                                          /* Get TCB from head of pend list                       */
   1104                      p_tcb_new                = p_pend_list->HeadPtr;
   \                     ??OS_MutexGrpPostAll_2: (+1)
   \   0000003C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000040   0x4681             MOV      R9,R0
   1105                      p_mutex->OwnerTCBPtr     = p_tcb;                   /* Give mutex to new owner                              */
   \   00000042   0x626C             STR      R4,[R5, #+36]
   1106                      p_mutex->OwnerNestingCtr = 1u;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xF885 0x0028      STRB     R0,[R5, #+40]
   1107                      OS_MutexGrpAdd(p_tcb_new, p_mutex);
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       OS_MutexGrpAdd
   1108                                                                          /* Post to mutex                                        */
   1109                      OS_Post((OS_PEND_OBJ *)p_mutex,
   1110                                             p_tcb_new,
   1111                                             DEF_NULL,
   1112                                             0u,
   1113                                             ts);
   \   00000052   0x9700             STR      R7,[SP, #+0]
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x4649             MOV      R1,R9
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       OS_Post
   1114                  }
   1115          
   1116                  p_mutex = p_mutex_next;
   \                     ??OS_MutexGrpPostAll_3: (+1)
   \   00000060   0x0035             MOVS     R5,R6
   \   00000062   0xE7D2             B.N      ??OS_MutexGrpPostAll_0
   1117              }
   1118          
   1119          }
   \                     ??OS_MutexGrpPostAll_1: (+1)
   \   00000064   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x5854554D         DC32     0x5854554d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     OSMutexQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     OSMutexDbgListPtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x3F 0x4D          DC8 "?MUTEX"
   \              0x55 0x54    
   \              0x45 0x58    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
   1120          
   1121          #endif /* OS_CFG_MUTEX_EN */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSMutexCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MutexDbgListAdd
        24   -> OS_PendListInit
      48   OSMutexDel
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_TS_TmrRd
        48   -> OSSched
        48   -> OS_MutexClr
        48   -> OS_MutexDbgListRemove
        48   -> OS_MutexGrpPrioFindHighest
        48   -> OS_MutexGrpRemove
        48   -> OS_PendAbort
        48   -> OS_TaskChangePrio
      32   OSMutexPend
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_MutexGrpAdd
        32   -> OS_Pend
        32   -> OS_TaskChangePrio
      48   OSMutexPendAbort
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CPU_TS_TmrRd
        48   -> OSSched
        48   -> OS_MutexGrpPrioFindHighest
        48   -> OS_PendAbort
        48   -> OS_TaskChangePrio
      40   OSMutexPost
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_MutexGrpAdd
        40   -> OS_MutexGrpPrioFindHighest
        40   -> OS_MutexGrpRemove
        40   -> OS_Post
        40   -> OS_PrioInsert
        40   -> OS_RdyListInsertTail
        40   -> OS_RdyListRemove
       8   OS_MutexClr
         8   -> OS_PendListInit
       0   OS_MutexDbgListAdd
       0   OS_MutexDbgListRemove
       0   OS_MutexGrpAdd
      32   OS_MutexGrpPostAll
        32   -> CPU_TS_TmrRd
        32   -> OS_MutexGrpAdd
        32   -> OS_MutexGrpRemove
        32   -> OS_Post
       8   OS_MutexGrpPrioFindHighest
       0   OS_MutexGrpRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       8  ?_0
       2  ?_1
     120  OSMutexCreate
     360  OSMutexDel
     528  OSMutexPend
     308  OSMutexPendAbort
     390  OSMutexPost
      40  OS_MutexClr
      40  OS_MutexDbgListAdd
      58  OS_MutexDbgListRemove
       8  OS_MutexGrpAdd
     104  OS_MutexGrpPostAll
      58  OS_MutexGrpPrioFindHighest
      26  OS_MutexGrpRemove

 
    10 bytes in section .rodata
 2 080 bytes in section .text
 
 2 080 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none

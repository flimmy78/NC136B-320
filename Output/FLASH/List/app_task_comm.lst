###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Dec/2017  08:42:36
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320 IC卡模块\Software\APP\Tasks\app_task_comm.c
#    Command line =  
#        "F:\iar\NC136B-320 IC卡模块\Software\APP\Tasks\app_task_comm.c" -D
#        RELEASE -lCN "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\app_task_comm.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\app_task_comm.o
#
###############################################################################

F:\iar\NC136B-320 IC卡模块\Software\APP\Tasks\app_task_comm.c
      1          /*******************************************************************************
      2           *   Filename:       app_task_comm.c
      3           *   Revised:        All copyrights reserved to wumingshen.
      4           *   Revision:       v1.0
      5           *   Writer:	     wumingshen.
      6           *
      7           *   Description:    双击选中 comm 按 Ctrl + H, 钩选 Match the case, Replace with
      8           *                   输入您要的名字，点击 Replace All
      9           *                   双击选中 Comm 按 Ctrl + H, 钩选 Match the case, Replace with
     10           *                   输入您要的名字，点击 Replace All
     11           *                   双击选中 COMM 按 Ctrl + H, 钩选 Match the case, Replace with
     12           *                   输入您要的名字，点击 Replace All
     13           *                   在 app_cfg.h 中指定本任务的 优先级  （ APP_TASK_COMM_PRIO     ）
     14           *                                            和 任务堆栈（ APP_TASK_COMM_STK_SIZE ）大小
     15           *
     16           *   Notes:
     17           *     				E-mail: shenchangwei945@163.com
     18           *
     19           *******************************************************************************/
     20          
     21          /*******************************************************************************
     22           * INCLUDES
     23           */
     24          #define  SNL_APP_SOURCE
     25          #include <includes.h>
     26          #include <app_comm_protocol.h>
     27          #include <app_ctrl.h>
     28          #include <os_cfg_app.h>
     29          #include <CrcCheck.h>
     30          
     31          //#include <bsp_flash.h>
     32          //#include <iap.h>
     33          
     34          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     35          const  CPU_CHAR  *app_task_comm__c = "$Id: $";
     36          #endif
     37          
     38          #define APP_TASK_COMM_EN     DEF_ENABLED
     39          #if APP_TASK_COMM_EN == DEF_ENABLED
     40          /*******************************************************************************
     41           * CONSTANTS
     42           */
     43          
     44          /*******************************************************************************
     45           * MACROS
     46           */
     47          #define CYCLE_TIME_TICKS            (OS_TICKS_PER_SEC * 1)
     48          
     49          /*******************************************************************************
     50           * TYPEDEFS
     51           */
     52          
     53          
     54          
     55          /***********************************************
     56          * 描述： 任务控制块（TCB）
     57          */

   \                                 In section .bss, align 4
     58          static  OS_TCB   AppTaskCommTCB;
   \                     AppTaskCommTCB:
   \   00000000                      DS8 160
     59          
     60          /***********************************************
     61          * 描述： 任务堆栈（STACKS）
     62          */

   \                                 In section .bss, align 4
     63          static  CPU_STK  AppTaskCommStk[ APP_TASK_COMM_STK_SIZE ];
   \                     AppTaskCommStk:
   \   00000000                      DS8 2048
     64          
     65          //StrCtrlDCB       Ctrl;
     66          

   \                                 In section .bss, align 4
     67          OS_Q             MTR_RxQ;
   \                     MTR_RxQ:
   \   00000000                      DS8 48
     68          /*******************************************************************************
     69           * LOCAL VARIABLES
     70           */
     71          
     72          /*******************************************************************************
     73           * GLOBAL VARIABLES
     74           */
     75          
     76          /***********************************************
     77          * 描述： 软定时器声明
     78          */

   \                                 In section .bss, align 4
     79          OS_TMR          OSTmr1;                         //定时器1
   \                     OSTmr1:
   \   00000000                      DS8 48
     80          
     81          /***********************************************
     82          * 描述： 软定时器回调函数
     83          */
     84          void            OSTmr1_callback             (OS_TMR *ptmr,void *p_arg);
     85          CPU_BOOLEAN     APP_CSNC_CommHandler        (MODBUS_CH  *pch);
     86          CPU_BOOLEAN     APP_MaterCommHandler        (MODBUS_CH  *pch);
     87          
     88          /*******************************************************************************
     89           * LOCAL FUNCTIONS
     90           */
     91          static void    AppTaskComm                 (void *p_arg);
     92          static void    APP_CommInit                (void);
     93                  void    App_McuStatusInit           (void);
     94                  void    ReportDevStatusHandle       (void);
     95                  void    InformCommConfigMode        (u8 mode);
     96          static void    App_ModbusInit              (void);
     97          
     98          INT08U          APP_CommRxDataDealCB        (MODBUS_CH  *pch);
     99          INT08U          IAP_CommRxDataDealCB        (MODBUS_CH  *pch);
    100          /*******************************************************************************
    101           * GLOBAL FUNCTIONS
    102           */
    103          
    104          /*******************************************************************************
    105           * EXTERN VARIABLES
    106           */
    107          
    108           /*******************************************************************************
    109           * EXTERN FUNCTIONS
    110           */
    111          extern  void    app_comm_mtr(void);
    112          extern  void    app_comm_dtu(void);
    113          extern  void    app_comm_otr(void);
    114          
    115          unsigned char GetRecSlaveAddr(void);
    116          void    comm_para_flow(StrDevOtr * sDtu,uint8 addrnum);
    117          void    comm_rec_read (StrDevOtr * sDtu,uint8 addrnum);
    118          
    119          
    120          /*******************************************************************************/
    121          
    122          /*******************************************************************************
    123           * 名    称： App_TaskCommCreate
    124           * 功    能： **任务创建
    125           * 入口参数： 无
    126           * 出口参数： 无
    127           * 作　 　者： wumingshen.
    128           * 创建日期： 2015-02-05
    129           * 修    改：
    130           * 修改日期：
    131           * 备    注： 任务创建函数需要在app.h文件中声明
    132           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    133          void  App_TaskCommCreate(void)
    134          {
   \                     App_TaskCommCreate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    135              OS_ERR  err;
    136          
    137              /***********************************************
    138              * 描述： 任务创建
    139              */
    140              OSTaskCreate((OS_TCB     *)&AppTaskCommTCB,                     // 任务控制块  （当前文件中定义）
    141                           (CPU_CHAR   *)"App Task Comm",                     // 任务名称
    142                           (OS_TASK_PTR ) AppTaskComm,                        // 任务函数指针（当前文件中定义）
    143                           (void       *) 0,                                  // 任务函数参数
    144                           (OS_PRIO     ) APP_TASK_COMM_PRIO,                 // 任务优先级，不同任务优先级可以相同，0 < 优先级 < OS_CFG_PRIO_MAX - 2（app_cfg.h中定义）
    145                           (CPU_STK    *)&AppTaskCommStk[0],                  // 任务栈顶
    146                           (CPU_STK_SIZE) APP_TASK_COMM_STK_SIZE / 10,        // 任务栈溢出报警值
    147                           (CPU_STK_SIZE) APP_TASK_COMM_STK_SIZE,             // 任务栈大小（CPU数据宽度 * 8 * size = 4 * 8 * size(字节)）（app_cfg.h中定义）
    148                           (OS_MSG_QTY  ) 0u,                                 // 可以发送给任务的最大消息队列数量
    149                           (OS_TICK     ) 0u,                                 // 相同优先级任务的轮循时间（ms），0为默认
    150                           (void       *) 0,                                  // 是一个指向它被用作一个TCB扩展用户提供的存储器位置
    151                           (OS_OPT      )(OS_OPT_TASK_STK_CHK |               // 允许堆栈检查该任务
    152                                          OS_OPT_TASK_STK_CLR),               // 创建任务时堆栈清零
    153                           (OS_ERR     *)&err);                               // 指向错误代码的指针，用于创建结果处理
   \   00000004   0xA809             ADD      R0,SP,#+36
   \   00000006   0x9008             STR      R0,[SP, #+32]
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x9007             STR      R0,[SP, #+28]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9006             STR      R0,[SP, #+24]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9005             STR      R0,[SP, #+20]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9004             STR      R0,[SP, #+16]
   \   00000018   0xF44F 0x7000      MOV      R0,#+512
   \   0000001C   0x9003             STR      R0,[SP, #+12]
   \   0000001E   0x2033             MOVS     R0,#+51
   \   00000020   0x9002             STR      R0,[SP, #+8]
   \   00000022   0x....             LDR.N    R0,??DataTable5
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x2016             MOVS     R0,#+22
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x.... 0x....      ADR.W    R2,AppTaskComm
   \   00000030   0x....             LDR.N    R1,??DataTable5_1
   \   00000032   0x....             LDR.N    R0,??DataTable5_2
   \   00000034   0x.... 0x....      BL       OSTaskCreate
    154          
    155          }
   \   00000038   0xB00B             ADD      SP,SP,#+44
   \   0000003A   0xBD00             POP      {PC}             ;; return
    156          
    157          extern  void    OS_ProtocolInit(void);
    158          /*******************************************************************************
    159           * 名    称： AppTaskComm
    160           * 功    能： 控制任务
    161           * 入口参数： p_arg - 由任务创建函数传入
    162           * 出口参数： 无
    163           * 作　 　者： wumingshen.
    164           * 创建日期： 2015-02-05
    165           * 修    改：
    166           * 修改日期：
    167           *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    168          static  void  AppTaskComm (void *p_arg)
    169          {
   \                     AppTaskComm: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    170              OS_ERR      err;
    171          
    172              OS_TICK     dly     = CYCLE_TIME_TICKS;
   \   00000008   0xF44F 0x757A      MOV      R5,#+1000
    173              OS_TICK     ticks;
    174              /***********************************************
    175              * 描述： 任务初始化
    176              
    177              */
    178              APP_CommInit();   
   \   0000000C   0x.... 0x....      BL       APP_CommInit
    179              
    180              InitFlashIO();      //初始化flash
   \   00000010   0x.... 0x....      BL       InitFlashIO
    181          
    182              GPIO_Fram_Init();   //初始化fram
   \   00000014   0x.... 0x....      BL       GPIO_Fram_Init
    183              
    184              InitDS3231();       //初始化时钟
   \   00000018   0x.... 0x....      BL       InitDS3231
    185              
    186              OS_ProtocolInit();
   \   0000001C   0x.... 0x....      BL       OS_ProtocolInit
    187              /***********************************************
    188              * 描述： 在看门狗标志组注册本任务的看门狗标志
    189              */
    190              OSRegWdtFlag(( OS_FLAGS     ) WDT_FLAG_COMM);     
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       OSRegWdtFlag
    191              /***********************************************
    192              * 描述： Task body, always written as an infinite loop.
    193              */
    194              while (DEF_TRUE) {         
    195                  /***********************************************
    196                  * 描述： 本任务看门狗标志置位
    197                  */
    198                  OSSetWdtFlag(( OS_FLAGS     ) WDT_FLAG_COMM);        
   \                     ??AppTaskComm_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      BL       OSSetWdtFlag
    199                  
    200                  OS_ERR      terr;
    201                  ticks   = OSTimeGet(&terr);                        // 获取当前OSTick
   \   0000002C   0xF10D 0x000A      ADD      R0,SP,#+10
   \   00000030   0x.... 0x....      BL       OSTimeGet
   \   00000034   0x0006             MOVS     R6,R0
    202                  /***********************************************
    203                  * 描述： 等待COMM的标识组
    204                  */
    205                  OS_FLAGS    flags = 
    206                  OSFlagPend( ( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    207                              ( OS_FLAGS     ) Ctrl.Os.CommEvtFlag,
    208                              ( OS_TICK      ) dly,
    209                              ( OS_OPT       ) OS_OPT_PEND_FLAG_SET_ANY,
    210                              ( CPU_TS      *) NULL,
    211                              ( OS_ERR      *)&err);
   \   00000036   0xA802             ADD      R0,SP,#+8
   \   00000038   0x9001             STR      R0,[SP, #+4]
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0x2308             MOVS     R3,#+8
   \   00000040   0x002A             MOVS     R2,R5
   \   00000042   0x....             LDR.N    R0,??DataTable5_3
   \   00000044   0xF8D0 0x129D      LDR      R1,[R0, #+669]
   \   00000048   0x....             LDR.N    R0,??DataTable5_4
   \   0000004A   0x.... 0x....      BL       OSFlagPend
   \   0000004E   0x0007             MOVS     R7,R0
    212          
    213                  /***********************************************
    214                  * 描述： 没有错误,有事件发生
    215                  */
    216                  if ( err == OS_ERR_NONE ) {
   \   00000050   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD129             BNE.N    ??AppTaskComm_1
    217                      OS_FLAGS    flagClr = 0;
   \   00000058   0xF05F 0x0800      MOVS     R8,#+0
    218          
    219                      /***********************************************
    220                      * 从机，如果收到数据通讯发起；或者有邋IC卡插入，同样发起通讯
    221                      */
    222                      //插入IC卡
    223                      if(    flags & COMM_EVT_FLAG_PLUG_CARD) {
   \   0000005C   0x0678             LSLS     R0,R7,#+25
   \   0000005E   0xD506             BPL.N    ??AppTaskComm_2
    224          
    225          					comm_para_flow((StrDevOtr *)&Ctrl.Otr,0);   	    //设置根据IC卡类型操作
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x....             LDR.N    R0,??DataTable5_5
   \   00000064   0x.... 0x....      BL       comm_para_flow
    226          					
    227          					flagClr |=  COMM_EVT_FLAG_PLUG_CARD; 
   \   00000068   0xF058 0x0840      ORRS     R8,R8,#0x40
   \   0000006C   0xE014             B.N      ??AppTaskComm_3
    228                         //接收到数据
    229                         } else if ( flags & COMM_EVT_FLAG_OTR_RX) {			   
   \                     ??AppTaskComm_2: (+1)
   \   0000006E   0x0778             LSLS     R0,R7,#+29
   \   00000070   0xD512             BPL.N    ??AppTaskComm_3
    230                         		//接收数据。 1、询问是否需要数据；2、数据记录
    231                         		if(Ctrl.Otr.RxCtrl.SourceAddr == MASTE_ADDR_HOST){	//主机地址
   \   00000072   0x....             LDR.N    R0,??DataTable5_3
   \   00000074   0xF890 0x0201      LDRB     R0,[R0, #+513]
   \   00000078   0x2880             CMP      R0,#+128
   \   0000007A   0xD103             BNE.N    ??AppTaskComm_4
    232                         		
    233          						comm_rec_read((StrDevOtr *)&Ctrl.Otr,0);		//取数据记录
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x....             LDR.N    R0,??DataTable5_5
   \   00000080   0x.... 0x....      BL       comm_rec_read
    234          					}
    235                         			
    236                              Ctrl.Otr.ConnCtrl[0].TimeOut   = 0;
   \                     ??AppTaskComm_4: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x....             LDR.N    R1,??DataTable5_3
   \   00000088   0xF881 0x020A      STRB     R0,[R1, #+522]
    237                              Ctrl.Otr.ConnCtrl[0].ErrFlg    = 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x....             LDR.N    R1,??DataTable5_3
   \   00000090   0xF881 0x020B      STRB     R0,[R1, #+523]
    238          
    239                         		flagClr |=  COMM_EVT_FLAG_OTR_RX;    				//接收到数据
   \   00000094   0xF058 0x0804      ORRS     R8,R8,#0x4
    240                         	}
    241                      
    242                      /***********************************************
    243                      * 描述： 清除标志
    244                      */
    245                      if ( !flagClr ) {
   \                     ??AppTaskComm_3: (+1)
   \   00000098   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000009C   0xD100             BNE.N    ??AppTaskComm_5
    246                          flagClr = flags;
   \   0000009E   0x46B8             MOV      R8,R7
    247                      }
    248                      
    249                      /***********************************************
    250                      * 描述： 清除标志位
    251                      */
    252                      OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.CommEvtFlagGrp,
    253                                  ( OS_FLAGS      )flagClr,
    254                                  ( OS_OPT        )OS_OPT_POST_FLAG_CLR,
    255                                  ( OS_ERR       *)&err);
   \                     ??AppTaskComm_5: (+1)
   \   000000A0   0xAB02             ADD      R3,SP,#+8
   \   000000A2   0x2201             MOVS     R2,#+1
   \   000000A4   0x4641             MOV      R1,R8
   \   000000A6   0x....             LDR.N    R0,??DataTable5_4
   \   000000A8   0x.... 0x....      BL       OSFlagPost
    256                  }
    257                  
    258                  
    259                  if(Ctrl.Otr.ConnCtrl[0].TimeOut++ > 2)         //2秒没通讯
   \                     ??AppTaskComm_1: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable5_3
   \   000000AE   0xF890 0x020A      LDRB     R0,[R0, #+522]
   \   000000B2   0x1C41             ADDS     R1,R0,#+1
   \   000000B4   0x....             LDR.N    R2,??DataTable5_3
   \   000000B6   0xF882 0x120A      STRB     R1,[R2, #+522]
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x2803             CMP      R0,#+3
   \   000000BE   0xDB03             BLT.N    ??AppTaskComm_6
    260                      Ctrl.Otr.ConnCtrl[0].ErrFlg = 1;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x....             LDR.N    R1,??DataTable5_3
   \   000000C4   0xF881 0x020B      STRB     R0,[R1, #+523]
    261                  
    262                  /***********************************************
    263                  * 描述： 去除任务运行的时间，等到一个控制周期里剩余需要延时的时间
    264                  */
    265                  dly   = CYCLE_TIME_TICKS - ( OSTimeGet(&err) - ticks );
   \                     ??AppTaskComm_6: (+1)
   \   000000C8   0xA802             ADD      R0,SP,#+8
   \   000000CA   0x.... 0x....      BL       OSTimeGet
   \   000000CE   0xF5D0 0x707A      RSBS     R0,R0,#+1000
   \   000000D2   0x1830             ADDS     R0,R6,R0
   \   000000D4   0x0005             MOVS     R5,R0
    266                  if ( dly  < 1 ) {
   \   000000D6   0x2D00             CMP      R5,#+0
   \   000000D8   0xD102             BNE.N    ??AppTaskComm_7
    267                      dly = 1;
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x0005             MOVS     R5,R0
   \   000000DE   0xE7A2             B.N      ??AppTaskComm_0
    268                  } else if ( dly > CYCLE_TIME_TICKS ) {
   \                     ??AppTaskComm_7: (+1)
   \   000000E0   0xF5B5 0x7F7A      CMP      R5,#+1000
   \   000000E4   0xD99F             BLS.N    ??AppTaskComm_0
    269                      dly = CYCLE_TIME_TICKS;
   \   000000E6   0xF44F 0x707A      MOV      R0,#+1000
   \   000000EA   0x0005             MOVS     R5,R0
   \   000000EC   0xE79B             B.N      ??AppTaskComm_0
    270                  }
    271              }
    272          }
    273          
    274          /*******************************************************************************
    275           * 名    称： APP_ModbusInit
    276           * 功    能： MODBUS初始化
    277           * 入口参数： 无
    278           * 出口参数： 无
    279           * 作　 　者： 无名沈
    280           * 创建日期： 2015-03-28
    281           * 修    改：
    282           * 修改日期：
    283           * 备    注： 该初始化会创建Modbus任务。
    284           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    285          void App_ModbusInit(void)
    286          {
   \                     App_ModbusInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    287              MODBUS_CH   *pch;
    288              /***********************************************
    289              * 描述： uCModBus初始化，RTU时钟频率为1000HZ
    290              *        使用了定时器2（TIM2）
    291              */
    292              MB_Init(1000);
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0x.... 0x....      BL       MB_Init
    293              
    294              // UART1
    295              /***********************************************
    296              * 描述：  UART1串口和测量装置连接。master
    297              *        用作主机。
    298              */
    299          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    300          
    301          #endif
    302              // UART1
    303              /***********************************************
    304              * 描述:   UART1串口。IC卡模块
    305              */
    306              
    307          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    308              pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    309                                      MODBUS_SLAVE,           // ... This is a MASTER
    310                                      500,                    // ... 0 when a slave
    311                                      MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    312                                      1,                      // ... Specify UART #2
    313                                      57600,                  // ... Baud Rate
    314                                      UART_DATABIT_8,         // ... Number of data bits 7 or 8
    315                                      UART_PARITY_NONE,       // ... Parity: _NONE, _ODD or _EVEN
    316                                      UART_STOPBIT_1,         // ... Number of stop bits 1 or 2
    317                                      MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x9005             STR      R0,[SP, #+20]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9004             STR      R0,[SP, #+16]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9003             STR      R0,[SP, #+12]
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x9002             STR      R0,[SP, #+8]
   \   0000001C   0xF44F 0x4061      MOV      R0,#+57600
   \   00000020   0x9001             STR      R0,[SP, #+4]
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0xF44F 0x72FA      MOV      R2,#+500
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x.... 0x....      BL       MB_CfgCh
   \   00000034   0x0004             MOVS     R4,R0
    318              pch->AesEn          =   DEF_DISABLED;           // ... AES加密禁止
   \   00000036   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   0000003A   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000003E   0xF884 0x0452      STRB     R0,[R4, #+1106]
    319              pch->NonModbusEn    =   DEF_ENABLED;            // ... 支持非MODBUS通信
   \   00000042   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000046   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004A   0xF884 0x0452      STRB     R0,[R4, #+1106]
    320              pch->IapModbusEn    =   DEF_ENABLED;            // ... 支持IAP MODBUS通信
   \   0000004E   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000052   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000056   0xF884 0x0452      STRB     R0,[R4, #+1106]
    321              
    322              pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
   \   0000005A   0xF241 0x0028      MOVW     R0,#+4136
   \   0000005E   0xF8A4 0x034A      STRH     R0,[R4, #+842]
    323              pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
   \   00000062   0xF241 0x002C      MOVW     R0,#+4140
   \   00000066   0xF8A4 0x034C      STRH     R0,[R4, #+844]
    324              
    325              Ctrl.Otr.pch       = pch;                      // ... modbus控制块和全局结构体建立连接
   \   0000006A   0x....             LDR.N    R0,??DataTable5_3
   \   0000006C   0xF8C0 0x4218      STR      R4,[R0, #+536]
    326          #endif
    327              
    328              // UART3
    329              /***********************************************
    330              * 描述：  UART3串口和IC卡模块连接。master
    331              *        
    332              */
    333          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    334          
    335          
    336          #endif
    337             
    338          }
   \   00000070   0xB006             ADD      SP,SP,#+24
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
    339          
    340          
    341          /*******************************************************************************
    342           * 名    称： APP_CommInit
    343           * 功    能： 任务初始化
    344           * 入口参数： 无
    345           * 出口参数： 无
    346           * 作　 　者： wumingshen.
    347           * 创建日期： 2015-03-28
    348           * 修    改：
    349           * 修改日期：
    350           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    351           void APP_CommInit(void)
    352          {
   \                     APP_CommInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    353              OS_ERR err;
    354              
    355              /***********************************************
    356              * 描述： 创建事件标志组,协调comm收发
    357              */
    358              OSFlagCreate(( OS_FLAG_GRP  *)&Ctrl.Os.CommEvtFlagGrp,
    359                           ( CPU_CHAR     *)"App_CommFlag",
    360                           ( OS_FLAGS      )0,
    361                           ( OS_ERR       *)&err);
   \   00000002   0x466B             MOV      R3,SP
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable5_6
   \   00000008   0x....             LDR.N    R0,??DataTable5_4
   \   0000000A   0x.... 0x....      BL       OSFlagCreate
    362              
    363              Ctrl.Os.CommEvtFlag=   COMM_EVT_FLAG_OTR_RX        // OTR 接收事件
    364                                   +  COMM_EVT_FLAG_OTR_TIMEOUT  // OTR 操作超时，定时发送使用
    365                                   +  COMM_EVT_FLAG_PLUG_CARD;  // IC卡触发
   \   0000000E   0x2064             MOVS     R0,#+100
   \   00000010   0x....             LDR.N    R1,??DataTable5_3
   \   00000012   0xF8C1 0x029D      STR      R0,[R1, #+669]
    366          
    367              
    368              /***********************************************
    369              * 描述： 初始化MODBUS通信
    370              */        
    371              App_ModbusInit();    
   \   00000016   0x.... 0x....      BL       App_ModbusInit
    372          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    373          
    374          
    375          
    376          /*******************************************************************************
    377          * 名    称： APP_CommRxDataDealCB
    378          * 功    能： 串口数据处理回调函数，由MB_DATA.C调用
    379          * 入口参数： 无
    380          * 出口参数： 无
    381          * 作    者： 无名沈
    382          * 创建日期： 2016-01-04
    383          * 修    改：
    384          * 修改日期：
    385          * 备    注： 
    386          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    387          INT08U APP_CommRxDataDealCB(MODBUS_CH  *pch)
    388          {
   \                     APP_CommRxDataDealCB: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
    389              /***********************************************
    390              * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    391              */
    392          #if MB_IAPMODBUS_EN == DEF_ENABLED
    393              //    /***********************************************
    394              //    * 描述： 如果程序处在升级模式
    395              //    */
    396              //    if ( ( Iap.Status != IAP_STS_DEF ) && 
    397              //         ( Iap.Status != IAP_STS_SUCCEED ) &&
    398              //         ( Iap.Status != IAP_STS_FAILED ) ) {
    399              //        return IAP_CommRxDataDealCB(pch);
    400              //    }
    401          #endif
    402              /***********************************************
    403              * 描述： 获取帧头
    404              */
    405          //    CPU_SR_ALLOC();
    406              
    407              //redmorningcn 数据复制功能由MBS_RTU_Task 已经执行。此处无需重复拷贝。
    408              
    409              //    CPU_CRITICAL_ENTER();
    410              //    //u8  Len     = pch->RxBufByteCtr;
    411              u8  Len     = pch->RxBufByteCnt;
   \   00000008   0x8E60             LDRH     R0,[R4, #+50]
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    412              //    memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    413              //    CPU_CRITICAL_EXIT();
    414              
    415              OS_ERR      err;
    416              
    417              //DataBuf = pch->RxFrameData;
    418              
    419              //INT08U  *DataBuf = 0 ;
    420              /***********************************************
    421              * 描述： 接收数据处理,
    422              * 根据协议，返回数据是            源地址
    423              *           目标地址由           GetRecSlaveAddr （）获得。
    424              *           数据区长度在          Len
    425              *           数据区                 DataBuf
    426              *           接收序号            GetRecvFrameNbr（）
    427              */  
    428              uint8   DataPos;
    429              u8  SourceAddr = 
    430                  CSNC_GetData(	(uint8 *)pch->RxFrameData,          //RecBuf,
    431                                  (uint16 )Len,                       //RecLen, 
    432                                  (uint8 *)&DataPos,                   //DataBuf,
    433                                  (uint16 *)&Len);                    //InfoLen)
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000014   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0xF514 0x7011      ADDS     R0,R4,#+580
   \   0000001E   0x.... 0x....      BL       CSNC_GetData
   \   00000022   0x0005             MOVS     R5,R0
    434              
    435              /***********************************************
    436              * 描述： 如果接收地址和装置地址不符，则不处理，接收数据错误。
    437              */
    438              if ( SLAVE_ADDR_OTR != GetRecSlaveAddr() ) 
   \   00000024   0x.... 0x....      BL       GetRecSlaveAddr
   \   00000028   0x28C1             CMP      R0,#+193
   \   0000002A   0xD001             BEQ.N    ??APP_CommRxDataDealCB_0
    439                  return FALSE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE067             B.N      ??APP_CommRxDataDealCB_1
    440              
    441              /***********************************************
    442              * 描述： 根据 地址  pch来源  判断数据是 否 合理 ，
    443              *       并赋值。
    444              */
    445              //switch  (pch->Ch )
    446              switch  (pch->PortNbr )     //根据端口号定义
   \                     ??APP_CommRxDataDealCB_0: (+1)
   \   00000030   0x7A60             LDRB     R0,[R4, #+9]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD005             BEQ.N    ??APP_CommRxDataDealCB_2
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD061             BEQ.N    ??APP_CommRxDataDealCB_3
   \   0000003A   0xD303             BCC.N    ??APP_CommRxDataDealCB_4
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD05D             BEQ.N    ??APP_CommRxDataDealCB_5
   \   00000040   0xE05D             B.N      ??APP_CommRxDataDealCB_6
    447              {
    448                  /***********************************************
    449                  * 描述： UART0接收到数据
    450                  */
    451              case 0:
    452                  break;
   \                     ??APP_CommRxDataDealCB_2: (+1)
   \   00000042   0xE05C             B.N      ??APP_CommRxDataDealCB_6
    453                  
    454                  /***********************************************
    455                  * 描述： UART1接收到数据。数据发送地址：A1、A2
    456                  *                         数据接收地址：80
    457                  */        
    458              case 1:
    459                     if(         MASTE_ADDR_HOST == SourceAddr 
    460                         )   
   \                     ??APP_CommRxDataDealCB_4: (+1)
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D80             CMP      R5,#+128
   \   00000048   0xD147             BNE.N    ??APP_CommRxDataDealCB_7
    461                      {
    462                          Ctrl.Otr.RxCtrl.SourceAddr = SourceAddr;           //源地址
   \   0000004A   0x....             LDR.N    R0,??DataTable5_3
   \   0000004C   0xF880 0x5201      STRB     R5,[R0, #+513]
    463                          Ctrl.Otr.RxCtrl.DestAddr   = GetRecSlaveAddr();    //目标地址
   \   00000050   0x.... 0x....      BL       GetRecSlaveAddr
   \   00000054   0x....             LDR.N    R1,??DataTable5_3
   \   00000056   0xF881 0x0200      STRB     R0,[R1, #+512]
    464                          Ctrl.Otr.RxCtrl.FramNum    = GetRecvFrameNbr();    //接收到的帧号
   \   0000005A   0x.... 0x....      BL       GetRecvFrameNbr
   \   0000005E   0x....             LDR.N    R1,??DataTable5_3
   \   00000060   0xF881 0x0202      STRB     R0,[R1, #+514]
    465                          
    466                         /***********************************************
    467                          * 描述：无线通讯及IC卡通讯，定义数据区的前 4 个字节为命令字，   
    468                          *                           ，4字节后才是真正的数据。                        
    469                          */                   
    470                          if(Len >=4)                                        
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x2804             CMP      R0,#+4
   \   0000006A   0xDB12             BLT.N    ??APP_CommRxDataDealCB_8
    471                          {
    472          //                    Ctrl.Otr.RxCtrl.Len        = Len - 4;                  //数据区长度
    473          //                    //取数据记录，将数据记录保存到接收区
    474          //                    OS_CRITICAL_ENTER();
    475          //                        memcpy( (INT08U *)&Ctrl.Otr.RxCtrl.Code, (INT08U *)&pch->RxFrameData[DataPos], 4);        //功能码
    476          //                        memcpy( (INT08U *)&Ctrl.Otr.Rd.Buf[0],   (INT08U *)&pch->RxFrameData[DataPos+4], Len-4 );   //数据区
    477          //                    OS_CRITICAL_EXIT();                    
    478                              Ctrl.Otr.RxCtrl.Len        = Len;                  //数据区长度    只接收数据记录、查询
   \   0000006C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000070   0x....             LDR.N    R1,??DataTable5_3
   \   00000072   0xF881 0x0203      STRB     R0,[R1, #+515]
    479                              //取数据记录，将数据记录保存到接收区
    480                              //OS_CRITICAL_ENTER();
    481                                  memcpy( (INT08U *)&Ctrl.Otr.Rd.Buf[0],   (INT08U *)&pch->RxFrameData[DataPos], Len );   //数据区
   \   00000076   0xF89D 0x6000      LDRB     R6,[SP, #+0]
   \   0000007A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000007E   0x1900             ADDS     R0,R0,R4
   \   00000080   0xF510 0x7711      ADDS     R7,R0,#+580
   \   00000084   0x.... 0x....      LDR.W    R8,??DataTable5_5
   \   00000088   0x0032             MOVS     R2,R6
   \   0000008A   0x0039             MOVS     R1,R7
   \   0000008C   0x4640             MOV      R0,R8
   \   0000008E   0x.... 0x....      BL       __aeabi_memcpy
    482                              //OS_CRITICAL_EXIT(); 
    483                              
    484                          }
    485                          /***********************************************
    486                          * 描述： UART2连接状态描述
    487                          */       
    488                          for(uint8 i = 0;i< COMM_DEV_OTR_CONN_NUM;i++)
   \                     ??APP_CommRxDataDealCB_8: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \                     ??APP_CommRxDataDealCB_9: (+1)
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x2802             CMP      R0,#+2
   \   00000098   0xDA18             BGE.N    ??APP_CommRxDataDealCB_10
    489                          {
    490                              if( Ctrl.Otr.ConnCtrl[i].SlaveAddr == SourceAddr){
   \   0000009A   0x....             LDR.N    R1,??DataTable5_3
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   000000A2   0xF891 0x120C      LDRB     R1,[R1, #+524]
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x42A9             CMP      R1,R5
   \   000000AA   0xD10D             BNE.N    ??APP_CommRxDataDealCB_11
    491                                  Ctrl.Otr.ConnCtrl[i].RecvEndFlg  = 1;      //接收到数据，置1。数据处理后置0
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x....             LDR.N    R2,??DataTable5_3
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000B6   0xF882 0x1209      STRB     R1,[R2, #+521]
    492                                  Ctrl.Otr.ConnCtrl[i].TimeOut     = 0;      //超时计数器清零。
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0x....             LDR.N    R2,??DataTable5_3
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000C4   0xF882 0x120A      STRB     R1,[R2, #+522]
    493                              }
    494                          } 
   \                     ??APP_CommRxDataDealCB_11: (+1)
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \   000000CA   0xE7E3             B.N      ??APP_CommRxDataDealCB_9
    495                          
    496                          OSFlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    497                          ( OS_FLAGS     ) COMM_EVT_FLAG_OTR_RX,
    498                          ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    499                          ( OS_ERR      *) &err);       
   \                     ??APP_CommRxDataDealCB_10: (+1)
   \   000000CC   0xF10D 0x0302      ADD      R3,SP,#+2
   \   000000D0   0x2200             MOVS     R2,#+0
   \   000000D2   0x2104             MOVS     R1,#+4
   \   000000D4   0x....             LDR.N    R0,??DataTable5_4
   \   000000D6   0x.... 0x....      BL       OSFlagPost
    500                      }
    501                          
    502                      Ctrl.Otr.ConnectFlag       = 1;
   \                     ??APP_CommRxDataDealCB_7: (+1)
   \   000000DA   0x....             LDR.N    R0,??DataTable5_3
   \   000000DC   0xF890 0x021C      LDRB     R0,[R0, #+540]
   \   000000E0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000E4   0x....             LDR.N    R1,??DataTable5_3
   \   000000E6   0xF881 0x021C      STRB     R0,[R1, #+540]
    503                      Ctrl.Otr.ConnectTimeOut    = 0;   
   \   000000EA   0x....             LDR.N    R0,??DataTable5_3
   \   000000EC   0xF890 0x021C      LDRB     R0,[R0, #+540]
   \   000000F0   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   000000F4   0x....             LDR.N    R1,??DataTable5_3
   \   000000F6   0xF881 0x021C      STRB     R0,[R1, #+540]
    504                      
    505                      break;
   \   000000FA   0xE000             B.N      ??APP_CommRxDataDealCB_6
    506                  
    507                  /***********************************************
    508                  * 描述： UART3接收到数据。数据发送地址：CA、C2
    509                  *                         数据接收地址:80
    510                  */   
    511              case 3:
    512          
    513                  
    514                  break;
   \                     ??APP_CommRxDataDealCB_5: (+1)
   \   000000FC   0xE7FF             B.N      ??APP_CommRxDataDealCB_6
    515                  /***********************************************
    516                  * 描述： UART2接收到数据
    517                  */   
    518              case 2:
    519          
    520                  
    521                  break;
    522              }
    523              
    524              return TRUE;
   \                     ??APP_CommRxDataDealCB_3: (+1)
   \                     ??APP_CommRxDataDealCB_6: (+1)
   \   000000FE   0x2001             MOVS     R0,#+1
   \                     ??APP_CommRxDataDealCB_1: (+1)
   \   00000100   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    525          }
    526          
    527          /***********************************************
    528          * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    529          */
    530          #if MB_IAPMODBUS_EN == DEF_ENABLED
    531          /*******************************************************************************
    532           * 名    称： APP_CommRxDataDealCB
    533           * 功    能： 串口数据处理回调函数，由MB_DATA.C调用
    534           * 入口参数： 无
    535           * 出口参数： 无
    536           * 作    者： 无名沈
    537           * 创建日期： 2016-01-04
    538           * 修    改：
    539           * 修改日期：
    540           * 备    注： 
    541           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    542          INT08U IAP_CommRxDataDealCB(MODBUS_CH  *pch)
    543          {
   \                     IAP_CommRxDataDealCB: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    544          //    CPU_SR_ALLOC();
    545          //    CPU_CRITICAL_ENTER();
    546          //    u8  Len     = pch->RxBufByteCtr;
    547          //    memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    548          //    CPU_CRITICAL_EXIT();
    549          //    
    550          //    /***********************************************
    551          //    * 描述： 获取帧头
    552          //    */    
    553          //    INT08U  *DataBuf    = pch->RxFrameData;
    554          //    
    555          //    /***********************************************
    556          //    * 描述： 接收数据处理
    557          //    */
    558          //    u8  DstAddr = 
    559          //    CSNC_GetData(	(unsigned char *)pch->RxFrameData,          //RecBuf,
    560          //                    (unsigned char	 )Len,                       //RecLen, 
    561          //                    (unsigned char *)DataBuf,                   //DataBuf,
    562          //                    (unsigned short *)&Len);                    //InfoLen)
    563          //    /***********************************************
    564          //    * 描述： 检测接收结束
    565          //    */
    566          //    if ( ( Len == 16) && 
    567          //         ( 0 >= memcmp((const char *)"IAP_pragram end!",(const char *)&pch->RxFrameData[8], 16) ) ) {
    568          //        /***********************************************
    569          //        * 描述： 发送数据处理
    570          //        */
    571          //        CSNC_SendData(	(MODBUS_CH      *)Ctrl.Com.pch,
    572          //                        (unsigned char  ) Ctrl.Com.SlaveAddr,          // SourceAddr,
    573          //                        (unsigned char  ) Ctrl.Com.Rd.Head.SrcAddr,    // DistAddr,
    574          //                        (unsigned char *)&pch->RxFrameData[8],          // DataBuf,
    575          //                        (unsigned short ) Len); 
    576          //        /***********************************************
    577          //        * 描述： 置位IAP结束标志位
    578          //        */
    579          //        OS_ERR err;
    580          //        OS_FlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    581          //                    ( OS_FLAGS     ) COMM_EVT_FLAG_IAP_END,
    582          //                    ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    583          //                    ( CPU_TS       ) 0,
    584          //                    ( OS_ERR      *) &err);
    585          //        
    586          //        return TRUE;
    587          //    }
    588          //    
    589          //    if ( ( Len == 18) && 
    590          //         ( 0 >= memcmp((const char *)"IAP_pragram start!",(const char *)&pch->RxFrameData[8], 18) ) ) {
    591          //        
    592          //#if defined     (IMAGE_A) || defined   (IMAGE_B)
    593          //#else
    594          //        /***********************************************
    595          //        * 描述： 发送数据处理
    596          //        */
    597          //        CSNC_SendData(	(MODBUS_CH      *)Ctrl.Com.pch,
    598          //                        (unsigned char  ) Ctrl.Com.SlaveAddr,          // SourceAddr,
    599          //                        (unsigned char  ) Ctrl.Com.Rd.Head.SrcAddr,    // DistAddr,
    600          //                        (unsigned char *)&pch->RxFrameData[8],         // DataBuf,
    601          //                        (unsigned int	 ) Len);                        // DataLen 
    602          //#endif
    603          //        IAP_Restart();
    604          //        Iap.FrameIdx    = 0;
    605          //        return TRUE;
    606          //    }
    607          //    
    608          //    if ( Iap.Status < IAP_STS_START )
    609          //        return TRUE;
    610          //    /***********************************************
    611          //    * 描述： 写数据
    612          //    */
    613          //    /***********************************************
    614          //    * 描述： 将数据打包给发送结构
    615          //    */
    616          //    Ctrl.Com.Wr.Head.DataLen       = 0;
    617          //    /***********************************************
    618          //    * 描述： 编辑应答内容
    619          //    */
    620          //    char str[20];
    621          //    usprintf(str,"\n%d",Iap.FrameIdx);
    622          //    str[19]  = 0;
    623          //    /***********************************************
    624          //    * 描述： 写数据到Flash
    625          //    */
    626          //    IAP_Program((StrIapState *)&Iap, (INT16U *)&pch->RxFrameData[8], Len, (INT16U )GetRecvFrameNbr() );
    627          //    /***********************************************
    628          //    * 描述： 发送数据处理
    629          //    */
    630          //    CSNC_SendData(	(MODBUS_CH     *) Ctrl.Com.pch,
    631          //                    (unsigned char  ) Ctrl.Com.SlaveAddr,                    // SourceAddr,
    632          //                    (unsigned char  ) Ctrl.Com.Rd.Head.SrcAddr,              // DistAddr,
    633          //                    (unsigned char *) str,                                    // DataBuf,
    634          //                    (unsigned short ) strlen(str));                           // DataLen 
    635          //    if ( Len < 128 ) {
    636          //        /***********************************************
    637          //        * 描述： 置位IAP结束标志位
    638          //        */
    639          //        OS_ERR err;
    640          //        OS_FlagPost(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    641          //                    ( OS_FLAGS     ) COMM_EVT_FLAG_IAP_END,
    642          //                    ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    643          //                    ( CPU_TS       ) 0,
    644          //                    ( OS_ERR      *) &err);
    645          //    } else {
    646          //        IAP_Programing();                               // 复位超时计数器
    647          //    }
    648          //        
    649          //    /***********************************************
    650          //    * 描述： 串口接受COMM模组的消息并处理
    651          //    */
    652          //    Ctrl.Com.ConnectTimeOut    = 0;                // 超时计数器清零
    653          //    Ctrl.Com.ConnectFlag       = TRUE;             // 转连接成功标志
    654          //    
    655              return TRUE;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
    656          }
    657          #endif
    658          
    659          /*******************************************************************************
    660           * 名    称： NMBS_FCxx_Handler
    661           * 功    能： 非MODBUS串口数据处理回调函数，由mbs_core.d调用。处理接收中断应答。
    662           * 入口参数： 无
    663           * 出口参数： 无
    664           * 作    者： 无名沈
    665           * 创建日期： 2017-02-03
    666           * 修    改：
    667           * 修改日期：
    668           * 备    注： 
    669           *******************************************************************************/
    670          extern OS_Q                MTR_RxQ;
    671          extern OS_Q                COM_RxQ;
    672          extern OS_Q                DTU_RxQ;
    673          //CPU_BOOLEAN  NMBS_FCxx_Handler (MODBUS_CH  *pch)
    674          //{
    675          //    OS_ERR      err;
    676          //    CPU_INT16U  head    = BUILD_INT16U(pch->RxBuf[1], pch->RxBuf[0]);
    677          //    CPU_INT16U  tail    = BUILD_INT16U(pch->RxBuf[pch->RxBufByteCtr-1],
    678          //                                       pch->RxBuf[pch->RxBufByteCtr-2]);
    679          //    /***********************************************
    680          //    * 描述： 长沙南车DTU协议处理
    681          //    */
    682          //    
    683          //    if ( ( pch->RxFrameHead == head ) &&              
    684          //         ( pch->RxFrameTail == tail ) ) {
    685          //        APP_CommRxDataDealCB(pch);
    686          //        /***********************************************
    687          //        * 描述： 电表调试协议协议,电表协议协议处理处理
    688          //        */
    689          //    } else  if ( ( 0xAA55 == head ) || ( 0xAAAA == head ) ) {
    690          //        OS_ERR  err;
    691          //        
    692          //        CPU_SR_ALLOC();
    693          //        OS_CRITICAL_ENTER();
    694          //        memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, pch->RxBufByteCnt );
    695          //        OS_CRITICAL_EXIT();
    696          //        
    697          //        (void)OSQPost((OS_Q         *)&MTR_RxQ,
    698          //                      (void         *) pch,
    699          //                      (OS_MSG_SIZE   ) pch->RxBufByteCtr,
    700          //                      (OS_OPT        ) OS_OPT_POST_FIFO,
    701          //                      (OS_ERR       *)&err);
    702          //         //BSP_OS_TimeDly(5);
    703          //         /***********************************************
    704          //         * 描述： 电表协议协议处理
    705          //         */  
    706          //    } else {
    707          //        return DEF_FALSE;
    708          //    }
    709          //    return DEF_TRUE;
    710          //}
    711          

   \                                 In section .text, align 2, keep-with-next
    712          CPU_BOOLEAN  NMBS_FCxx_Handler (MODBUS_CH  *pch)
    713          {
   \                     NMBS_FCxx_Handler: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
    714          //    OS_ERR      err;
    715              //   CPU_INT16U  head    = BUILD_INT16U(pch->RxBuf[1], pch->RxBuf[0]);
    716              //    CPU_INT16U  tail    = BUILD_INT16U(pch->RxBuf[pch->RxBufByteCtr-1],
    717              //                                       pch->RxBuf[pch->RxBufByteCtr-2]);
    718              CPU_INT16U  head    = BUILD_INT16U( pch->RxFrameData[1], pch->RxFrameData[0]);
   \   00000008   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   0000000C   0xF894 0x1244      LDRB     R1,[R4, #+580]
   \   00000010   0xEB10 0x2501      ADDS     R5,R0,R1, LSL #+8
    719              CPU_INT16U  tail    = BUILD_INT16U( pch->RxFrameData[pch->RxBufByteCnt-1],
    720                                                 pch->RxFrameData[pch->RxBufByteCnt-2]);           //20170526 RxBufByteCtr 中断函数中动态更新。
   \   00000014   0x8E60             LDRH     R0,[R4, #+50]
   \   00000016   0x1900             ADDS     R0,R0,R4
   \   00000018   0xF890 0x0243      LDRB     R0,[R0, #+579]
   \   0000001C   0x8E61             LDRH     R1,[R4, #+50]
   \   0000001E   0x1909             ADDS     R1,R1,R4
   \   00000020   0xF891 0x1242      LDRB     R1,[R1, #+578]
   \   00000024   0xEB10 0x2601      ADDS     R6,R0,R1, LSL #+8
    721              
    722              /***********************************************
    723              * 描述： 长沙南车DTU协议处理
    724              */
    725              
    726              if ( ( pch->RxFrameHead == head ) &&              
    727                  ( pch->RxFrameTail == tail ) ) {
   \   00000028   0xF8B4 0x034A      LDRH     R0,[R4, #+842]
   \   0000002C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD108             BNE.N    ??NMBS_FCxx_Handler_0
   \   00000032   0xF8B4 0x034C      LDRH     R0,[R4, #+844]
   \   00000036   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000038   0x42B0             CMP      R0,R6
   \   0000003A   0xD103             BNE.N    ??NMBS_FCxx_Handler_0
    728                      APP_CommRxDataDealCB(pch);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       APP_CommRxDataDealCB
   \   00000042   0xE01E             B.N      ??NMBS_FCxx_Handler_1
    729                      /***********************************************
    730                      * 描述： 电表调试协议协议,电表协议协议处理处理
    731                      */
    732                  } else  if ( ( 0xAA55 == head ) || ( 0xAAAA == head ) ) {
   \                     ??NMBS_FCxx_Handler_0: (+1)
   \   00000044   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000046   0xF64A 0x2055      MOVW     R0,#+43605
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0xD004             BEQ.N    ??NMBS_FCxx_Handler_2
   \   0000004E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000050   0xF64A 0x20AA      MOVW     R0,#+43690
   \   00000054   0x4285             CMP      R5,R0
   \   00000056   0xD112             BNE.N    ??NMBS_FCxx_Handler_3
    733                      OS_ERR  err;
    734                      
    735                      //CPU_SR_ALLOC();
    736                      //OS_CRITICAL_ENTER();
    737                      memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, pch->RxBufByteCnt );
   \                     ??NMBS_FCxx_Handler_2: (+1)
   \   00000058   0x8E67             LDRH     R7,[R4, #+50]
   \   0000005A   0xF114 0x0838      ADDS     R8,R4,#+56
   \   0000005E   0xF514 0x7911      ADDS     R9,R4,#+580
   \   00000062   0x003A             MOVS     R2,R7
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x4648             MOV      R0,R9
   \   00000068   0x.... 0x....      BL       __aeabi_memcpy
    738                      //OS_CRITICAL_EXIT();
    739                      
    740                      (void)OSQPost((OS_Q         *)&MTR_RxQ,
    741                                    (void         *) pch,
    742                                    //(OS_MSG_SIZE   ) pch->RxBufByteCtr,
    743                                    (OS_MSG_SIZE   ) pch->RxBufByteCnt,
    744                                    (OS_OPT        ) OS_OPT_POST_FIFO,
    745                                    (OS_ERR       *)&err);
   \   0000006C   0xA801             ADD      R0,SP,#+4
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x2300             MOVS     R3,#+0
   \   00000072   0x8E62             LDRH     R2,[R4, #+50]
   \   00000074   0x0021             MOVS     R1,R4
   \   00000076   0x....             LDR.N    R0,??DataTable5_7
   \   00000078   0x.... 0x....      BL       OSQPost
   \   0000007C   0xE001             B.N      ??NMBS_FCxx_Handler_1
    746                       //BSP_OS_TimeDly(5);
    747                       /***********************************************
    748                       * 描述： 电表协议协议处理
    749                       */  
    750                  } else {
    751                      return DEF_FALSE;
   \                     ??NMBS_FCxx_Handler_3: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??NMBS_FCxx_Handler_4
    752                  }
    753              return DEF_TRUE;
   \                     ??NMBS_FCxx_Handler_1: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \                     ??NMBS_FCxx_Handler_4: (+1)
   \   00000084   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
    754          }
    755          
    756          
    757          /*******************************************************************************
    758           * 名    称： APP_MaterCommHandler
    759           * 功    能： 电表串口数据处理函数
    760           * 入口参数： 无
    761           * 出口参数： 无
    762           * 作　　者： wumingshen.
    763           * 创建日期： 2015-03-28
    764           * 修    改：
    765           * 修改日期：
    766           *******************************************************************************/
    767          /***********************************************
    768          * 描述： 2015/12/07增加，用于非MODBBUS通信
    769          *        非MODBUS通信，带帧头帧尾的通信数据处理
    770          */
    771          #if MB_NONMODBUS_EN == DEF_ENABLED

   \                                 In section .text, align 2, keep-with-next
    772          CPU_BOOLEAN APP_MaterCommHandler (MODBUS_CH  *pch)
    773          {    
   \                     APP_MaterCommHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    774          //    uint8_t     fram_clr[4]     = {0};
    775          //	uint8_t     IDBuf[4]        = {0};
    776          //	uint8_t     clear_buf[24]   = {0};
    777          //	uint32_t    ID              = 0;
    778          //	uint32_t    utemp;
    779              	
    780          	//TIME        system; 
    781              
    782              /***********************************************
    783              * 描述： 拷贝数据到数据区
    784              */
    785              //CPU_SR_ALLOC();
    786              //CPU_CRITICAL_ENTER();
    787              //uint32_t  Len     = pch->RxBufByteCnt;
    788              //memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    789              //CPU_CRITICAL_EXIT();
    790              uint32_t    Len       = pch->RxBufByteCnt;
   \   00000006   0x8E65             LDRH     R5,[R4, #+50]
    791              INT08U      *DataBuf  = pch->RxFrameData;
   \   00000008   0xF514 0x7611      ADDS     R6,R4,#+580
    792              
    793              
    794              CPU_INT16U  head    = BUILD_INT16U(pch->RxBuf[1], pch->RxBuf[0]);
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   00000014   0xEB10 0x2701      ADDS     R7,R0,R1, LSL #+8
    795              CPU_INT16U  tail    = BUILD_INT16U(pch->RxBuf[pch->RxBufByteCnt-1],
    796                                                 pch->RxBuf[pch->RxBufByteCnt-2]);
   \   00000018   0x8E60             LDRH     R0,[R4, #+50]
   \   0000001A   0x1900             ADDS     R0,R0,R4
   \   0000001C   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   00000020   0x8E61             LDRH     R1,[R4, #+50]
   \   00000022   0x1909             ADDS     R1,R1,R4
   \   00000024   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \   00000028   0xEB10 0x2801      ADDS     R8,R0,R1, LSL #+8
    797              /***********************************************
    798              * 描述： 长沙南车DTU协议处理
    799              */
    800              if ( ( pch->RxFrameHead == head ) &&
    801                   ( pch->RxFrameTail == tail ) ) {
   \   0000002C   0xF8B4 0x034A      LDRH     R0,[R4, #+842]
   \   00000030   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000032   0x42B8             CMP      R0,R7
   \   00000034   0xD10D             BNE.N    ??APP_MaterCommHandler_0
   \   00000036   0xF8B4 0x034C      LDRH     R0,[R4, #+844]
   \   0000003A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000003E   0x4540             CMP      R0,R8
   \   00000040   0xD107             BNE.N    ??APP_MaterCommHandler_0
    802                  DataBuf = &pch->RxFrameData[8];
   \   00000042   0xF514 0x7013      ADDS     R0,R4,#+588
   \   00000046   0x0006             MOVS     R6,R0
    803          //        Len     = Ctrl.Com.Rd.Head.DataLen;        
    804                  head    = BUILD_INT16U(DataBuf[1], DataBuf[0]);
   \   00000048   0x7870             LDRB     R0,[R6, #+1]
   \   0000004A   0x7831             LDRB     R1,[R6, #+0]
   \   0000004C   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   00000050   0x0007             MOVS     R7,R0
    805              }
    806              
    807              /***********************************************
    808              * 描述： 
    809              序号    内容       字节数 内容说明
    810              1       帧头       2      0xAA 0xAA
    811              2       帧长度     1      0x08 帧长度固定为8字节
    812              3       命令类型   2      0x00 0x01
    813              4       预留       2      0x00 0x00
    814              5       累加和     1      前7个字节的累加和
    815              */ 
    816              if ( 0xAAAA == head ) {
   \                     ??APP_MaterCommHandler_0: (+1)
   \   00000052   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000054   0xF64A 0x20AA      MOVW     R0,#+43690
   \   00000058   0x4287             CMP      R7,R0
   \   0000005A   0xD10E             BNE.N    ??APP_MaterCommHandler_1
    817                  Len            -= 1;
   \   0000005C   0x1E6D             SUBS     R5,R5,#+1
    818                  int8_t chkSum   = GetCheckSum(DataBuf,Len);
   \   0000005E   0x0029             MOVS     R1,R5
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0x.... 0x....      BL       GetCheckSum
   \   00000066   0x0001             MOVS     R1,R0
    819                  
    820                  if ( chkSum ==  DataBuf[Len] ) {
   \   00000068   0x0008             MOVS     R0,R1
   \   0000006A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000006C   0x5DAA             LDRB     R2,[R5, R6]
   \   0000006E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000070   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000072   0x4290             CMP      R0,R2
   \   00000074   0xD113             BNE.N    ??APP_MaterCommHandler_2
    821          //            pch->TxFrameData[0]     = 0xAA;
    822          //            pch->TxFrameData[1]     = 0xAA;
    823          //            pch->TxFrameData[2]     = 0x30;
    824          //            pch->TxFrameData[3]     = 0x00;
    825          //            pch->TxFrameData[4]     = 0x71;
    826          //            
    827          //            CPU_SR  cpu_sr;
    828          //            OS_CRITICAL_ENTER();
    829          //            memcpy(&pch->TxFrameData[5],(uint8_t *)&Mater.Energy, sizeof(StrEnergy));
    830          //            OS_CRITICAL_EXIT();
    831          //            
    832          //            pch->TxFrameData[45]    = 0x00;
    833          //            pch->TxFrameData[46]    = 0x00;
    834          //            
    835          //            pch->TxFrameData[47]    = GetCheckSum(pch->TxFrameData,47);
    836          //            
    837          //            NMB_Tx((MODBUS_CH   *)pch,
    838          //                   (CPU_INT08U  *)pch->TxFrameData,
    839          //                   (CPU_INT16U   )48);
    840                      return TRUE;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE012             B.N      ??APP_MaterCommHandler_3
    841                  }
    842              /***********************************************
    843              * 描述： 调试参数
    844              */
    845              } else if ( ( 0xAA55 == head ) && ( Len > 10 )) {
   \                     ??APP_MaterCommHandler_1: (+1)
   \   0000007A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000007C   0xF64A 0x2055      MOVW     R0,#+43605
   \   00000080   0x4287             CMP      R7,R0
   \   00000082   0xD10C             BNE.N    ??APP_MaterCommHandler_2
   \   00000084   0x2D0B             CMP      R5,#+11
   \   00000086   0xD30A             BCC.N    ??APP_MaterCommHandler_2
    846                  /***********************************************
    847                  * 描述： 检测是否有帧尾，没有帧尾则进行CRC校验
    848                  */
    849                  if ( tail != 0x55AA  ) {
    850                      //uint16_t crc16_Cal = crc16((uint8_t *)&DataBuf[0],9);
    851                      //uint16_t crc16_Rec = BUILD_INT16U(DataBuf[9],DataBuf[10]);
    852                      //if(crc16_Cal != crc16_Rec) {                
    853                      //    return TRUE;
    854                      //}
    855                  }
    856                  switch(DataBuf[2])
   \   00000088   0x78B0             LDRB     R0,[R6, #+2]
   \   0000008A   0x28A1             CMP      R0,#+161
   \   0000008C   0xD004             BEQ.N    ??APP_MaterCommHandler_4
   \   0000008E   0xD306             BCC.N    ??APP_MaterCommHandler_5
   \   00000090   0x28A3             CMP      R0,#+163
   \   00000092   0xD003             BEQ.N    ??APP_MaterCommHandler_6
   \   00000094   0xD301             BCC.N    ??APP_MaterCommHandler_7
   \   00000096   0xE002             B.N      ??APP_MaterCommHandler_5
    857                  {
    858                  /***********************************************
    859                  * 描述： 设置序列号
    860                  */
    861                  case 0xA1:
    862          //            ID = BUILD_INT32U(DataBuf[3], DataBuf[4], DataBuf[5], DataBuf[6]);
    863                      //WriteFM24CL64(64 , (uint8_t *)&ID , 4);
    864                      //ReadFM24CL64(64 , (uint8_t *)&ID , 4);
    865          //            uartprintf(pch,"\r\n 本装置ID设置为：%d\r\n" , ID);
    866                      break;            
   \                     ??APP_MaterCommHandler_4: (+1)
   \   00000098   0xE001             B.N      ??APP_MaterCommHandler_2
    867                  /***********************************************
    868                  * 描述： 设置机车型号/机车号
    869                  */
    870                  case 0xA2:	
    871                      //Mater.LocoTyp   = BUILD_INT16U(DataBuf[3],DataBuf[4]);
    872                      //Mater.LocoNbr   = BUILD_INT16U(DataBuf[5],DataBuf[6]);
    873                      //WriteFM24CL64(68 , (uint8_t *)&Mater.LocoTyp, 2);
    874                      //WriteFM24CL64(70 , (uint8_t *)&Mater.LocoNbr, 2);
    875                      //ReadFM24CL64(68 ,  (uint8_t *)&Mater.LocoTyp, 2);
    876                      //ReadFM24CL64(70 ,  (uint8_t *)&Mater.LocoNbr, 2);
    877                      //uartprintf(pch,"\r\n 当前车型：%d；当前车号：%d\r\n", Mater.LocoTyp,Mater.LocoNbr);
    878                      break; 
   \                     ??APP_MaterCommHandler_7: (+1)
   \   0000009A   0xE000             B.N      ??APP_MaterCommHandler_2
    879                  /***********************************************
    880                  * 描述： 设置时间
    881                  */
    882                  case 0xA3:
    883          //            system.Year     =DataBuf[3];
    884          //            system.Month    =DataBuf[4];
    885          //            system.Day      =DataBuf[5];
    886          //            system.Hour     =DataBuf[6];
    887          //            system.Min      =DataBuf[7];
    888          //            system.Sec      =DataBuf[8];
    889          //            WriteTime(system);
    890          //            GetTime((TIME *)&recordsfr.Time[0]);
    891          //            uartprintf(pch,"\r\n 当前时间为：20%02d-%02d-%02d  %02d:%02d:%02d", 
    892          //                       recordsfr.Time[0], recordsfr.Time[1], recordsfr.Time[2],
    893          //                       recordsfr.Time[3], recordsfr.Time[4], recordsfr.Time[5]);
    894                      break;
   \                     ??APP_MaterCommHandler_6: (+1)
   \   0000009C   0xE7FF             B.N      ??APP_MaterCommHandler_2
    895                      
    896                  default:
    897                      break;
    898                  }
    899              }
    900              /***********************************************
    901              * 描述： 调用串口数据处理回调函数
    902              */ 
    903              return TRUE;
   \                     ??APP_MaterCommHandler_5: (+1)
   \                     ??APP_MaterCommHandler_2: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \                     ??APP_MaterCommHandler_3: (+1)
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    904          }
    905          
    906          /*******************************************************************************
    907           * 名    称： APP_CSNC_CommHandler
    908           * 功    能： 串口数据处理函数
    909           * 入口参数： 无
    910           * 出口参数： 无
    911           * 作　　者： wumingshen.
    912           * 创建日期： 2015-03-28
    913           * 修    改：
    914           * 修改日期：
    915           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    916          CPU_BOOLEAN APP_CSNC_CommHandler (MODBUS_CH  *pch)
    917          {   
   \                     APP_CSNC_CommHandler: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    918          //    if ( pch->PortNbr == Ctrl.Dtu.pch->PortNbr ) {
    919          //        if ( GetRecvFrameNbr() == Ctrl.Com.Rd.Head.PacketSn ) {
    920          //            /***********************************************
    921          //            * 描述： 清除定时上传标志
    922          //            */
    923          //            //SetSendFrameNbr();
    924          //            //extern void UpdateRecordPoint(uint8_t storeflag);
    925          //            //UpdateRecordPoint(1);
    926          //            //pch->StatNoRespCtr  = 0;
    927          //            
    928          //            //osal_set_event( OS_TASK_ID_TMR, OS_EVT_TMR_MIN);
    929          //        }
    930          //    } else {
    931          //        /***********************************************
    932          //        * 描述： 将数据打包给发送结构
    933          //        */ 
    934          //        APP_MaterCommHandler(pch);
    935          //    }
    936          //    
    937          //    /***********************************************
    938          //    * 描述： 串口接受COMM模组的消息并处理
    939          //    */
    940          //    Ctrl.Com.ConnectTimeOut    = 0;                // 超时计数器清零
    941          //    Ctrl.Com.ConnectFlag       = TRUE;             // 转连接成功标志
    942          //    
    943              return TRUE;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
    944          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     AppTaskCommStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     AppTaskCommTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     Ctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     Ctrl+0x275

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     Ctrl+0xBC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     MTR_RxQ

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x70          DC8 "App Task Comm"
   \              0x70 0x20    
   \              0x54 0x61    
   \              0x73 0x6B    
   \              0x20 0x43    
   \              0x6F 0x6D    
   \              0x6D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x70          DC8 "App_CommFlag"
   \              0x70 0x5F    
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x46 0x6C    
   \              0x61 0x67    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    945          #endif
    946          /*******************************************************************************
    947           * 				end of file
    948           *******************************************************************************/
    949          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   APP_CSNC_CommHandler
       8   APP_CommInit
         8   -> App_ModbusInit
         8   -> OSFlagCreate
      32   APP_CommRxDataDealCB
        32   -> CSNC_GetData
        32   -> GetRecSlaveAddr
        32   -> GetRecvFrameNbr
        32   -> OSFlagPost
        32   -> __aeabi_memcpy
      24   APP_MaterCommHandler
        24   -> GetCheckSum
      40   AppTaskComm
        40   -> APP_CommInit
        40   -> GPIO_Fram_Init
        40   -> InitDS3231
        40   -> InitFlashIO
        40   -> OSFlagPend
        40   -> OSFlagPost
        40   -> OSRegWdtFlag
        40   -> OSSetWdtFlag
        40   -> OSTimeGet
        40   -> OS_ProtocolInit
        40   -> comm_para_flow
        40   -> comm_rec_read
      32   App_ModbusInit
        32   -> MB_CfgCh
        32   -> MB_Init
      48   App_TaskCommCreate
        48   -> OSTaskCreate
       0   IAP_CommRxDataDealCB
      40   NMBS_FCxx_Handler
        40   -> APP_CommRxDataDealCB
        40   -> OSQPost
        40   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
      16  ?_0
      16  ?_1
       6  APP_CSNC_CommHandler
      28  APP_CommInit
     260  APP_CommRxDataDealCB
     164  APP_MaterCommHandler
     238  AppTaskComm
    2048  AppTaskCommStk
     160  AppTaskCommTCB
     116  App_ModbusInit
      60  App_TaskCommCreate
       6  IAP_CommRxDataDealCB
      48  MTR_RxQ
     136  NMBS_FCxx_Handler
      48  OSTmr1

 
 2 304 bytes in section .bss
    32 bytes in section .rodata
 1 046 bytes in section .text
 
 1 046 bytes of CODE  memory
    32 bytes of CONST memory
 2 304 bytes of DATA  memory

Errors: none
Warnings: 3

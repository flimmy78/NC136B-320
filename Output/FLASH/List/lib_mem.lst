###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Dec/2017  08:42:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uC-LIB\lib_mem.c
#    Command line =  
#        "F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uC-LIB\lib_mem.c" -D RELEASE -lCN
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\lib_mem.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\lib_mem.o
#
###############################################################################

F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                         (c) Copyright 2004-2015; Micrium, Inc.; Weston, FL
      7          *
      8          *                  All rights reserved.  Protected by international copyright laws.
      9          *
     10          *                  uC/LIB is provided in source form to registered licensees ONLY.  It is
     11          *                  illegal to distribute this source code to any third party unless you receive
     12          *                  written permission by an authorized Micrium representative.  Knowledge of
     13          *                  the source code may NOT be used to develop a similar product.
     14          *
     15          *                  Please help us continue to provide the Embedded community with the finest
     16          *                  software available.  Your honesty is greatly appreciated.
     17          *
     18          *                  You can find our product's user manual, API reference, release notes and
     19          *                  more information at: https://doc.micrium.com
     20          *
     21          *                  You can contact us at: http://www.micrium.com
     22          *********************************************************************************************************
     23          */
     24          
     25          /*
     26          *********************************************************************************************************
     27          *
     28          *                                     STANDARD MEMORY OPERATIONS
     29          *
     30          * Filename      : lib_mem.c
     31          * Version       : V1.38.02
     32          * Programmer(s) : ITJ
     33          *                 FGK
     34          *                 JFD
     35          *                 FBJ
     36          *                 EJ
     37          *********************************************************************************************************
     38          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     39          *
     40          *                     (a) ALL standard library functions are implemented in the custom library modules :
     41          *
     42          *                         (1) \<Custom Library Directory>\lib_*.*
     43          *
     44          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     45          *
     46          *                               where
     47          *                                       <Custom Library Directory>      directory path for custom library software
     48          *                                       <cpu>                           directory name for specific processor (CPU)
     49          *                                       <compiler>                      directory name for specific compiler
     50          *
     51          *                     (b) Product-specific library functions are implemented in individual products.
     52          *********************************************************************************************************
     53          */
     54          
     55          
     56          /*
     57          *********************************************************************************************************
     58          *                                            INCLUDE FILES
     59          *********************************************************************************************************
     60          */
     61          
     62          #define    MICRIUM_SOURCE
     63          #define    LIB_MEM_MODULE
     64          
     65          #include  <lib_mem.h>
     66          #include  <lib_math.h>
     67          #include  <lib_str.h>
     68          
     69          
     70          /*
     71          *********************************************************************************************************
     72          *                                            LOCAL DEFINES
     73          *********************************************************************************************************
     74          */
     75          
     76          
     77          /*
     78          *********************************************************************************************************
     79          *                                           LOCAL CONSTANTS
     80          *********************************************************************************************************
     81          */
     82          
     83          
     84          /*
     85          *********************************************************************************************************
     86          *                                          LOCAL DATA TYPES
     87          *********************************************************************************************************
     88          */
     89          
     90          
     91          /*
     92          *********************************************************************************************************
     93          *                                            LOCAL TABLES
     94          *********************************************************************************************************
     95          */
     96          
     97          
     98          /*
     99          *********************************************************************************************************
    100          *                                       LOCAL GLOBAL VARIABLES
    101          *********************************************************************************************************
    102          */
    103          
    104          
    105          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    106          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR

   \                                 In section .bss, align 4
    107          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                   /* Mem heap.                                            */
   \                     Mem_Heap:
   \   00000000                      DS8 1024
    108          #endif
    109          

   \                                 In section .bss, align 4
    110          MEM_SEG      Mem_SegHeap;                                       /* Heap mem seg.                                        */
   \                     Mem_SegHeap:
   \   00000000                      DS8 20
    111          #endif
    112          

   \                                 In section .bss, align 4
    113          MEM_SEG     *Mem_SegHeadPtr;                                    /* Ptr to head of seg list.                             */
   \                     Mem_SegHeadPtr:
   \   00000000                      DS8 4
    114          
    115          
    116          /*
    117          *********************************************************************************************************
    118          *                                      LOCAL FUNCTION PROTOTYPES
    119          *********************************************************************************************************
    120          */
    121          
    122          static  void          Mem_SegCreateCritical    (const  CPU_CHAR      *p_name,
    123                                                                 MEM_SEG       *p_seg,
    124                                                                 CPU_ADDR       seg_base_addr,
    125                                                                 CPU_SIZE_T     padding_align,
    126                                                                 CPU_SIZE_T     size);
    127          
    128          #if  (LIB_MEM_CFG_HEAP_SIZE > 0u)
    129          static  MEM_SEG      *Mem_SegOverlapChkCritical(       CPU_ADDR       seg_base_addr,
    130                                                                 CPU_SIZE_T     size,
    131                                                                 LIB_ERR       *p_err);
    132          #endif
    133          
    134          static  void         *Mem_SegAllocInternal     (const  CPU_CHAR      *p_name,
    135                                                                 MEM_SEG       *p_seg,
    136                                                                 CPU_SIZE_T     size,
    137                                                                 CPU_SIZE_T     align,
    138                                                                 CPU_SIZE_T     padding_align,
    139                                                                 CPU_SIZE_T    *p_bytes_reqd,
    140                                                                 LIB_ERR       *p_err);
    141          
    142          static  void         *Mem_SegAllocExtCritical  (       MEM_SEG       *p_seg,
    143                                                                 CPU_SIZE_T     size,
    144                                                                 CPU_SIZE_T     align,
    145                                                                 CPU_SIZE_T     padding_align,
    146                                                                 CPU_SIZE_T    *p_bytes_reqd,
    147                                                                 LIB_ERR       *p_err);
    148          
    149          static  void          Mem_DynPoolCreateInternal(const  CPU_CHAR      *p_name,
    150                                                                 MEM_DYN_POOL  *p_pool,
    151                                                                 MEM_SEG       *p_seg,
    152                                                                 CPU_SIZE_T     blk_size,
    153                                                                 CPU_SIZE_T     blk_align,
    154                                                                 CPU_SIZE_T     blk_padding_align,
    155                                                                 CPU_SIZE_T     blk_qty_init,
    156                                                                 CPU_SIZE_T     blk_qty_max,
    157                                                                 LIB_ERR       *p_err);
    158          
    159          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
    160          static  void          Mem_SegAllocTrackCritical(const  CPU_CHAR      *p_name,
    161                                                                 MEM_SEG       *p_seg,
    162                                                                 CPU_SIZE_T     size,
    163                                                                 LIB_ERR       *p_err);
    164          #endif
    165          
    166          #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
    167               (LIB_MEM_CFG_HEAP_SIZE      >  0u))
    168          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr   (       MEM_POOL      *p_pool,
    169                                                                 void          *p_mem);
    170          #endif
    171          
    172          
    173          /*
    174          *********************************************************************************************************
    175          *                                     LOCAL CONFIGURATION ERRORS
    176          *********************************************************************************************************
    177          */
    178          
    179          /*
    180          *********************************************************************************************************
    181          *********************************************************************************************************
    182          *                                            GLOBAL FUNCTIONS
    183          *********************************************************************************************************
    184          *********************************************************************************************************
    185          */
    186          
    187          /*
    188          *********************************************************************************************************
    189          *                                             Mem_Init()
    190          *
    191          * Description : (1) Initializes Memory Management Module :
    192          *
    193          *                   (a) Initialize heap memory pool
    194          *                   (b) Initialize      memory pool table
    195          *
    196          *
    197          * Argument(s) : none.
    198          *
    199          * Return(s)   : none.
    200          *
    201          * Caller(s)   : Application.
    202          *
    203          * Note(s)     : (2) Mem_Init() MUST be called ... :
    204          *
    205          *                   (a) ONLY ONCE from a product's application; ...
    206          *                   (b) BEFORE product's application calls any memory library module function(s)
    207          *********************************************************************************************************
    208          */
    209          

   \                                 In section .text, align 2, keep-with-next
    210          void  Mem_Init (void)
    211          {
   \                     Mem_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    212          
    213                                                                          /* ------------------ INIT SEG LIST ------------------- */
    214              Mem_SegHeadPtr = DEF_NULL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    215          
    216          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    217              {
    218                  LIB_ERR   err;
    219                  CPU_ADDR  heap_base_addr;
    220          
    221          
    222                                                                          /* ------------------ INIT HEAP SEG ------------------- */
    223          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    224                  heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
    225          #else
    226                  heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000010   0x0004             MOVS     R4,R0
    227          #endif
    228          
    229                  Mem_SegCreate("Heap",
    230                                &Mem_SegHeap,                             /* Create heap seg.                                     */
    231                                 heap_base_addr,
    232                                 LIB_MEM_CFG_HEAP_SIZE,
    233                                 LIB_MEM_PADDING_ALIGN_NONE,
    234                                &err);
   \   00000012   0xA802             ADD      R0,SP,#+8
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0xF44F 0x6380      MOV      R3,#+1024
   \   0000001E   0x0022             MOVS     R2,R4
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   00000028   0x.... 0x....      BL       Mem_SegCreate
    235                  if (err != LIB_MEM_ERR_NONE) {
   \   0000002C   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   00000030   0xF242 0x7110      MOVW     R1,#+10000
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD001             BEQ.N    ??Mem_Init_0
    236                      CPU_SW_EXCEPTION(;);
   \   00000038   0x.... 0x....      BL       CPU_SW_Exception
    237                  }
    238              }
    239          #endif
    240          }
   \                     ??Mem_Init_0: (+1)
   \   0000003C   0xBD1F             POP      {R0-R4,PC}       ;; return
    241          
    242          
    243          /*
    244          *********************************************************************************************************
    245          *                                              Mem_Clr()
    246          *
    247          * Description : Clears data buffer (see Note #2).
    248          *
    249          * Argument(s) : pmem        Pointer to memory buffer to clear.
    250          *
    251          *               size        Number of data buffer octets to clear (see Note #1).
    252          *
    253          * Return(s)   : none.
    254          *
    255          * Caller(s)   : Application.
    256          *
    257          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    258          *
    259          *                   See also 'Mem_Set()  Note #1'.
    260          *
    261          *               (2) Clear data by setting each data octet to 0.
    262          *********************************************************************************************************
    263          */
    264          

   \                                 In section .text, align 2, keep-with-next
    265          void  Mem_Clr (void        *pmem,
    266                         CPU_SIZE_T   size)
    267          {
   \                     Mem_Clr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    268              Mem_Set(pmem,
    269                      0u,                                                 /* See Note #2.                                         */
    270                      size);
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Mem_Set
    271          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    272          
    273          
    274          /*
    275          *********************************************************************************************************
    276          *                                              Mem_Set()
    277          *
    278          * Description : Fills data buffer with specified data octet.
    279          *
    280          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    281          *
    282          *               data_val    Data fill octet value.
    283          *
    284          *               size        Number of data buffer octets to fill (see Note #1).
    285          *
    286          * Return(s)   : none.
    287          *
    288          * Caller(s)   : Application.
    289          *
    290          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    291          *
    292          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    293          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    294          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    295          *                   addresses.
    296          *
    297          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    298          *                   address boundary.
    299          *
    300          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    301          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    302          *                  'mem_align_mod' arithmetic operation.
    303          *********************************************************************************************************
    304          */
    305          

   \                                 In section .text, align 2, keep-with-next
    306          void  Mem_Set (void        *pmem,
    307                         CPU_INT08U   data_val,
    308                         CPU_SIZE_T   size)
    309          {
   \                     Mem_Set: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    310              CPU_SIZE_T   size_rem;
    311              CPU_ALIGN    data_align;
    312              CPU_ALIGN   *pmem_align;
    313              CPU_INT08U  *pmem_08;
    314              CPU_DATA     mem_align_mod;
    315              CPU_DATA     i;
    316          
    317          
    318          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    319              if (size < 1) {                                             /* See Note #1.                                         */
    320                  return;
    321              }
    322              if (pmem == (void *)0) {
    323                  return;
    324              }
    325          #endif
    326          
    327          
    328              data_align = 0u;
   \   00000004   0xF05F 0x0E00      MOVS     LR,#+0
   \   00000008   0x4674             MOV      R4,LR
    329              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
   \   0000000A   0xF05F 0x0E00      MOVS     LR,#+0
   \   0000000E   0x46F4             MOV      R12,LR
   \                     ??Mem_Set_0: (+1)
   \   00000010   0xF1BC 0x0F04      CMP      R12,#+4
   \   00000014   0xD205             BCS.N    ??Mem_Set_1
    330                  data_align <<=  DEF_OCTET_NBR_BITS;
   \   00000016   0x0224             LSLS     R4,R4,#+8
    331                  data_align  |= (CPU_ALIGN)data_val;
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x430C             ORRS     R4,R1,R4
    332              }
   \   0000001C   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   00000020   0xE7F6             B.N      ??Mem_Set_0
    333          
    334              size_rem      =  size;
   \                     ??Mem_Set_1: (+1)
   \   00000022   0x0013             MOVS     R3,R2
    335              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
   \   00000024   0xF05F 0x0E04      MOVS     LR,#+4
   \   00000028   0xFBB0 0xF8FE      UDIV     R8,R0,LR
   \   0000002C   0xFB08 0x081E      MLS      R8,R8,LR,R0
   \   00000030   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000034   0x4647             MOV      R7,R8
    336          
    337              pmem_08 = (CPU_INT08U *)pmem;
   \   00000036   0x0006             MOVS     R6,R0
    338              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD00B             BEQ.N    ??Mem_Set_2
    339                  i = mem_align_mod;
   \   0000003C   0x46BC             MOV      R12,R7
    340                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    341                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
   \                     ??Mem_Set_3: (+1)
   \   0000003E   0x2B00             CMP      R3,#+0
   \   00000040   0xD008             BEQ.N    ??Mem_Set_2
   \   00000042   0xF1BC 0x0F04      CMP      R12,#+4
   \   00000046   0xD205             BCS.N    ??Mem_Set_2
    342                     *pmem_08++ = data_val;
   \   00000048   0x7031             STRB     R1,[R6, #+0]
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
    343                      size_rem -= sizeof(CPU_INT08U);
   \   0000004C   0x1E5B             SUBS     R3,R3,#+1
    344                      i++;
   \   0000004E   0xF11C 0x0C01      ADDS     R12,R12,#+1
   \   00000052   0xE7F4             B.N      ??Mem_Set_3
    345                  }
    346              }
    347          
    348              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
   \                     ??Mem_Set_2: (+1)
   \   00000054   0x0035             MOVS     R5,R6
    349              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
   \                     ??Mem_Set_4: (+1)
   \   00000056   0x2B04             CMP      R3,#+4
   \   00000058   0xD303             BCC.N    ??Mem_Set_5
    350                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \   0000005A   0x602C             STR      R4,[R5, #+0]
   \   0000005C   0x1D2D             ADDS     R5,R5,#+4
    351                  size_rem    -= sizeof(CPU_ALIGN);
   \   0000005E   0x1F1B             SUBS     R3,R3,#+4
   \   00000060   0xE7F9             B.N      ??Mem_Set_4
    352              }
    353          
    354              pmem_08 = (CPU_INT08U *)pmem_align;
   \                     ??Mem_Set_5: (+1)
   \   00000062   0x002E             MOVS     R6,R5
    355              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
   \                     ??Mem_Set_6: (+1)
   \   00000064   0x2B00             CMP      R3,#+0
   \   00000066   0xD003             BEQ.N    ??Mem_Set_7
    356                 *pmem_08++   = data_val;
   \   00000068   0x7031             STRB     R1,[R6, #+0]
   \   0000006A   0x1C76             ADDS     R6,R6,#+1
    357                  size_rem   -= sizeof(CPU_INT08U);
   \   0000006C   0x1E5B             SUBS     R3,R3,#+1
   \   0000006E   0xE7F9             B.N      ??Mem_Set_6
    358              }
    359          }
   \                     ??Mem_Set_7: (+1)
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    360          
    361          
    362          /*
    363          *********************************************************************************************************
    364          *                                             Mem_Copy()
    365          *
    366          * Description : Copies data octets from one memory buffer to another memory buffer.
    367          *
    368          * Argument(s) : pdest       Pointer to destination memory buffer.
    369          *
    370          *               psrc        Pointer to source      memory buffer.
    371          *
    372          *               size        Number of octets to copy (see Note #1).
    373          *
    374          * Return(s)   : none.
    375          *
    376          * Caller(s)   : Application.
    377          *
    378          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    379          *
    380          *               (2) Memory buffers NOT checked for overlapping.
    381          *
    382          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    383          *                       copying takes place between objects that overlap, the behavior is undefined".
    384          *
    385          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
    386          *                       successfully copy to a destination memory buffer at a lower  address value even
    387          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
    388          *                       word copy overlaps.
    389          *
    390          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
    391          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
    392          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    393          *                       ever overlap.
    394          *
    395          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    396          *                       buffers as long as the source memory buffer is at a higher address value than the
    397          *                       destination memory buffer.
    398          *
    399          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    400          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    401          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    402          *                   addresses.
    403          *
    404          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    405          *                   address boundary.
    406          *
    407          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    408          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    409          *                  'mem_align_mod' arithmetic operation.
    410          *********************************************************************************************************
    411          */
    412          
    413          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
    414          void  Mem_Copy (       void        *pdest,
    415                          const  void        *psrc,
    416                                 CPU_SIZE_T   size)
    417          {
    418                     CPU_SIZE_T    size_rem;
    419                     CPU_SIZE_T    mem_gap_octets;
    420                     CPU_ALIGN    *pmem_align_dest;
    421              const  CPU_ALIGN    *pmem_align_src;
    422                     CPU_INT08U   *pmem_08_dest;
    423              const  CPU_INT08U   *pmem_08_src;
    424                     CPU_DATA      i;
    425                     CPU_DATA      mem_align_mod_dest;
    426                     CPU_DATA      mem_align_mod_src;
    427                     CPU_BOOLEAN   mem_aligned;
    428          
    429          
    430          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    431              if (size < 1) {                                             /* See Note #1.                                         */
    432                  return;
    433              }
    434              if (pdest == (void *)0) {
    435                  return;
    436              }
    437              if (psrc  == (void *)0) {
    438                  return;
    439              }
    440          #endif
    441          
    442          
    443              size_rem           =  size;
    444          
    445              pmem_08_dest       = (      CPU_INT08U *)pdest;
    446              pmem_08_src        = (const CPU_INT08U *)psrc;
    447          
    448              mem_gap_octets     = (CPU_SIZE_T)(pmem_08_src - pmem_08_dest);
    449          
    450          
    451              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
    452                                                                          /* See Note #4.                                         */
    453                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
    454                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    455          
    456                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
    457          
    458                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
    459                                                                          /* ... optimize copy for mem buf alignment.             */
    460                      if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
    461                          i = mem_align_mod_dest;
    462                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    463                                 (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
    464                             *pmem_08_dest++ = *pmem_08_src++;
    465                              size_rem      -=  sizeof(CPU_INT08U);
    466                              i++;
    467                          }
    468                      }
    469          
    470                      pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3.                                         */
    471                      pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
    472                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    473                         *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
    474                          size_rem         -=  sizeof(CPU_ALIGN);
    475                      }
    476          
    477                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    478                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
    479                  }
    480              }
    481          
    482              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    483                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
    484                  size_rem      -=  sizeof(CPU_INT08U);
    485              }
    486          }
    487          #endif
    488          
    489          
    490          /*
    491          *********************************************************************************************************
    492          *                                             Mem_Move()
    493          *
    494          * Description : Moves data octets from one memory buffer to another memory buffer, or within the same
    495          *               memory buffer. Overlapping is correctly handled for all move operations.
    496          *
    497          * Argument(s) : pdest       Pointer to destination memory buffer.
    498          *
    499          *               psrc        Pointer to source      memory buffer.
    500          *
    501          *               size        Number of octets to move (see Note #1).
    502          *
    503          * Return(s)   : none.
    504          *
    505          * Caller(s)   : Application.
    506          *
    507          * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
    508          *
    509          *               (2) Memory buffers checked for overlapping.
    510          *
    511          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    512          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    513          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    514          *                   addresses.
    515          *
    516          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    517          *                   address boundary.
    518          *
    519          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    520          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    521          *                  'mem_align_mod' arithmetic operation.
    522          *********************************************************************************************************
    523          */
    524          

   \                                 In section .text, align 2, keep-with-next
    525          void  Mem_Move (       void        *pdest,
    526                          const  void        *psrc,
    527                                 CPU_SIZE_T   size)
    528          {
   \                     Mem_Move: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0014             MOVS     R4,R2
    529                     CPU_SIZE_T    size_rem;
    530                     CPU_SIZE_T    mem_gap_octets;
    531                     CPU_ALIGN    *pmem_align_dest;
    532              const  CPU_ALIGN    *pmem_align_src;
    533                     CPU_INT08U   *pmem_08_dest;
    534              const  CPU_INT08U   *pmem_08_src;
    535                     CPU_INT08S    i;
    536                     CPU_DATA      mem_align_mod_dest;
    537                     CPU_DATA      mem_align_mod_src;
    538                     CPU_BOOLEAN   mem_aligned;
    539          
    540          
    541          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    542              if (size < 1) {
    543                  return;
    544              }
    545              if (pdest == (void *)0) {
    546                  return;
    547              }
    548              if (psrc  == (void *)0) {
    549                  return;
    550              }
    551          #endif
    552          
    553              pmem_08_src  = (const CPU_INT08U *)psrc;
   \   00000008   0x9804             LDR      R0,[SP, #+16]
   \   0000000A   0x4681             MOV      R9,R0
    554              pmem_08_dest = (      CPU_INT08U *)pdest;
   \   0000000C   0x9803             LDR      R0,[SP, #+12]
   \   0000000E   0x4680             MOV      R8,R0
    555              if (pmem_08_src > pmem_08_dest) {
   \   00000010   0x45C8             CMP      R8,R9
   \   00000012   0xD205             BCS.N    ??Mem_Move_0
    556                  Mem_Copy(pdest, psrc, size);
   \   00000014   0x0022             MOVS     R2,R4
   \   00000016   0x9904             LDR      R1,[SP, #+16]
   \   00000018   0x9803             LDR      R0,[SP, #+12]
   \   0000001A   0x.... 0x....      BL       Mem_Copy
    557                  return;
   \   0000001E   0xE060             B.N      ??Mem_Move_1
    558              }
    559          
    560              size_rem           =  size;
   \                     ??Mem_Move_0: (+1)
   \   00000020   0x0025             MOVS     R5,R4
    561          
    562              pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
   \   00000022   0x9803             LDR      R0,[SP, #+12]
   \   00000024   0x1820             ADDS     R0,R4,R0
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x4680             MOV      R8,R0
    563              pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
   \   0000002A   0x9804             LDR      R0,[SP, #+16]
   \   0000002C   0x1820             ADDS     R0,R4,R0
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x4681             MOV      R9,R0
    564          
    565              mem_gap_octets     = (CPU_SIZE_T)(pmem_08_dest - pmem_08_src);
   \   00000032   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   00000036   0x9002             STR      R0,[SP, #+8]
    566          
    567          
    568              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \   00000038   0x9802             LDR      R0,[SP, #+8]
   \   0000003A   0x2804             CMP      R0,#+4
   \   0000003C   0xD345             BCC.N    ??Mem_Move_2
    569          
    570                                                                          /* See Note #4.                                         */
    571                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \   0000003E   0x2004             MOVS     R0,#+4
   \   00000040   0xFBB8 0xF1F0      UDIV     R1,R8,R0
   \   00000044   0xFB01 0x8110      MLS      R1,R1,R0,R8
   \   00000048   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004A   0x9100             STR      R1,[SP, #+0]
    572                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0xFBB9 0xF1F0      UDIV     R1,R9,R0
   \   00000052   0xFB01 0x9110      MLS      R1,R1,R0,R9
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x9101             STR      R1,[SP, #+4]
    573          
    574                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x9901             LDR      R1,[SP, #+4]
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD102             BNE.N    ??Mem_Move_3
   \   00000062   0xF05F 0x0B01      MOVS     R11,#+1
   \   00000066   0xE001             B.N      ??Mem_Move_4
   \                     ??Mem_Move_3: (+1)
   \   00000068   0xF05F 0x0B00      MOVS     R11,#+0
    575          
    576                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Move_4: (+1)
   \   0000006C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000070   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000074   0xD129             BNE.N    ??Mem_Move_2
    577                                                                          /* ... optimize copy for mem buf alignment.             */
    578                      if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x2803             CMP      R0,#+3
   \   0000007A   0xD014             BEQ.N    ??Mem_Move_5
    579                          i = (CPU_INT08S)mem_align_mod_dest;
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x4682             MOV      R10,R0
    580                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    581                                 (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
   \                     ??Mem_Move_6: (+1)
   \   00000080   0x2D00             CMP      R5,#+0
   \   00000082   0xD010             BEQ.N    ??Mem_Move_5
   \   00000084   0xFA4F 0xFA8A      SXTB     R10,R10          ;; SignExt  R10,R10,#+24,#+24
   \   00000088   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000008C   0xD40B             BMI.N    ??Mem_Move_5
    582                             *pmem_08_dest-- = *pmem_08_src--;
   \   0000008E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000092   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000096   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   0000009A   0xF1B8 0x0801      SUBS     R8,R8,#+1
    583                              size_rem      -=  sizeof(CPU_INT08U);
   \   0000009E   0x1E6D             SUBS     R5,R5,#+1
    584                              i--;
   \   000000A0   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   000000A4   0xE7EC             B.N      ??Mem_Move_6
    585                          }
    586                      }
    587          
    588                                                                          /* See Note #3.                                         */
    589                      pmem_align_dest = (      CPU_ALIGN *)(((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN)) + 1);
   \                     ??Mem_Move_5: (+1)
   \   000000A6   0xF1B8 0x0003      SUBS     R0,R8,#+3
   \   000000AA   0x0006             MOVS     R6,R0
    590                      pmem_align_src  = (const CPU_ALIGN *)(((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN)) + 1);
   \   000000AC   0xF1B9 0x0003      SUBS     R0,R9,#+3
   \   000000B0   0x0007             MOVS     R7,R0
    591                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
   \                     ??Mem_Move_7: (+1)
   \   000000B2   0x2D04             CMP      R5,#+4
   \   000000B4   0xD305             BCC.N    ??Mem_Move_8
    592                         *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \   000000B6   0x6838             LDR      R0,[R7, #+0]
   \   000000B8   0x6030             STR      R0,[R6, #+0]
   \   000000BA   0x1F3F             SUBS     R7,R7,#+4
   \   000000BC   0x1F36             SUBS     R6,R6,#+4
    593                          size_rem         -=  sizeof(CPU_ALIGN);
   \   000000BE   0x1F2D             SUBS     R5,R5,#+4
   \   000000C0   0xE7F7             B.N      ??Mem_Move_7
    594                      }
    595          
    596                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
   \                     ??Mem_Move_8: (+1)
   \   000000C2   0x1CF0             ADDS     R0,R6,#+3
   \   000000C4   0x4680             MOV      R8,R0
    597                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
   \   000000C6   0x1CF8             ADDS     R0,R7,#+3
   \   000000C8   0x4681             MOV      R9,R0
    598          
    599                  }
    600              }
    601          
    602              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
   \                     ??Mem_Move_2: (+1)
   \   000000CA   0x2D00             CMP      R5,#+0
   \   000000CC   0xD009             BEQ.N    ??Mem_Move_9
    603                 *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
   \   000000CE   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   000000D2   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000000D6   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   000000DA   0xF1B8 0x0801      SUBS     R8,R8,#+1
    604                  size_rem      -=  sizeof(CPU_INT08U);
   \   000000DE   0x1E6D             SUBS     R5,R5,#+1
   \   000000E0   0xE7F3             B.N      ??Mem_Move_2
    605              }
    606          }
   \                     ??Mem_Move_9: (+1)
   \                     ??Mem_Move_1: (+1)
   \   000000E2   0xB005             ADD      SP,SP,#+20
   \   000000E4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    607          
    608          
    609          /*
    610          *********************************************************************************************************
    611          *                                              Mem_Cmp()
    612          *
    613          * Description : Verifies that ALL data octets in two memory buffers are identical in sequence.
    614          *
    615          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    616          *
    617          *               p2_mem      Pointer to second memory buffer.
    618          *
    619          *               size        Number of data buffer octets to compare (see Note #1).
    620          *
    621          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    622          *
    623          *               DEF_NO,  otherwise.
    624          *
    625          * Caller(s)   : Application.
    626          *
    627          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
    628          *                   identical null compare.
    629          *
    630          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    631          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    632          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    633          *                   on dissimilar memory buffers that vary only in the least significant octets.
    634          *
    635          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    636          *                   data words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    637          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    638          *                   addresses.
    639          *
    640          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    641          *                   address boundary.
    642          *
    643          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    644          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    645          *                  'mem_align_mod' arithmetic operation.
    646          *********************************************************************************************************
    647          */
    648          

   \                                 In section .text, align 2, keep-with-next
    649          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
    650                                const  void        *p2_mem,
    651                                       CPU_SIZE_T   size)
    652          {
   \                     Mem_Cmp: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0003             MOVS     R3,R0
    653                     CPU_SIZE_T    size_rem;
    654                     CPU_ALIGN    *p1_mem_align;
    655                     CPU_ALIGN    *p2_mem_align;
    656              const  CPU_INT08U   *p1_mem_08;
    657              const  CPU_INT08U   *p2_mem_08;
    658                     CPU_DATA      i;
    659                     CPU_DATA      mem_align_mod_1;
    660                     CPU_DATA      mem_align_mod_2;
    661                     CPU_BOOLEAN   mem_aligned;
    662                     CPU_BOOLEAN   mem_cmp;
    663          
    664          
    665              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE.N    ??Mem_Cmp_0
    666                  return (DEF_YES);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE077             B.N      ??Mem_Cmp_1
    667              }
    668              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_0: (+1)
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD101             BNE.N    ??Mem_Cmp_2
    669                  return (DEF_NO);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE073             B.N      ??Mem_Cmp_1
    670              }
    671              if (p2_mem == (void *)0) {
   \                     ??Mem_Cmp_2: (+1)
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD101             BNE.N    ??Mem_Cmp_3
    672                  return (DEF_NO);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE06F             B.N      ??Mem_Cmp_1
    673              }
    674          
    675          
    676              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
   \                     ??Mem_Cmp_3: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x4683             MOV      R11,R0
    677              size_rem        =  size;
   \   00000022   0x0014             MOVS     R4,R2
    678                                                                          /* Start @ end of mem bufs (see Note #2).               */
    679              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
   \   00000024   0x18D0             ADDS     R0,R2,R3
   \   00000026   0x0007             MOVS     R7,R0
    680              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
   \   00000028   0x1850             ADDS     R0,R2,R1
   \   0000002A   0x4686             MOV      LR,R0
    681                                                                          /* See Note #4.                                         */
    682              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xFBB7 0xFCF0      UDIV     R12,R7,R0
   \   00000032   0xFB0C 0x7C10      MLS      R12,R12,R0,R7
   \   00000036   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000003A   0x46E1             MOV      R9,R12
    683              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
   \   0000003C   0xF05F 0x0C04      MOVS     R12,#+4
   \   00000040   0xFBBE 0xF0FC      UDIV     R0,LR,R12
   \   00000044   0xFB00 0xE01C      MLS      R0,R0,R12,LR
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    684          
    685              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x4581             CMP      R9,R0
   \   00000050   0xD102             BNE.N    ??Mem_Cmp_4
   \   00000052   0xF05F 0x0A01      MOVS     R10,#+1
   \   00000056   0xE001             B.N      ??Mem_Cmp_5
   \                     ??Mem_Cmp_4: (+1)
   \   00000058   0xF05F 0x0A00      MOVS     R10,#+0
    686          
    687              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Cmp_5: (+1)
   \   0000005C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000060   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000064   0xD136             BNE.N    ??Mem_Cmp_6
    688                                                                          /* ... optimize cmp for mem buf alignment.              */
    689                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
   \   00000066   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006A   0xD018             BEQ.N    ??Mem_Cmp_7
    690                      i = mem_align_mod_1;
   \   0000006C   0x46C8             MOV      R8,R9
    691                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    692                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    693                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
   \                     ??Mem_Cmp_8: (+1)
   \   0000006E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000072   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000076   0xD112             BNE.N    ??Mem_Cmp_7
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD010             BEQ.N    ??Mem_Cmp_7
   \   0000007C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000080   0xD00D             BEQ.N    ??Mem_Cmp_7
    694                          p1_mem_08--;
   \   00000082   0x1E7F             SUBS     R7,R7,#+1
    695                          p2_mem_08--;
   \   00000084   0xF1BE 0x0E01      SUBS     LR,LR,#+1
    696                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000088   0x7838             LDRB     R0,[R7, #+0]
   \   0000008A   0xF89E 0xC000      LDRB     R12,[LR, #+0]
   \   0000008E   0x4560             CMP      R0,R12
   \   00000090   0xD001             BEQ.N    ??Mem_Cmp_9
    697                               mem_cmp = DEF_NO;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x4683             MOV      R11,R0
    698                          }
    699                          size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_9: (+1)
   \   00000096   0x1E64             SUBS     R4,R4,#+1
    700                          i--;
   \   00000098   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000009C   0xE7E7             B.N      ??Mem_Cmp_8
    701                      }
    702                  }
    703          
    704                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
   \                     ??Mem_Cmp_7: (+1)
   \   0000009E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A2   0xF1BB 0x0F01      CMP      R11,#+1
   \   000000A6   0xD115             BNE.N    ??Mem_Cmp_6
    705                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
   \   000000A8   0x003D             MOVS     R5,R7
    706                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \   000000AA   0x4676             MOV      R6,LR
    707          
    708                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    709                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
   \                     ??Mem_Cmp_10: (+1)
   \   000000AC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B0   0xF1BB 0x0F01      CMP      R11,#+1
   \   000000B4   0xD10C             BNE.N    ??Mem_Cmp_11
   \   000000B6   0x2C04             CMP      R4,#+4
   \   000000B8   0xD30A             BCC.N    ??Mem_Cmp_11
    710                          p1_mem_align--;
   \   000000BA   0x1F2D             SUBS     R5,R5,#+4
    711                          p2_mem_align--;
   \   000000BC   0x1F36             SUBS     R6,R6,#+4
    712                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xF8D6 0xC000      LDR      R12,[R6, #+0]
   \   000000C4   0x4560             CMP      R0,R12
   \   000000C6   0xD001             BEQ.N    ??Mem_Cmp_12
    713                               mem_cmp = DEF_NO;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x4683             MOV      R11,R0
    714                          }
    715                          size_rem -= sizeof(CPU_ALIGN);
   \                     ??Mem_Cmp_12: (+1)
   \   000000CC   0x1F24             SUBS     R4,R4,#+4
   \   000000CE   0xE7ED             B.N      ??Mem_Cmp_10
    716                      }
    717          
    718                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
   \                     ??Mem_Cmp_11: (+1)
   \   000000D0   0x002F             MOVS     R7,R5
    719                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
   \   000000D2   0x46B6             MOV      LR,R6
    720                  }
    721              }
    722          
    723              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    724                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
   \                     ??Mem_Cmp_6: (+1)
   \   000000D4   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D8   0xF1BB 0x0F01      CMP      R11,#+1
   \   000000DC   0xD10D             BNE.N    ??Mem_Cmp_13
   \   000000DE   0x2C00             CMP      R4,#+0
   \   000000E0   0xD00B             BEQ.N    ??Mem_Cmp_13
    725                  p1_mem_08--;
   \   000000E2   0x1E7F             SUBS     R7,R7,#+1
    726                  p2_mem_08--;
   \   000000E4   0xF1BE 0x0E01      SUBS     LR,LR,#+1
    727                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   000000E8   0x7838             LDRB     R0,[R7, #+0]
   \   000000EA   0xF89E 0xC000      LDRB     R12,[LR, #+0]
   \   000000EE   0x4560             CMP      R0,R12
   \   000000F0   0xD001             BEQ.N    ??Mem_Cmp_14
    728                       mem_cmp = DEF_NO;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x4683             MOV      R11,R0
    729                  }
    730                  size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_14: (+1)
   \   000000F6   0x1E64             SUBS     R4,R4,#+1
   \   000000F8   0xE7EC             B.N      ??Mem_Cmp_6
    731              }
    732          
    733              return (mem_cmp);
   \                     ??Mem_Cmp_13: (+1)
   \   000000FA   0x4658             MOV      R0,R11
   \   000000FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??Mem_Cmp_1: (+1)
   \   000000FE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    734          }
    735          
    736          
    737          /*
    738          *********************************************************************************************************
    739          *                                           Mem_HeapAlloc()
    740          *
    741          * Description : Allocates a memory block from the heap memory segment.
    742          *
    743          * Argument(s) : size            Size      of memory block to allocate (in bytes).
    744          *
    745          *               align           Alignment of memory block to specific word boundary (in bytes).
    746          *
    747          *               p_bytes_reqd    Optional pointer to a variable to ... :
    748          *
    749          *                                   (a) Return the number of bytes required to successfully
    750          *                                           allocate the memory block, if any error(s);
    751          *                                   (b) Return 0, otherwise.
    752          *
    753          *               p_err           Pointer to variable that will receive the return error code from this function :
    754          *
    755          *                                   LIB_MEM_ERR_NONE                Operation was successful.
    756          *                                   LIB_MEM_ERR_HEAP_EMPTY          No more memory available on heap.
    757          *
    758          *                                   ---------------------RETURNED BY Mem_SegAllocInternal()---------------------
    759          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
    760          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
    761          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
    762          *
    763          * Return(s)   : Pointer to memory block, if NO error(s).
    764          *
    765          *               Pointer to NULL,         otherwise.
    766          *
    767          * Caller(s)   : Application.
    768          *
    769          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
    770          *                   validation or function handling in case of any error(s).
    771          *
    772          *               (2) This function is DEPRECATED and will be removed in a future version of this product.
    773          *                   Mem_SegAlloc(), Mem_SegAllocExt() or Mem_SegAllocHW() should be used instead.
    774          *********************************************************************************************************
    775          */
    776          
    777          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
    778          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    779                                CPU_SIZE_T   align,
    780                                CPU_SIZE_T  *p_bytes_reqd,
    781                                LIB_ERR     *p_err)
    782          {
   \                     Mem_HeapAlloc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    783              void  *p_mem;
    784          
    785          
    786              p_mem = Mem_SegAllocInternal(DEF_NULL,
    787                                          &Mem_SegHeap,
    788                                           size,
    789                                           align,
    790                                           LIB_MEM_CFG_HEAP_PADDING_ALIGN,
    791                                           p_bytes_reqd,
    792                                           p_err);
   \   0000000E   0x9702             STR      R7,[SP, #+8]
   \   00000010   0x9601             STR      R6,[SP, #+4]
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x002B             MOVS     R3,R5
   \   00000018   0x0022             MOVS     R2,R4
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000024   0x4680             MOV      R8,R0
    793              if (*p_err == LIB_MEM_ERR_SEG_OVF) {
   \   00000026   0xF9B7 0x0000      LDRSH    R0,[R7, #+0]
   \   0000002A   0xF242 0x71D9      MOVW     R1,#+10201
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD102             BNE.N    ??Mem_HeapAlloc_0
    794                 *p_err = LIB_MEM_ERR_HEAP_OVF;
   \   00000032   0xF242 0x70E3      MOVW     R0,#+10211
   \   00000036   0x8038             STRH     R0,[R7, #+0]
    795              }
    796          
    797              return (p_mem);
   \                     ??Mem_HeapAlloc_0: (+1)
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0xB004             ADD      SP,SP,#+16
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    798          }
    799          #endif
    800          
    801          
    802          /*
    803          *********************************************************************************************************
    804          *                                        Mem_HeapGetSizeRem()
    805          *
    806          * Description : Gets remaining heap memory size available to allocate.
    807          *
    808          * Argument(s) : align       Desired word boundary alignment (in bytes) to return remaining memory size from.
    809          *
    810          *               p_err       Pointer to variable that will receive the return error code from this function
    811          *
    812          *                               LIB_MEM_ERR_NONE                Operation was successful.
    813          *
    814          *                               --------------------RETURNED BY Mem_SegRemSizeGet()--------------------
    815          *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
    816          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    817          *
    818          * Return(s)   : Remaining heap memory size (in bytes), if NO error(s).
    819          *
    820          *               0,                                     otherwise.
    821          *
    822          * Caller(s)   : Application.
    823          *
    824          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
    825          *                   Mem_SegRemSizeGet() should be used instead.
    826          *********************************************************************************************************
    827          */
    828          
    829          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
    830          CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
    831                                          LIB_ERR     *p_err)
    832          {
   \                     Mem_HeapGetSizeRem: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    833              CPU_SIZE_T  rem_size;
    834          
    835          
    836              rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
    837                                            align,
    838                                            DEF_NULL,
    839                                            p_err);
   \   00000006   0x002B             MOVS     R3,R5
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x0021             MOVS     R1,R4
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000010   0x.... 0x....      BL       Mem_SegRemSizeGet
   \   00000014   0x0006             MOVS     R6,R0
    840              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000016   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   0000001A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD001             BEQ.N    ??Mem_HeapGetSizeRem_0
    841                  return (0u);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE000             B.N      ??Mem_HeapGetSizeRem_1
    842              }
    843          
    844              return (rem_size);
   \                     ??Mem_HeapGetSizeRem_0: (+1)
   \   00000026   0x0030             MOVS     R0,R6
   \                     ??Mem_HeapGetSizeRem_1: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    845          }
    846          #endif
    847          
    848          
    849          /*
    850          *********************************************************************************************************
    851          *                                            Mem_SegCreate()
    852          *
    853          * Description : Creates a new memory segment to be used for runtime memory allocation.
    854          *
    855          * Argument(s) : p_name          Pointer to segment name.
    856          *
    857          *               p_seg           Pointer to segment data. Must be allocated by caller.
    858          *
    859          *               seg_base_addr   Address of segment's first byte.
    860          *
    861          *               size            Total size of segment, in bytes.
    862          *
    863          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
    864          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
    865          *                               means no padding.
    866          *
    867          *               p_err           Pointer to variable that will receive the return error code from this function :
    868          *
    869          *                                   LIB_MEM_ERR_NONE                    Operation was successful.
    870          *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size specified.
    871          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid padding alignment.
    872          *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
    873          *
    874          *                                   -------------------RETURNED BY Mem_SegOverlapChkCritical()-------------------
    875          *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
    876          *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
    877          *
    878          * Return(s)   : None.
    879          *
    880          * Caller(s)   : Application.
    881          *
    882          * Note(s)     : (1) New segments are checked for overlap with existing segments. A critical section needs
    883          *                   to be maintained during the whole list search and add procedure to prevent a reentrant
    884          *                   call from creating another segment overlapping with the one being added.
    885          *********************************************************************************************************
    886          */
    887          

   \                                 In section .text, align 2, keep-with-next
    888          void  Mem_SegCreate (const  CPU_CHAR    *p_name,
    889                                      MEM_SEG     *p_seg,
    890                                      CPU_ADDR     seg_base_addr,
    891                                      CPU_SIZE_T   size,
    892                                      CPU_SIZE_T   padding_align,
    893                                      LIB_ERR     *p_err)
    894          {
   \                     Mem_SegCreate: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000012   0xF8DD 0x902C      LDR      R9,[SP, #+44]
    895              CPU_SR_ALLOC();
   \   00000016   0xF05F 0x0A00      MOVS     R10,#+0
    896          
    897          
    898          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    899              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
    900                  CPU_SW_EXCEPTION(;);
    901              }
    902          
    903              if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
    904                 *p_err = LIB_MEM_ERR_NULL_PTR;
    905                  return;
    906              }
    907          
    908              if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
    909                 *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
    910                  return;
    911              }
    912                                                                          /* Chk for addr space ovf.                              */
    913              if (seg_base_addr + (size - 1u) < seg_base_addr) {
    914                 *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
    915                  return;
    916              }
    917          
    918              if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
    919                  (MATH_IS_PWR2(padding_align) != DEF_YES)) {
    920                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
    921                  return;
    922              }
    923          #endif
    924          
    925              CPU_CRITICAL_ENTER();
   \   0000001A   0x.... 0x....      BL       CPU_SR_Save
   \   0000001E   0x4682             MOV      R10,R0
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStart
    926          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    927              (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
    928                                              size,
    929                                              p_err);
    930              if (*p_err != LIB_MEM_ERR_NONE) {
    931                  CPU_CRITICAL_EXIT();
    932                  return;
    933              }
    934          #endif
    935          
    936              Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
    937                                    p_seg,
    938                                    seg_base_addr,
    939                                    padding_align,
    940                                    size);
   \   00000024   0x9700             STR      R7,[SP, #+0]
   \   00000026   0x4643             MOV      R3,R8
   \   00000028   0x0032             MOVS     R2,R6
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       Mem_SegCreateCritical
    941              CPU_CRITICAL_EXIT();
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000036   0x4650             MOV      R0,R10
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
    942          
    943             *p_err = LIB_MEM_ERR_NONE;
   \   0000003C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000040   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    944          }
   \   00000044   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    945          
    946          
    947          /*
    948          *********************************************************************************************************
    949          *                                            Mem_SegClr()
    950          *
    951          * Description : Clears a memory segment.
    952          *
    953          * Argument(s) : p_seg           Pointer to segment data. Must be allocated by caller.
    954          *
    955          *               p_err           Pointer to variable that will receive the return error code from this function :
    956          *
    957          *                               LIB_MEM_ERR_NONE                Operation was successful.
    958          *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
    959          *
    960          * Return(s)   : None.
    961          *
    962          * Caller(s)   : Application.
    963          *
    964          * Note(s)     : (1) This function must be used with extreme caution. It must only be called on memory
    965          *                   segments that are no longer used.
    966          *
    967          *               (2) This function is disabled when debug mode is enabled to avoid heap memory leaks.
    968          *********************************************************************************************************
    969          */
    970          
    971          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)

   \                                 In section .text, align 2, keep-with-next
    972          void  Mem_SegClr (MEM_SEG  *p_seg,
    973                            LIB_ERR  *p_err)
    974          {
   \                     Mem_SegClr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    975              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    976          
    977          
    978          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    979              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
    980                  CPU_SW_EXCEPTION(;);
    981              }
    982          
    983              if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
    984                 *p_err = LIB_MEM_ERR_NULL_PTR;
    985                  return;
    986              }
    987          #endif
    988          
    989              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    990              p_seg->AddrNext = p_seg->AddrBase;
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    991              CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
    992          
    993             *p_err = LIB_MEM_ERR_NONE;
   \   00000020   0xF242 0x7010      MOVW     R0,#+10000
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    994          }
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    995          #endif
    996          
    997          
    998          /*
    999          *********************************************************************************************************
   1000          *                                         Mem_SegRemSizeGet()
   1001          *
   1002          * Description : Gets free space of memory segment.
   1003          *
   1004          * Argument(s) : p_seg       Pointer to segment data.
   1005          *
   1006          *               align       Alignment in bytes to assume for calculation of free space.
   1007          *
   1008          *               p_seg_info  Pointer to structure that will receive further segment info data (used size,
   1009          *                           total size, base address and next allocation address).
   1010          *
   1011          *               p_err       Pointer to variable that will receive the return error code from this function :
   1012          *
   1013          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1014          *                           LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
   1015          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
   1016          *
   1017          * Return(s)   : Memory segment remaining size in bytes,     if successful.
   1018          *               0,                                          otherwise or if memory segment empty.
   1019          *
   1020          * Caller(s)   : Application,
   1021          *               Mem_HeapGetSizeRem(),
   1022          *               Mem_OutputUsage().
   1023          *
   1024          * Note(s)     : None.
   1025          *********************************************************************************************************
   1026          */
   1027          

   \                                 In section .text, align 2, keep-with-next
   1028          CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
   1029                                         CPU_SIZE_T     align,
   1030                                         MEM_SEG_INFO  *p_seg_info,
   1031                                         LIB_ERR       *p_err)
   1032          {
   \                     Mem_SegRemSizeGet: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1033              CPU_SIZE_T  rem_size;
   1034              CPU_SIZE_T  total_size;
   1035              CPU_SIZE_T  used_size;
   1036              CPU_ADDR    next_addr_align;
   1037              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   1038          
   1039          
   1040          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1041              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   1042                  CPU_SW_EXCEPTION(0);
   1043              }
   1044          
   1045              if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
   1046                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   1047                  return (0u);
   1048              }
   1049          #endif
   1050          
   1051              if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD102             BNE.N    ??Mem_SegRemSizeGet_0
   1052          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1053                  p_seg = &Mem_SegHeap;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000018   0x0004             MOVS     R4,R0
   1054          #else
   1055                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1056                  return (0u);
   1057          #endif
   1058              }
   1059          
   1060              CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
   \                     ??Mem_SegRemSizeGet_0: (+1)
   \   0000001A   0x.... 0x....      BL       CPU_SR_Save
   \   0000001E   0x4682             MOV      R10,R0
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStart
   1061              next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x1E69             SUBS     R1,R5,#+1
   \   00000028   0x4208             TST      R0,R1
   \   0000002A   0xD101             BNE.N    ??Mem_SegRemSizeGet_1
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE000             B.N      ??Mem_SegRemSizeGet_2
   \                     ??Mem_SegRemSizeGet_1: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \                     ??Mem_SegRemSizeGet_2: (+1)
   \   00000032   0x68A1             LDR      R1,[R4, #+8]
   \   00000034   0x1E6A             SUBS     R2,R5,#+1
   \   00000036   0x4391             BICS     R1,R1,R2
   \   00000038   0xEB10 0x0B01      ADDS     R11,R0,R1
   1062              CPU_CRITICAL_EXIT();
   \   0000003C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000040   0x4650             MOV      R0,R10
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
   1063          
   1064              total_size = (p_seg->AddrEnd  - p_seg->AddrBase) + 1u;
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x6821             LDR      R1,[R4, #+0]
   \   0000004A   0x1A40             SUBS     R0,R0,R1
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x4681             MOV      R9,R0
   1065              used_size  =  p_seg->AddrNext - p_seg->AddrBase;
   \   00000050   0x68A0             LDR      R0,[R4, #+8]
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x1A40             SUBS     R0,R0,R1
   \   00000056   0x9000             STR      R0,[SP, #+0]
   1066          
   1067              if (next_addr_align > p_seg->AddrEnd){
   \   00000058   0x6860             LDR      R0,[R4, #+4]
   \   0000005A   0x4558             CMP      R0,R11
   \   0000005C   0xD204             BCS.N    ??Mem_SegRemSizeGet_3
   1068                  next_addr_align = 0u;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x4683             MOV      R11,R0
   1069                  rem_size        = 0u;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x4680             MOV      R8,R0
   \   00000066   0xE004             B.N      ??Mem_SegRemSizeGet_4
   1070              } else {
   1071                  rem_size        = total_size - (next_addr_align - p_seg->AddrBase);
   \                     ??Mem_SegRemSizeGet_3: (+1)
   \   00000068   0xEBB9 0x000B      SUBS     R0,R9,R11
   \   0000006C   0x6821             LDR      R1,[R4, #+0]
   \   0000006E   0x1808             ADDS     R0,R1,R0
   \   00000070   0x4680             MOV      R8,R0
   1072              }
   1073          
   1074              if (p_seg_info != DEF_NULL) {
   \                     ??Mem_SegRemSizeGet_4: (+1)
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD007             BEQ.N    ??Mem_SegRemSizeGet_5
   1075                  p_seg_info->TotalSize     = total_size;
   \   00000076   0xF8C6 0x9004      STR      R9,[R6, #+4]
   1076                  p_seg_info->UsedSize      = used_size;
   \   0000007A   0x9800             LDR      R0,[SP, #+0]
   \   0000007C   0x6030             STR      R0,[R6, #+0]
   1077                  p_seg_info->AddrBase      = p_seg->AddrBase;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x60B0             STR      R0,[R6, #+8]
   1078                  p_seg_info->AddrNextAlloc = next_addr_align;
   \   00000082   0xF8C6 0xB00C      STR      R11,[R6, #+12]
   1079              }
   1080          
   1081             *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_SegRemSizeGet_5: (+1)
   \   00000086   0xF242 0x7010      MOVW     R0,#+10000
   \   0000008A   0x8038             STRH     R0,[R7, #+0]
   1082          
   1083              return (rem_size);
   \   0000008C   0x4640             MOV      R0,R8
   \   0000008E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1084          }
   1085          
   1086          
   1087          /*
   1088          *********************************************************************************************************
   1089          *                                            Mem_SegAlloc()
   1090          *
   1091          * Description : Allocates memory from specified segment. Returned memory block will be aligned on a CPU
   1092          *               word boundary.
   1093          *
   1094          * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1095          *
   1096          *               p_seg   Pointer to segment from which to allocate memory. Will be allocated from
   1097          *                       general-purpose heap if null.
   1098          *
   1099          *               size    Size of memory block to allocate, in bytes.
   1100          *
   1101          *               p_err   Pointer to variable that will receive the return error code from this function :
   1102          *
   1103          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1104          *
   1105          *                           ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1106          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1107          *                           LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1108          *                           LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1109          *                           LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1110          *
   1111          * Return(s)   : Pointer to allocated memory block, if successful.
   1112          *
   1113          *               DEF_NULL, otherwise.
   1114          *
   1115          * Caller(s)   : Application.
   1116          *
   1117          * Note(s)     : (1) The memory block returned  by this function will be aligned on a word boundary. In
   1118          *                   order to specify a specific alignment value, use either Mem_SegAllocExt() or
   1119          *                   Mem_SegAllocHW().
   1120          *********************************************************************************************************
   1121          */
   1122          

   \                                 In section .text, align 2, keep-with-next
   1123          void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
   1124                                      MEM_SEG     *p_seg,
   1125                                      CPU_SIZE_T   size,
   1126                                      LIB_ERR     *p_err)
   1127          {
   \                     Mem_SegAlloc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   1128              void  *p_blk;
   1129          
   1130          
   1131              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD102             BNE.N    ??Mem_SegAlloc_0
   1132          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1133                  p_seg = &Mem_SegHeap;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000016   0x0005             MOVS     R5,R0
   1134          #else
   1135                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1136                  return (DEF_NULL);
   1137          #endif
   1138              }
   1139          
   1140              p_blk = Mem_SegAllocInternal(p_name,
   1141                                           p_seg,
   1142                                           size,
   1143                                           sizeof(CPU_ALIGN),
   1144                                           LIB_MEM_PADDING_ALIGN_NONE,
   1145                                           DEF_NULL,
   1146                                           p_err);
   \                     ??Mem_SegAlloc_0: (+1)
   \   00000018   0x9702             STR      R7,[SP, #+8]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0x2304             MOVS     R3,#+4
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       Mem_SegAllocInternal
   \   0000002E   0x4680             MOV      R8,R0
   1147          
   1148              return (p_blk);
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0xB004             ADD      SP,SP,#+16
   \   00000034   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1149          }
   1150          
   1151          
   1152          /*
   1153          *********************************************************************************************************
   1154          *                                           Mem_SegAllocExt()
   1155          *
   1156          * Description : Allocates memory from specified memory segment.
   1157          *
   1158          * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1159          *
   1160          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1161          *                               general-purpose heap if null.
   1162          *
   1163          *               size            Size of memory block to allocate, in bytes.
   1164          *
   1165          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   1166          *
   1167          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   1168          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   1169          *
   1170          *               p_err           Pointer to variable that will receive the return error code from this function :
   1171          *
   1172          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1173          *
   1174          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1175          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1176          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1177          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1178          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1179          *
   1180          * Return(s)   : Pointer to allocated memory block, if successful.
   1181          *
   1182          *               DEF_NULL, otherwise.
   1183          *
   1184          * Caller(s)   : Application.
   1185          *
   1186          * Note(s)     : none.
   1187          *********************************************************************************************************
   1188          */
   1189          

   \                                 In section .text, align 2, keep-with-next
   1190          void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
   1191                                         MEM_SEG     *p_seg,
   1192                                         CPU_SIZE_T   size,
   1193                                         CPU_SIZE_T   align,
   1194                                         CPU_SIZE_T  *p_bytes_reqd,
   1195                                         LIB_ERR     *p_err)
   1196          {
   \                     Mem_SegAllocExt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000012   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   1197              void  *p_blk;
   1198          
   1199          
   1200              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD102             BNE.N    ??Mem_SegAllocExt_0
   1201          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1202                  p_seg = &Mem_SegHeap;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000001E   0x0005             MOVS     R5,R0
   1203          #else
   1204                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1205                  return (DEF_NULL);
   1206          #endif
   1207              }
   1208          
   1209              p_blk = Mem_SegAllocInternal(p_name,
   1210                                           p_seg,
   1211                                           size,
   1212                                           align,
   1213                                           LIB_MEM_PADDING_ALIGN_NONE,
   1214                                           p_bytes_reqd,
   1215                                           p_err);
   \                     ??Mem_SegAllocExt_0: (+1)
   \   00000020   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000024   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x003B             MOVS     R3,R7
   \   0000002E   0x0032             MOVS     R2,R6
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000038   0x4682             MOV      R10,R0
   1216          
   1217              return (p_blk);
   \   0000003A   0x4650             MOV      R0,R10
   \   0000003C   0xB004             ADD      SP,SP,#+16
   \   0000003E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1218          }
   1219          
   1220          
   1221          /*
   1222          *********************************************************************************************************
   1223          *                                          Mem_SegAllocHW()
   1224          *
   1225          * Description : Allocates memory from specified segment. The returned buffer will be padded in function
   1226          *               of memory segment's properties.
   1227          *
   1228          * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1229          *
   1230          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1231          *                               general-purpose heap if null.
   1232          *
   1233          *               size            Size of memory block to allocate, in bytes.
   1234          *
   1235          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   1236          *
   1237          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   1238          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   1239          *
   1240          *               p_err           Pointer to variable that will receive the return error code from this function :
   1241          *
   1242          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1243          *
   1244          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1245          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1246          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1247          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1248          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1249          *
   1250          * Return(s)   : Pointer to allocated memory block, if successful.
   1251          *
   1252          *               DEF_NULL, otherwise.
   1253          *
   1254          * Caller(s)   : Application.
   1255          *
   1256          * Note(s)     : none.
   1257          *********************************************************************************************************
   1258          */
   1259          

   \                                 In section .text, align 2, keep-with-next
   1260          void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
   1261                                        MEM_SEG     *p_seg,
   1262                                        CPU_SIZE_T   size,
   1263                                        CPU_SIZE_T   align,
   1264                                        CPU_SIZE_T  *p_bytes_reqd,
   1265                                        LIB_ERR     *p_err)
   1266          {
   \                     Mem_SegAllocHW: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000012   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   1267              void  *p_blk;
   1268          
   1269          
   1270              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD102             BNE.N    ??Mem_SegAllocHW_0
   1271          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1272                  p_seg = &Mem_SegHeap;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000001E   0x0005             MOVS     R5,R0
   1273          #else
   1274                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1275                  return (DEF_NULL);
   1276          #endif
   1277              }
   1278          
   1279              p_blk = Mem_SegAllocInternal(p_name,
   1280                                           p_seg,
   1281                                           size,
   1282                                           align,
   1283                                           p_seg->PaddingAlign,
   1284                                           p_bytes_reqd,
   1285                                           p_err);
   \                     ??Mem_SegAllocHW_0: (+1)
   \   00000020   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000024   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000028   0x6928             LDR      R0,[R5, #+16]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x003B             MOVS     R3,R7
   \   0000002E   0x0032             MOVS     R2,R6
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000038   0x4682             MOV      R10,R0
   1286          
   1287              return (p_blk);
   \   0000003A   0x4650             MOV      R0,R10
   \   0000003C   0xB004             ADD      SP,SP,#+16
   \   0000003E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1288          }
   1289          
   1290          
   1291          /*
   1292          *********************************************************************************************************
   1293          *                                          Mem_PoolCreate()
   1294          *
   1295          * Description : (1) Creates a memory pool :
   1296          *
   1297          *                   (a) Create    memory pool from heap or dedicated memory
   1298          *                   (b) Allocate  memory pool memory blocks
   1299          *                   (c) Configure memory pool
   1300          *
   1301          *
   1302          * Argument(s) : p_pool          Pointer to a memory pool structure to create (see Note #1).
   1303          *
   1304          *               p_mem_base      Memory pool segment base address :
   1305          *
   1306          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
   1307          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
   1308          *                                                                   specified by its base address.
   1309          *
   1310          *               mem_size        Size      of memory pool segment          (in bytes).
   1311          *
   1312          *               blk_nbr         Number    of memory pool blocks to create.
   1313          *
   1314          *               blk_size        Size      of memory pool blocks to create (in bytes).
   1315          *
   1316          *               blk_align       Alignment of memory pool blocks to specific word boundary (in bytes).
   1317          *
   1318          *               p_bytes_reqd    Optional pointer to a variable to ... :
   1319          *
   1320          *                                   (a) Return the number of bytes required to successfully
   1321          *                                               allocate the memory pool, if any error(s);
   1322          *                                   (b) Return 0, otherwise.
   1323          *
   1324          *               p_err           Pointer to variable that will receive the return error code from this function :
   1325          *
   1326          *                                   LIB_MEM_ERR_NONE                    Operation was successful.
   1327          *                                   LIB_MEM_ERR_NULL_PTR                Pointer to memory pool is null.
   1328          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid block alignment requested.
   1329          *                                   LIB_MEM_ERR_INVALID_BLK_NBR         Invalid number of blocks specified.
   1330          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid block size specified.
   1331          *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size.
   1332          *                                   LIB_MEM_ERR_HEAP_EMPTY              No more memory available on heap.
   1333          *
   1334          *                                   ---------------RETURNED BY Mem_SegOverlapChkCritical()----------------
   1335          *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
   1336          *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
   1337          *
   1338          *                                   -----------------RETURNED BY Mem_SegAllocExtCritical()-----------------
   1339          *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1340          *
   1341          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1342          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
   1343          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
   1344          *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
   1345          *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1346          *
   1347          *                                   -----------------------RETURNED BY Mem_PoolClr()-----------------------
   1348          *                                   LIB_MEM_ERR_NULL_PTR                Argument 'p_pool' passed a NULL pointer.
   1349          *
   1350          * Return(s)   : none.
   1351          *
   1352          * Caller(s)   : Application.
   1353          *
   1354          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1355          *                   Mem_DynPoolCreate() or Mem_DynPoolCreateHW() should be used instead.
   1356          *********************************************************************************************************
   1357          */
   1358          
   1359          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1360          void  Mem_PoolCreate (MEM_POOL          *p_pool,
   1361                                void              *p_mem_base,
   1362                                CPU_SIZE_T         mem_size,
   1363                                MEM_POOL_BLK_QTY   blk_nbr,
   1364                                CPU_SIZE_T         blk_size,
   1365                                CPU_SIZE_T         blk_align,
   1366                                CPU_SIZE_T        *p_bytes_reqd,
   1367                                LIB_ERR           *p_err)
   1368          {
   \                     Mem_PoolCreate: (+1)
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x001D             MOVS     R5,R3
   \   0000000A   0x9E13             LDR      R6,[SP, #+76]
   \   0000000C   0x9F15             LDR      R7,[SP, #+84]
   1369              MEM_SEG           *p_seg;
   1370              void              *p_pool_mem;
   1371              CPU_SIZE_T         pool_size;
   1372              CPU_SIZE_T         blk_size_align;
   1373              CPU_ADDR           pool_addr_end;
   1374              MEM_POOL_BLK_QTY   blk_ix;
   1375              CPU_INT08U        *p_blk;
   1376              CPU_SR_ALLOC();
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
   1377          
   1378          
   1379          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
   1380              if (p_err == DEF_NULL) {
   1381                  CPU_SW_EXCEPTION(;);
   1382              }
   1383          
   1384                                                                          /* ------------- VALIDATE MEM POOL CREATE ------------- */
   1385              if (p_pool == DEF_NULL) {
   1386                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1387                  return;
   1388              }
   1389          
   1390              if (p_mem_base != DEF_NULL) {
   1391                  if (mem_size < 1u) {
   1392                     *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
   1393                      return;
   1394                  }
   1395              }
   1396          
   1397              if (blk_nbr < 1u) {
   1398                 *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
   1399                  return;
   1400              }
   1401          
   1402              if (blk_size < 1u) {
   1403                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1404                  return;
   1405              }
   1406          
   1407              if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
   1408                 *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   1409                  return;
   1410              }
   1411          #endif
   1412          
   1413              Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
   \   00000012   0x0039             MOVS     R1,R7
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       Mem_PoolClr
   1414              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000001A   0xF9B7 0x0000      LDRSH    R0,[R7, #+0]
   \   0000001E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xF040 0x8097      BNE.W    ??Mem_PoolCreate_0
   1415                   return;
   1416              }
   1417          
   1418                                                                          /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
   1419              if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
   \                     ??Mem_PoolCreate_1: (+1)
   \   00000028   0x9807             LDR      R0,[SP, #+28]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD103             BNE.N    ??Mem_PoolCreate_2
   1420                  p_seg = &Mem_SegHeap;
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000032   0x9003             STR      R0,[SP, #+12]
   \   00000034   0xE03E             B.N      ??Mem_PoolCreate_3
   1421              } else {                                                    /* Use other seg.                                       */
   1422                  CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolCreate_2: (+1)
   \   00000036   0x.... 0x....      BL       CPU_SR_Save
   \   0000003A   0x4682             MOV      R10,R0
   \   0000003C   0x.... 0x....      BL       CPU_IntDisMeasStart
   1423                  p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
   1424                                                              mem_size,
   1425                                                              p_err);
   \   00000040   0x003A             MOVS     R2,R7
   \   00000042   0x9908             LDR      R1,[SP, #+32]
   \   00000044   0x9807             LDR      R0,[SP, #+28]
   \   00000046   0x.... 0x....      BL       Mem_SegOverlapChkCritical
   \   0000004A   0x9003             STR      R0,[SP, #+12]
   1426                  switch (*p_err) {
   \   0000004C   0xF9B7 0x0000      LDRSH    R0,[R7, #+0]
   \   00000050   0xF242 0x7110      MOVW     R1,#+10000
   \   00000054   0x1A40             SUBS     R0,R0,R1
   \   00000056   0xD002             BEQ.N    ??Mem_PoolCreate_4
   \   00000058   0x3870             SUBS     R0,R0,#+112
   \   0000005A   0xD120             BNE.N    ??Mem_PoolCreate_5
   1427                      case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
   1428                           break;
   \                     ??Mem_PoolCreate_6: (+1)
   \   0000005C   0xE025             B.N      ??Mem_PoolCreate_7
   1429          
   1430                      case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
   1431                           p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
   1432                                                                       sizeof(MEM_SEG),
   1433                                                                       sizeof(CPU_ALIGN),
   1434                                                                       LIB_MEM_PADDING_ALIGN_NONE,
   1435                                                                       p_bytes_reqd,
   1436                                                                       p_err);
   \                     ??Mem_PoolCreate_4: (+1)
   \   0000005E   0x9701             STR      R7,[SP, #+4]
   \   00000060   0x9814             LDR      R0,[SP, #+80]
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x2301             MOVS     R3,#+1
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0x2114             MOVS     R1,#+20
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000006E   0x.... 0x....      BL       Mem_SegAllocExtCritical
   \   00000072   0x9003             STR      R0,[SP, #+12]
   1437                           if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000074   0xF9B7 0x0000      LDRSH    R0,[R7, #+0]
   \   00000078   0xF242 0x7110      MOVW     R1,#+10000
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD005             BEQ.N    ??Mem_PoolCreate_8
   1438                               CPU_CRITICAL_EXIT();
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4650             MOV      R0,R10
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
   1439                               return;
   \   0000008A   0xE064             B.N      ??Mem_PoolCreate_0
   1440                           }
   1441          
   1442          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
   1443                           Mem_SegAllocTrackCritical("Unknown segment data",
   1444                                                     &Mem_SegHeap,
   1445                                                      sizeof(MEM_SEG),
   1446                                                      p_err);
   1447                           if (*p_err != LIB_MEM_ERR_NONE) {
   1448                               CPU_CRITICAL_EXIT();
   1449                               return;
   1450                           }
   1451          #endif
   1452          
   1453                           Mem_SegCreateCritical(          DEF_NULL,
   1454                                                           p_seg,
   1455                                                 (CPU_ADDR)p_mem_base,
   1456                                                           LIB_MEM_PADDING_ALIGN_NONE,
   1457                                                           mem_size);
   \                     ??Mem_PoolCreate_8: (+1)
   \   0000008C   0x9808             LDR      R0,[SP, #+32]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x2301             MOVS     R3,#+1
   \   00000092   0x9A07             LDR      R2,[SP, #+28]
   \   00000094   0x9903             LDR      R1,[SP, #+12]
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x.... 0x....      BL       Mem_SegCreateCritical
   1458                           break;
   \   0000009C   0xE005             B.N      ??Mem_PoolCreate_7
   1459          
   1460          
   1461                      case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
   1462                      default:
   1463                           CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolCreate_5: (+1)
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0x4650             MOV      R0,R10
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
   1464                           return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
   \   000000A8   0xE055             B.N      ??Mem_PoolCreate_0
   1465                  }
   1466          
   1467                  CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolCreate_7: (+1)
   \   000000AA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AE   0x4650             MOV      R0,R10
   \   000000B0   0x.... 0x....      BL       CPU_SR_Restore
   1468              }
   1469          
   1470          
   1471                                                                          /* ---------------- ALLOC MEM FOR POOL ---------------- */
   1472                                                                          /* Calc blk size with align.                            */
   1473              blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
   \                     ??Mem_PoolCreate_3: (+1)
   \   000000B4   0x9812             LDR      R0,[SP, #+72]
   \   000000B6   0x1E71             SUBS     R1,R6,#+1
   \   000000B8   0x4208             TST      R0,R1
   \   000000BA   0xD101             BNE.N    ??Mem_PoolCreate_9
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE000             B.N      ??Mem_PoolCreate_10
   \                     ??Mem_PoolCreate_9: (+1)
   \   000000C0   0x0030             MOVS     R0,R6
   \                     ??Mem_PoolCreate_10: (+1)
   \   000000C2   0x9912             LDR      R1,[SP, #+72]
   \   000000C4   0x1E72             SUBS     R2,R6,#+1
   \   000000C6   0x4391             BICS     R1,R1,R2
   \   000000C8   0xEB10 0x0B01      ADDS     R11,R0,R1
   1474              pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
   \   000000CC   0xFB05 0xF00B      MUL      R0,R5,R11
   \   000000D0   0x9005             STR      R0,[SP, #+20]
   1475          
   1476                                                                          /* Alloc mem for pool.                                  */
   1477              p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
   1478                                                         p_seg,
   1479                                                         pool_size,
   1480                                                         blk_align,
   1481                                                         LIB_MEM_PADDING_ALIGN_NONE,
   1482                                                         p_bytes_reqd,
   1483                                                         p_err);
   \   000000D2   0x9702             STR      R7,[SP, #+8]
   \   000000D4   0x9814             LDR      R0,[SP, #+80]
   \   000000D6   0x9001             STR      R0,[SP, #+4]
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0x9000             STR      R0,[SP, #+0]
   \   000000DC   0x0033             MOVS     R3,R6
   \   000000DE   0x9A05             LDR      R2,[SP, #+20]
   \   000000E0   0x9903             LDR      R1,[SP, #+12]
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   000000E6   0x.... 0x....      BL       Mem_SegAllocInternal
   \   000000EA   0x9004             STR      R0,[SP, #+16]
   1484              if (*p_err != LIB_MEM_ERR_NONE) {
   \   000000EC   0xF9B7 0x0000      LDRSH    R0,[R7, #+0]
   \   000000F0   0xF242 0x7110      MOVW     R1,#+10000
   \   000000F4   0x4288             CMP      R0,R1
   \   000000F6   0xD12E             BNE.N    ??Mem_PoolCreate_0
   1485                  return;
   1486              }
   1487          
   1488                                                                          /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
   1489              p_pool->BlkFreeTbl = (void **)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
   1490                                                                 &Mem_SegHeap,
   1491                                                                  blk_nbr * sizeof(void *),
   1492                                                                  sizeof(CPU_ALIGN),
   1493                                                                  LIB_MEM_PADDING_ALIGN_NONE,
   1494                                                                  p_bytes_reqd,
   1495                                                                  p_err);
   \                     ??Mem_PoolCreate_11: (+1)
   \   000000F8   0x9702             STR      R7,[SP, #+8]
   \   000000FA   0x9814             LDR      R0,[SP, #+80]
   \   000000FC   0x9001             STR      R0,[SP, #+4]
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x9000             STR      R0,[SP, #+0]
   \   00000102   0x2304             MOVS     R3,#+4
   \   00000104   0x00AA             LSLS     R2,R5,#+2
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   0000010E   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000112   0x6120             STR      R0,[R4, #+16]
   1496              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000114   0xF9B7 0x0000      LDRSH    R0,[R7, #+0]
   \   00000118   0xF242 0x7110      MOVW     R1,#+10000
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD11A             BNE.N    ??Mem_PoolCreate_0
   1497                  return;
   1498              }
   1499          
   1500                                                                          /* ------------------ INIT BLK LIST ------------------- */
   1501              p_blk = (CPU_INT08U *)p_pool_mem;
   \                     ??Mem_PoolCreate_12: (+1)
   \   00000120   0x9804             LDR      R0,[SP, #+16]
   \   00000122   0x4681             MOV      R9,R0
   1502              for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x4680             MOV      R8,R0
   \                     ??Mem_PoolCreate_13: (+1)
   \   00000128   0x45A8             CMP      R8,R5
   \   0000012A   0xD207             BCS.N    ??Mem_PoolCreate_14
   1503                  p_pool->BlkFreeTbl[blk_ix]  = p_blk;
   \   0000012C   0x6920             LDR      R0,[R4, #+16]
   \   0000012E   0xF840 0x9028      STR      R9,[R0, R8, LSL #+2]
   1504                  p_blk                      += blk_size_align;
   \   00000132   0xEB1B 0x0909      ADDS     R9,R11,R9
   1505              }
   \   00000136   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000013A   0xE7F5             B.N      ??Mem_PoolCreate_13
   1506          
   1507          
   1508                                                                          /* ------------------ INIT POOL DATA ------------------ */
   1509              pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
   \                     ??Mem_PoolCreate_14: (+1)
   \   0000013C   0x9804             LDR      R0,[SP, #+16]
   \   0000013E   0x9905             LDR      R1,[SP, #+20]
   \   00000140   0x1808             ADDS     R0,R1,R0
   \   00000142   0x1E40             SUBS     R0,R0,#+1
   \   00000144   0x9006             STR      R0,[SP, #+24]
   1510              p_pool->PoolAddrStart =  p_pool_mem;
   \   00000146   0x9804             LDR      R0,[SP, #+16]
   \   00000148   0x6020             STR      R0,[R4, #+0]
   1511              p_pool->PoolAddrEnd   = (void *)pool_addr_end;
   \   0000014A   0x9806             LDR      R0,[SP, #+24]
   \   0000014C   0x6060             STR      R0,[R4, #+4]
   1512              p_pool->BlkNbr        =  blk_nbr;
   \   0000014E   0x60A5             STR      R5,[R4, #+8]
   1513              p_pool->BlkSize       =  blk_size_align;
   \   00000150   0xF8C4 0xB00C      STR      R11,[R4, #+12]
   1514              p_pool->BlkFreeTblIx  =  blk_nbr;
   \   00000154   0x6165             STR      R5,[R4, #+20]
   1515          }
   \                     ??Mem_PoolCreate_0: (+1)
   \   00000156   0xB009             ADD      SP,SP,#+36
   \   00000158   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1516          #endif
   1517          
   1518          
   1519          /*
   1520          *********************************************************************************************************
   1521          *                                            Mem_PoolClr()
   1522          *
   1523          * Description : Clears a memory pool (see Note #1).
   1524          *
   1525          * Argument(s) : p_pool   Pointer to a memory pool structure to clear (see Note #2).
   1526          *
   1527          *               p_err    Pointer to variable that will receive the return error code from this function :
   1528          *
   1529          *                               LIB_MEM_ERR_NONE                Operation was successful.
   1530          *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1531          *
   1532          * Return(s)   : none.
   1533          *
   1534          * Caller(s)   : Application,
   1535          *               Mem_PoolCreate().
   1536          *
   1537          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
   1538          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
   1539          *
   1540          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
   1541          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
   1542          *                       this will likely corrupt the memory pool management.
   1543          *
   1544          *               (2) Assumes 'p_pool' points to a valid memory pool (if non-NULL).
   1545          *
   1546          *               (3) This function is DEPRECATED and will be removed in a future version of this product.
   1547          *********************************************************************************************************
   1548          */
   1549          
   1550          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1551          void  Mem_PoolClr (MEM_POOL  *p_pool,
   1552                             LIB_ERR   *p_err)
   1553          {
   1554          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
   1555              if (p_err == DEF_NULL) {
   1556                  CPU_SW_EXCEPTION(;);
   1557              }
   1558          
   1559                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
   1560              if (p_pool == DEF_NULL) {
   1561                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1562                  return;
   1563              }
   1564          #endif
   1565          
   1566              p_pool->PoolAddrStart = DEF_NULL;
   \                     Mem_PoolClr: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1567              p_pool->PoolAddrEnd   = DEF_NULL;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6042             STR      R2,[R0, #+4]
   1568              p_pool->BlkSize       = 0u;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x60C2             STR      R2,[R0, #+12]
   1569              p_pool->BlkNbr        = 0u;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x6082             STR      R2,[R0, #+8]
   1570              p_pool->BlkFreeTbl    = DEF_NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x6102             STR      R2,[R0, #+16]
   1571              p_pool->BlkFreeTblIx  = 0u;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x6142             STR      R2,[R0, #+20]
   1572          
   1573             *p_err = LIB_MEM_ERR_NONE;
   \   00000018   0xF242 0x7210      MOVW     R2,#+10000
   \   0000001C   0x800A             STRH     R2,[R1, #+0]
   1574          }
   \   0000001E   0x4770             BX       LR               ;; return
   1575          #endif
   1576          
   1577          
   1578          /*
   1579          *********************************************************************************************************
   1580          *                                          Mem_PoolBlkGet()
   1581          *
   1582          * Description : Gets a memory block from memory pool.
   1583          *
   1584          * Argument(s) : p_pool  Pointer to  memory pool to get memory block from.
   1585          *
   1586          *               size    Size of requested memory (in bytes).
   1587          *
   1588          *               p_err   Pointer to variable that will receive the return error code from this function :
   1589          *
   1590          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1591          *                           LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1592          *                           LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1593          *                           LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1594          *
   1595          * Return(s)   : Pointer to memory block, if NO error(s).
   1596          *
   1597          *               Pointer to NULL,         otherwise.
   1598          *
   1599          * Caller(s)   : Application.
   1600          *
   1601          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1602          *                   Mem_DynPoolBlkGet() should be used instead.
   1603          *********************************************************************************************************
   1604          */
   1605          
   1606          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1607          void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
   1608                                 CPU_SIZE_T   size,
   1609                                 LIB_ERR     *p_err)
   1610          {
   \                     Mem_PoolBlkGet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1611              CPU_INT08U  *p_blk;
   1612              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   1613          
   1614          
   1615          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
   1616              if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
   1617                  CPU_SW_EXCEPTION(DEF_NULL);
   1618              }
   1619          
   1620              if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
   1621                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1622                  return (DEF_NULL);
   1623              }
   1624          
   1625              if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
   1626                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1627                  return (DEF_NULL);
   1628              }
   1629          
   1630              if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
   1631                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1632                  return (DEF_NULL);
   1633              }
   1634          #else
   1635              (void)size;                                                 /* Prevent possible 'variable unused' warning.          */
   1636          #endif
   1637          
   1638          
   1639                                                                          /* -------------- GET MEM BLK FROM POOL --------------- */
   1640              p_blk = DEF_NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0007             MOVS     R7,R0
   1641              CPU_CRITICAL_ENTER();
   \   00000012   0x.... 0x....      BL       CPU_SR_Save
   \   00000016   0x4680             MOV      R8,R0
   \   00000018   0x.... 0x....      BL       CPU_IntDisMeasStart
   1642              if (p_pool->BlkFreeTblIx > 0u) {
   \   0000001C   0x6960             LDR      R0,[R4, #+20]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00C             BEQ.N    ??Mem_PoolBlkGet_0
   1643                  p_pool->BlkFreeTblIx                     -=  1u;
   \   00000022   0x6960             LDR      R0,[R4, #+20]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x6160             STR      R0,[R4, #+20]
   1644                  p_blk                                     = (CPU_INT08U *)p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
   \   00000028   0x6920             LDR      R0,[R4, #+16]
   \   0000002A   0x6961             LDR      R1,[R4, #+20]
   \   0000002C   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000030   0x0007             MOVS     R7,R0
   1645                  p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  =  DEF_NULL;
   \   00000032   0x6920             LDR      R0,[R4, #+16]
   \   00000034   0x6961             LDR      R1,[R4, #+20]
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   1646              }
   1647              CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolBlkGet_0: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000040   0x4640             MOV      R0,R8
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
   1648          
   1649              if (p_blk == DEF_NULL) {
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD103             BNE.N    ??Mem_PoolBlkGet_1
   1650                 *p_err = LIB_MEM_ERR_POOL_EMPTY;
   \   0000004A   0xF242 0x70DE      MOVW     R0,#+10206
   \   0000004E   0x8030             STRH     R0,[R6, #+0]
   \   00000050   0xE002             B.N      ??Mem_PoolBlkGet_2
   1651              } else {
   1652                 *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_PoolBlkGet_1: (+1)
   \   00000052   0xF242 0x7010      MOVW     R0,#+10000
   \   00000056   0x8030             STRH     R0,[R6, #+0]
   1653              }
   1654          
   1655              return (p_blk);
   \                     ??Mem_PoolBlkGet_2: (+1)
   \   00000058   0x0038             MOVS     R0,R7
   \   0000005A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1656          }
   1657          #endif
   1658          
   1659          
   1660          /*
   1661          *********************************************************************************************************
   1662          *                                          Mem_PoolBlkFree()
   1663          *
   1664          * Description : Free a memory block to memory pool.
   1665          *
   1666          * Argument(s) : p_pool  Pointer to memory pool to free memory block.
   1667          *
   1668          *               p_blk   Pointer to memory block address to free.
   1669          *
   1670          *               p_err   Pointer to variable that will receive the return error code from this function :
   1671          *
   1672          *                           LIB_MEM_ERR_NONE                        Operation was successful.
   1673          *                           LIB_MEM_ERR_NULL_PTR                    Argument 'p_pool'/'p_blk' passed
   1674          *                                                                       a NULL pointer.
   1675          *                           LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1676          *                           LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1677          *                                                                        in memory pool.
   1678          *                           LIB_MEM_ERR_POOL_FULL                   Pool is full.
   1679          *
   1680          * Return(s)   : none.
   1681          *
   1682          * Caller(s)   : Application.
   1683          *
   1684          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1685          *                   Mem_DynPoolBlkFree() should be used instead.
   1686          *********************************************************************************************************
   1687          */
   1688          
   1689          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1690          void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
   1691                                 void      *p_blk,
   1692                                 LIB_ERR   *p_err)
   1693          {
   \                     Mem_PoolBlkFree: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1694          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1695              CPU_SIZE_T   tbl_ix;
   1696              CPU_BOOLEAN  addr_valid;
   1697          #endif
   1698              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
   1699          
   1700          
   1701          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
   1702              if (p_err == DEF_NULL) {
   1703                  CPU_SW_EXCEPTION(;);
   1704              }
   1705          
   1706              if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
   1707                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1708                  return;
   1709              }
   1710          
   1711              if (p_blk == DEF_NULL) {
   1712                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1713                  return;
   1714              }
   1715          
   1716              addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
   1717              if (addr_valid != DEF_OK) {
   1718                 *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1719                  return;
   1720              }
   1721          
   1722              CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
   1723              for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
   1724                  if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
   1725                      CPU_CRITICAL_EXIT();
   1726                     *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   1727                      return;
   1728                  }
   1729              }
   1730          #else                                                           /* Double-free possibility if not in critical section.  */
   1731              CPU_CRITICAL_ENTER();
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
   \   0000000E   0x0007             MOVS     R7,R0
   \   00000010   0x.... 0x....      BL       CPU_IntDisMeasStart
   1732          #endif
   1733                                                                          /* --------------- FREE MEM BLK TO POOL --------------- */
   1734              if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
   \   00000014   0x6960             LDR      R0,[R4, #+20]
   \   00000016   0x68A1             LDR      R1,[R4, #+8]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD308             BCC.N    ??Mem_PoolBlkFree_0
   1735                  CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
   1736                 *p_err = LIB_MEM_ERR_POOL_FULL;
   \   00000026   0xF242 0x70DD      MOVW     R0,#+10205
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
   1737                  return;
   \   0000002C   0xE00E             B.N      ??Mem_PoolBlkFree_1
   1738              }
   1739          
   1740              p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
   \                     ??Mem_PoolBlkFree_0: (+1)
   \   0000002E   0x6920             LDR      R0,[R4, #+16]
   \   00000030   0x6961             LDR      R1,[R4, #+20]
   \   00000032   0xF840 0x5021      STR      R5,[R0, R1, LSL #+2]
   1741              p_pool->BlkFreeTblIx                     += 1u;
   \   00000036   0x6960             LDR      R0,[R4, #+20]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x6160             STR      R0,[R4, #+20]
   1742              CPU_CRITICAL_EXIT();
   \   0000003C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000040   0x0038             MOVS     R0,R7
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
   1743          
   1744             *p_err = LIB_MEM_ERR_NONE;
   \   00000046   0xF242 0x7010      MOVW     R0,#+10000
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
   1745          }
   \                     ??Mem_PoolBlkFree_1: (+1)
   \   0000004C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1746          #endif
   1747          
   1748          
   1749          /*
   1750          *********************************************************************************************************
   1751          *                                      Mem_PoolBlkGetNbrAvail()
   1752          *
   1753          * Description : Get memory pool's remaining number of blocks available to allocate.
   1754          *
   1755          * Argument(s) : p_pool   Pointer to a memory pool structure.
   1756          *
   1757          *               p_err    Pointer to variable that will receive the return error code from this function :
   1758          *
   1759          *                               LIB_MEM_ERR_NONE                Operation was successful.
   1760          *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1761          *
   1762          * Return(s)   : Remaining memory pool blocks,   if NO error(s).
   1763          *
   1764          *               0,                              otherwise.
   1765          *
   1766          * Caller(s)   : Application.
   1767          *
   1768          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1769          *                   Mem_DynPoolBlkNbrAvailGet() should be used instead.
   1770          *********************************************************************************************************
   1771          */
   1772          
   1773          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1774          MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
   1775                                                    LIB_ERR   *p_err)
   1776          {
   \                     Mem_PoolBlkGetNbrAvail: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1777              CPU_SIZE_T  nbr_avail;
   1778              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
   1779          
   1780          
   1781          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1782                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
   1783              if (p_err == DEF_NULL) {
   1784                  CPU_SW_EXCEPTION(0u);
   1785              }
   1786                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
   1787              if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
   1788                 *p_err =  LIB_MEM_ERR_NULL_PTR;
   1789                  return (0u);
   1790              }
   1791          #endif
   1792          
   1793              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0007             MOVS     R7,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
   1794              nbr_avail = p_pool->BlkFreeTblIx;
   \   00000012   0x6960             LDR      R0,[R4, #+20]
   \   00000014   0x0006             MOVS     R6,R0
   1795              CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
   1796          
   1797             *p_err = LIB_MEM_ERR_NONE;
   \   00000020   0xF242 0x7010      MOVW     R0,#+10000
   \   00000024   0x8028             STRH     R0,[R5, #+0]
   1798          
   1799              return (nbr_avail);
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1800          }
   1801          #endif
   1802          
   1803          
   1804          /*
   1805          *********************************************************************************************************
   1806          *                                          Mem_DynPoolCreate()
   1807          *
   1808          * Description : Creates a dynamic memory pool.
   1809          *
   1810          * Argument(s) : p_name          Pointer to pool name.
   1811          *
   1812          *               p_pool          Pointer to pool data.
   1813          *
   1814          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1815          *                               general-purpose heap if null.
   1816          *
   1817          *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
   1818          *
   1819          *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
   1820          *
   1821          *               blk_qty_init    Initial number of elements to be allocated in pool.
   1822          *
   1823          *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1824          *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1825          *
   1826          *               p_err           Pointer to variable that will receive the return error code from this function :
   1827          *
   1828          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1829          *
   1830          *                                   --------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
   1831          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
   1832          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
   1833          *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
   1834          *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
   1835          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1836          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1837          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1838          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1839          *
   1840          * Return(s)   : None.
   1841          *
   1842          * Caller(s)   : Application.
   1843          *
   1844          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1845          *                   block is stored in the block itself (only when free/unused).
   1846          *********************************************************************************************************
   1847          */
   1848          

   \                                 In section .text, align 2, keep-with-next
   1849          void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
   1850                                          MEM_DYN_POOL  *p_pool,
   1851                                          MEM_SEG       *p_seg,
   1852                                          CPU_SIZE_T     blk_size,
   1853                                          CPU_SIZE_T     blk_align,
   1854                                          CPU_SIZE_T     blk_qty_init,
   1855                                          CPU_SIZE_T     blk_qty_max,
   1856                                          LIB_ERR       *p_err)
   1857          {
   \                     Mem_DynPoolCreate: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   \   00000012   0xF8DD 0x903C      LDR      R9,[SP, #+60]
   \   00000016   0xF8DD 0xA040      LDR      R10,[SP, #+64]
   \   0000001A   0xF8DD 0xB044      LDR      R11,[SP, #+68]
   1858              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD102             BNE.N    ??Mem_DynPoolCreate_0
   1859          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1860                  p_seg = &Mem_SegHeap;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000026   0x0006             MOVS     R6,R0
   1861          #else
   1862                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1863                  return;
   1864          #endif
   1865              }
   1866          
   1867              Mem_DynPoolCreateInternal(p_name,
   1868                                        p_pool,
   1869                                        p_seg,
   1870                                        blk_size,
   1871                                        blk_align,
   1872                                        LIB_MEM_PADDING_ALIGN_NONE,
   1873                                        blk_qty_init,
   1874                                        blk_qty_max,
   1875                                        p_err);
   \                     ??Mem_DynPoolCreate_0: (+1)
   \   00000028   0xF8CD 0xB010      STR      R11,[SP, #+16]
   \   0000002C   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \   00000030   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000003C   0x003B             MOVS     R3,R7
   \   0000003E   0x0032             MOVS     R2,R6
   \   00000040   0x0029             MOVS     R1,R5
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1876          }
   \   00000048   0xB005             ADD      SP,SP,#+20
   \   0000004A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1877          
   1878          
   1879          /*
   1880          *********************************************************************************************************
   1881          *                                        Mem_DynPoolCreateHW()
   1882          *
   1883          * Description : Creates a dynamic memory pool. Memory blocks will be padded according to memory segment's
   1884          *               properties.
   1885          *
   1886          * Argument(s) : p_name          Pointer to pool name.
   1887          *
   1888          *               p_pool          Pointer to pool data.
   1889          *
   1890          *               p_seg           Pointer to segment from which to allocate memory. Will allocate from
   1891          *                               general-purpose heap if null.
   1892          *
   1893          *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
   1894          *
   1895          *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
   1896          *
   1897          *               blk_qty_init    Initial number of elements to be allocated in pool.
   1898          *
   1899          *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1900          *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1901          *
   1902          *               p_err           Pointer to variable that will receive the return error code from this function :
   1903          *
   1904          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1905          *
   1906          *                                   -------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
   1907          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1908          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1909          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1910          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1911          *
   1912          * Return(s)   : None.
   1913          *
   1914          * Caller(s)   : Application.
   1915          *
   1916          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1917          *                   block is stored in the block itself (only when free/unused).
   1918          *********************************************************************************************************
   1919          */
   1920          

   \                                 In section .text, align 2, keep-with-next
   1921          void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
   1922                                            MEM_DYN_POOL  *p_pool,
   1923                                            MEM_SEG       *p_seg,
   1924                                            CPU_SIZE_T     blk_size,
   1925                                            CPU_SIZE_T     blk_align,
   1926                                            CPU_SIZE_T     blk_qty_init,
   1927                                            CPU_SIZE_T     blk_qty_max,
   1928                                            LIB_ERR       *p_err)
   1929          {
   \                     Mem_DynPoolCreateHW: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   \   00000012   0xF8DD 0x903C      LDR      R9,[SP, #+60]
   \   00000016   0xF8DD 0xA040      LDR      R10,[SP, #+64]
   \   0000001A   0xF8DD 0xB044      LDR      R11,[SP, #+68]
   1930              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD102             BNE.N    ??Mem_DynPoolCreateHW_0
   1931          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1932                  p_seg = &Mem_SegHeap;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000026   0x0006             MOVS     R6,R0
   1933          #else
   1934                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1935                  return;
   1936          #endif
   1937              }
   1938          
   1939              Mem_DynPoolCreateInternal(p_name,
   1940                                        p_pool,
   1941                                        p_seg,
   1942                                        blk_size,
   1943                                        blk_align,
   1944                                        p_seg->PaddingAlign,
   1945                                        blk_qty_init,
   1946                                        blk_qty_max,
   1947                                        p_err);
   \                     ??Mem_DynPoolCreateHW_0: (+1)
   \   00000028   0xF8CD 0xB010      STR      R11,[SP, #+16]
   \   0000002C   0xF8CD 0xA00C      STR      R10,[SP, #+12]
   \   00000030   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000034   0x6930             LDR      R0,[R6, #+16]
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000003C   0x003B             MOVS     R3,R7
   \   0000003E   0x0032             MOVS     R2,R6
   \   00000040   0x0029             MOVS     R1,R5
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1948          }
   \   00000048   0xB005             ADD      SP,SP,#+20
   \   0000004A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1949          
   1950          
   1951          /*
   1952          *********************************************************************************************************
   1953          *                                          Mem_DynPoolBlkGet()
   1954          *
   1955          * Description : Gets a memory block from specified pool, growing it if needed.
   1956          *
   1957          * Argument(s) : p_pool  Pointer to pool data.
   1958          *
   1959          *               p_err   Pointer to variable that will receive the return error code from this function :
   1960          *
   1961          *                           LIB_MEM_ERR_NONE                    Operation was successful.
   1962          *                           LIB_MEM_ERR_NULL_PTR                Pool data pointer NULL.
   1963          *                           LIB_MEM_ERR_POOL_EMPTY              Pools is empty.
   1964          *
   1965          *                           ----------------------RETURNED BY Mem_SegAllocInternal()-----------------------
   1966          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
   1967          *                           LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
   1968          *                           LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
   1969          *                           LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1970          *
   1971          * Return(s)   : Pointer to memory block, if successful.
   1972          *
   1973          *               DEF_NULL, otherwise.
   1974          *
   1975          * Caller(s)   : Application.
   1976          *
   1977          * Note(s)     : none.
   1978          *********************************************************************************************************
   1979          */
   1980          

   \                                 In section .text, align 2, keep-with-next
   1981          void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
   1982                                    LIB_ERR       *p_err)
   1983          {
   \                     Mem_DynPoolBlkGet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   1984                     void      *p_blk;
   1985              const  CPU_CHAR  *p_pool_name;
   1986              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   1987          
   1988          
   1989          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1990              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   1991                  CPU_SW_EXCEPTION(DEF_NULL);
   1992              }
   1993          
   1994              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   1995                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1996                  return (DEF_NULL);
   1997              }
   1998          #endif
   1999          
   2000                                                                          /* Ensure pool is not empty if qty is limited.          */
   2001              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \   0000000E   0x6960             LDR      R0,[R4, #+20]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD01A             BEQ.N    ??Mem_DynPoolBlkGet_0
   2002                  CPU_CRITICAL_ENTER();
   \   00000014   0x.... 0x....      BL       CPU_SR_Save
   \   00000018   0x4680             MOV      R8,R0
   \   0000001A   0x.... 0x....      BL       CPU_IntDisMeasStart
   2003                  if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
   \   0000001E   0x69A0             LDR      R0,[R4, #+24]
   \   00000020   0x6961             LDR      R1,[R4, #+20]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD309             BCC.N    ??Mem_DynPoolBlkGet_1
   2004                      CPU_CRITICAL_EXIT();
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0x.... 0x....      BL       CPU_SR_Restore
   2005          
   2006                     *p_err = LIB_MEM_ERR_POOL_EMPTY;
   \   00000030   0xF242 0x70DE      MOVW     R0,#+10206
   \   00000034   0x8028             STRH     R0,[R5, #+0]
   2007                      return (DEF_NULL);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE039             B.N      ??Mem_DynPoolBlkGet_2
   2008                  }
   2009          
   2010                  p_pool->BlkAllocCnt++;
   \                     ??Mem_DynPoolBlkGet_1: (+1)
   \   0000003A   0x69A0             LDR      R0,[R4, #+24]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x61A0             STR      R0,[R4, #+24]
   2011                  CPU_CRITICAL_EXIT();
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
   2012              }
   2013          
   2014                                                                          /* --------------- ALLOC FROM FREE LIST --------------- */
   2015              CPU_CRITICAL_ENTER();
   \                     ??Mem_DynPoolBlkGet_0: (+1)
   \   0000004A   0x.... 0x....      BL       CPU_SR_Save
   \   0000004E   0x4680             MOV      R8,R0
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStart
   2016              if (p_pool->BlkFreePtr != DEF_NULL) {
   \   00000054   0x6920             LDR      R0,[R4, #+16]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00D             BEQ.N    ??Mem_DynPoolBlkGet_3
   2017                  p_blk              = p_pool->BlkFreePtr;
   \   0000005A   0x6920             LDR      R0,[R4, #+16]
   \   0000005C   0x0006             MOVS     R6,R0
   2018                  p_pool->BlkFreePtr = *((void **)p_blk);
   \   0000005E   0x6830             LDR      R0,[R6, #+0]
   \   00000060   0x6120             STR      R0,[R4, #+16]
   2019                  CPU_CRITICAL_EXIT();
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
   2020          
   2021                 *p_err = LIB_MEM_ERR_NONE;
   \   0000006C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000070   0x8028             STRH     R0,[R5, #+0]
   2022          
   2023                  return (p_blk);
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0xE01B             B.N      ??Mem_DynPoolBlkGet_2
   2024              }
   2025              CPU_CRITICAL_EXIT();
   \                     ??Mem_DynPoolBlkGet_3: (+1)
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
   2026          
   2027                                                                          /* ------------------ ALLOC NEW BLK ------------------- */
   2028          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2029              p_pool_name = p_pool->NamePtr;
   2030          #else
   2031              p_pool_name = DEF_NULL;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0007             MOVS     R7,R0
   2032          #endif
   2033              p_blk = Mem_SegAllocInternal(p_pool_name,
   2034                                           p_pool->PoolSegPtr,
   2035                                           p_pool->BlkSize,
   2036                                           p_pool->BlkAlign,
   2037                                           p_pool->BlkPaddingAlign,
   2038                                           DEF_NULL,
   2039                                           p_err);
   \   00000084   0x9502             STR      R5,[SP, #+8]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0x68E0             LDR      R0,[R4, #+12]
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0x68A3             LDR      R3,[R4, #+8]
   \   00000090   0x6862             LDR      R2,[R4, #+4]
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x0038             MOVS     R0,R7
   \   00000096   0x.... 0x....      BL       Mem_SegAllocInternal
   \   0000009A   0x0006             MOVS     R6,R0
   2040              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000009C   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   000000A0   0xF242 0x7110      MOVW     R1,#+10000
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD001             BEQ.N    ??Mem_DynPoolBlkGet_4
   2041                  return (DEF_NULL);
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xE000             B.N      ??Mem_DynPoolBlkGet_2
   2042              }
   2043          
   2044              return (p_blk);
   \                     ??Mem_DynPoolBlkGet_4: (+1)
   \   000000AC   0x0030             MOVS     R0,R6
   \                     ??Mem_DynPoolBlkGet_2: (+1)
   \   000000AE   0xB004             ADD      SP,SP,#+16
   \   000000B0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2045          }
   2046          
   2047          
   2048          /*
   2049          *********************************************************************************************************
   2050          *                                         Mem_DynPoolBlkFree()
   2051          *
   2052          * Description : Frees memory block, making it available for future use.
   2053          *
   2054          * Argument(s) : p_pool  Pointer to pool data.
   2055          *
   2056          *               p_blk   Pointer to first byte of memory block.
   2057          *
   2058          *               p_err   Pointer to variable that will receive the return error code from this function :
   2059          *
   2060          *                           LIB_MEM_ERR_NONE        Operation was successful.
   2061          *                           LIB_MEM_ERR_NULL_PTR    'p_pool' or 'p_blk' pointer passed is NULL.
   2062          *                           LIB_MEM_ERR_POOL_FULL   Pool is full.
   2063          *
   2064          * Return(s)   : none.
   2065          *
   2066          * Caller(s)   : Application.
   2067          *
   2068          * Note(s)     : none.
   2069          *********************************************************************************************************
   2070          */
   2071          

   \                                 In section .text, align 2, keep-with-next
   2072          void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
   2073                                    void          *p_blk,
   2074                                    LIB_ERR       *p_err)
   2075          {
   \                     Mem_DynPoolBlkFree: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2076              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
   2077          
   2078          
   2079          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2080              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2081                  CPU_SW_EXCEPTION(;);
   2082              }
   2083          
   2084              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   2085                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2086                  return;
   2087              }
   2088          
   2089              if (p_blk == DEF_NULL) {
   2090                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2091                  return;
   2092              }
   2093          #endif
   2094          
   2095              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
   \   0000000A   0x6960             LDR      R0,[R4, #+20]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD018             BEQ.N    ??Mem_DynPoolBlkFree_0
   2096                  CPU_CRITICAL_ENTER();
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   \   00000014   0x0007             MOVS     R7,R0
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStart
   2097                  if (p_pool->BlkAllocCnt == 0u) {
   \   0000001A   0x69A0             LDR      R0,[R4, #+24]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD108             BNE.N    ??Mem_DynPoolBlkFree_1
   2098                      CPU_CRITICAL_EXIT();
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000024   0x0038             MOVS     R0,R7
   \   00000026   0x.... 0x....      BL       CPU_SR_Restore
   2099          
   2100                     *p_err = LIB_MEM_ERR_POOL_FULL;
   \   0000002A   0xF242 0x70DD      MOVW     R0,#+10205
   \   0000002E   0x8030             STRH     R0,[R6, #+0]
   2101                      return;
   \   00000030   0xE017             B.N      ??Mem_DynPoolBlkFree_2
   2102                  }
   2103          
   2104                  p_pool->BlkAllocCnt--;
   \                     ??Mem_DynPoolBlkFree_1: (+1)
   \   00000032   0x69A0             LDR      R0,[R4, #+24]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x61A0             STR      R0,[R4, #+24]
   2105                  CPU_CRITICAL_EXIT();
   \   00000038   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
   2106              }
   2107          
   2108              CPU_CRITICAL_ENTER();
   \                     ??Mem_DynPoolBlkFree_0: (+1)
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x0007             MOVS     R7,R0
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStart
   2109             *((void **)p_blk)   = p_pool->BlkFreePtr;
   \   0000004C   0x6920             LDR      R0,[R4, #+16]
   \   0000004E   0x6028             STR      R0,[R5, #+0]
   2110              p_pool->BlkFreePtr = p_blk;
   \   00000050   0x6125             STR      R5,[R4, #+16]
   2111              CPU_CRITICAL_EXIT();
   \   00000052   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
   2112          
   2113             *p_err = LIB_MEM_ERR_NONE;
   \   0000005C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000060   0x8030             STRH     R0,[R6, #+0]
   2114          }
   \                     ??Mem_DynPoolBlkFree_2: (+1)
   \   00000062   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2115          
   2116          
   2117          /*
   2118          *********************************************************************************************************
   2119          *                                     Mem_DynPoolBlkNbrAvailGet()
   2120          *
   2121          * Description : Gets number of available blocks in dynamic memory pool. This call will fail with a
   2122          *               dynamic memory pool for which no limit was set at creation.
   2123          *
   2124          * Argument(s) : p_pool  Pointer to pool data.
   2125          *
   2126          *               p_err   Pointer to variable that will receive the return error code from this function :
   2127          *
   2128          *                           LIB_MEM_ERR_NONE                Operation was successful.
   2129          *                           LIB_MEM_ERR_NULL_PTR            'p_pool' pointer passed is NULL.
   2130          *                           LIB_MEM_ERR_POOL_UNLIMITED      Pool has no specified limit.
   2131          *
   2132          * Return(s)   : Number of blocks available in dynamic memory pool, if successful.
   2133          *
   2134          *               0, if pool is empty or if an error occurred.
   2135          *
   2136          * Caller(s)   : Application.
   2137          *
   2138          * Note(s)     : None.
   2139          *********************************************************************************************************
   2140          */
   2141          

   \                                 In section .text, align 2, keep-with-next
   2142          CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
   2143                                                 LIB_ERR       *p_err)
   2144          {
   \                     Mem_DynPoolBlkNbrAvailGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2145              CPU_SIZE_T  blk_nbr_avail;
   2146              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
   2147          
   2148          
   2149          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2150              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2151                  CPU_SW_EXCEPTION(0);
   2152              }
   2153          
   2154              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   2155                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2156                  return (0u);
   2157              }
   2158          #endif
   2159          
   2160              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD011             BEQ.N    ??Mem_DynPoolBlkNbrAvailGet_0
   2161                  CPU_CRITICAL_ENTER();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Save
   \   00000012   0x0007             MOVS     R7,R0
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStart
   2162                  blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
   \   00000018   0x6960             LDR      R0,[R4, #+20]
   \   0000001A   0x69A1             LDR      R1,[R4, #+24]
   \   0000001C   0x1A40             SUBS     R0,R0,R1
   \   0000001E   0x0006             MOVS     R6,R0
   2163                  CPU_CRITICAL_EXIT();
   \   00000020   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000024   0x0038             MOVS     R0,R7
   \   00000026   0x.... 0x....      BL       CPU_SR_Restore
   2164          
   2165                 *p_err = LIB_MEM_ERR_NONE;
   \   0000002A   0xF242 0x7010      MOVW     R0,#+10000
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
   \   00000030   0xE004             B.N      ??Mem_DynPoolBlkNbrAvailGet_1
   2166              } else {
   2167                  blk_nbr_avail = 0u;
   \                     ??Mem_DynPoolBlkNbrAvailGet_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x0006             MOVS     R6,R0
   2168                 *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
   \   00000036   0xF242 0x70DF      MOVW     R0,#+10207
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
   2169              }
   2170          
   2171              return (blk_nbr_avail);
   \                     ??Mem_DynPoolBlkNbrAvailGet_1: (+1)
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2172          }
   2173          
   2174          
   2175          /*
   2176          *********************************************************************************************************
   2177          *                                           Mem_OutputUsage()
   2178          *
   2179          * Description : Outputs memory usage report through 'out_fnct'.
   2180          *
   2181          * Argument(s) : out_fnct        Pointer to output function.
   2182          *
   2183          *               print_details   DEF_YES, if the size of each allocation should be printed.
   2184          *                               DEF_NO,  otherwise.
   2185          *
   2186          *               p_err           Pointer to variable that will receive the return error code from this function :
   2187          *
   2188          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   2189          *                                   LIB_MEM_ERR_NULL_PTR            'out_fnct' pointer passed is NULL.
   2190          *
   2191          *                                   ---------------------RETURNED BY Mem_SegRemSizeGet()--------------------
   2192          *                                   LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
   2193          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
   2194          *
   2195          * Return(s)   : None.
   2196          *
   2197          * Caller(s)   : Application.
   2198          *
   2199          * Note(s)     : none.
   2200          *********************************************************************************************************
   2201          */
   2202          
   2203          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2204          void  Mem_OutputUsage(void     (*out_fnct) (CPU_CHAR *),
   2205                                LIB_ERR   *p_err)
   2206          {
   2207              CPU_CHAR   str[DEF_INT_32U_NBR_DIG_MAX];
   2208              MEM_SEG   *p_seg;
   2209              CPU_SR_ALLOC();
   2210          
   2211          
   2212          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2213              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2214                  CPU_SW_EXCEPTION(;);
   2215              }
   2216          
   2217              if (out_fnct == DEF_NULL) {                                 /* Chk for NULL out fnct ptr.                           */
   2218                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2219                  return;
   2220              }
   2221          #endif
   2222          
   2223              out_fnct((CPU_CHAR *)"---------------- Memory allocation info ----------------\r\n");
   2224              out_fnct((CPU_CHAR *)"| Type    | Size       | Free size  | Name\r\n");
   2225              out_fnct((CPU_CHAR *)"|---------|------------|------------|-------------------\r\n");
   2226          
   2227              CPU_CRITICAL_ENTER();
   2228              p_seg = Mem_SegHeadPtr;
   2229              while (p_seg != DEF_NULL) {
   2230                  CPU_SIZE_T       rem_size;
   2231                  MEM_SEG_INFO     seg_info;
   2232                  MEM_ALLOC_INFO  *p_alloc;
   2233          
   2234          
   2235                  rem_size = Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
   2236                  if (*p_err != LIB_MEM_ERR_NONE) {
   2237                      return;
   2238                  }
   2239          
   2240                  out_fnct((CPU_CHAR *)"| Section | ");
   2241          
   2242                  (void)Str_FmtNbr_Int32U(seg_info.TotalSize,
   2243                                          10u,
   2244                                          DEF_NBR_BASE_DEC,
   2245                                          ' ',
   2246                                          DEF_NO,
   2247                                          DEF_YES,
   2248                                         &str[0u]);
   2249          
   2250                  out_fnct(str);
   2251                  out_fnct((CPU_CHAR *)" | ");
   2252          
   2253                  (void)Str_FmtNbr_Int32U(rem_size,
   2254                                          10u,
   2255                                          DEF_NBR_BASE_DEC,
   2256                                          ' ',
   2257                                          DEF_NO,
   2258                                          DEF_YES,
   2259                                         &str[0u]);
   2260          
   2261                  out_fnct(str);
   2262                  out_fnct((CPU_CHAR *)" | ");
   2263                  out_fnct((p_seg->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_seg->NamePtr : (CPU_CHAR *)"Unknown");
   2264                  out_fnct((CPU_CHAR *)"\r\n");
   2265          
   2266                  p_alloc = p_seg->AllocInfoHeadPtr;
   2267                  while (p_alloc != DEF_NULL) {
   2268                      out_fnct((CPU_CHAR *)"| -> Obj  | ");
   2269          
   2270                      (void)Str_FmtNbr_Int32U(p_alloc->Size,
   2271                                              10u,
   2272                                              DEF_NBR_BASE_DEC,
   2273                                              ' ',
   2274                                              DEF_NO,
   2275                                              DEF_YES,
   2276                                             &str[0u]);
   2277          
   2278                      out_fnct(str);
   2279                      out_fnct((CPU_CHAR *)" |            | ");
   2280          
   2281                      out_fnct((p_alloc->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_alloc->NamePtr : (CPU_CHAR *)"Unknown");
   2282                      out_fnct((CPU_CHAR *)"\r\n");
   2283          
   2284                      p_alloc = p_alloc->NextPtr;
   2285                  }
   2286          
   2287                  p_seg = p_seg->NextPtr;
   2288              }
   2289              CPU_CRITICAL_EXIT();
   2290          
   2291             *p_err = LIB_MEM_ERR_NONE;
   2292          }
   2293          #endif
   2294          
   2295          
   2296          /*
   2297          *********************************************************************************************************
   2298          *********************************************************************************************************
   2299          *                                           LOCAL FUNCTIONS
   2300          *********************************************************************************************************
   2301          *********************************************************************************************************
   2302          */
   2303          
   2304          /*
   2305          *********************************************************************************************************
   2306          *                                       Mem_SegCreateCritical()
   2307          *
   2308          * Description : Creates a new memory segment to be used for runtime memory allocation or dynamic pools.
   2309          *
   2310          * Argument(s) : p_name          Pointer to segment name.
   2311          *
   2312          *               p_seg           Pointer to segment data. Must be allocated by caller.
   2313          *               -----           Argument validated by caller.
   2314          *
   2315          *               seg_base_addr   Segment's first byte address.
   2316          *
   2317          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer
   2318          *                               from this memory segment. MUST be a power of 2.
   2319          *                               LIB_MEM_PADDING_ALIGN_NONE means no padding.
   2320          *               -------------   Argument validated by caller.
   2321          *
   2322          *               size            Total size of segment, in bytes.
   2323          *               ----            Argument validated by caller.
   2324          *
   2325          * Return(s)   : Pointer to segment data, if successful.
   2326          *
   2327          *               DEF_NULL, otherwise.
   2328          *
   2329          * Caller(s)   : Mem_PoolCreate(),
   2330          *               Mem_SegCreate().
   2331          *
   2332          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2333          *********************************************************************************************************
   2334          */
   2335          

   \                                 In section .text, align 2, keep-with-next
   2336          static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
   2337                                                     MEM_SEG     *p_seg,
   2338                                                     CPU_ADDR     seg_base_addr,
   2339                                                     CPU_SIZE_T   padding_align,
   2340                                                     CPU_SIZE_T   size)
   2341          {
   \                     Mem_SegCreateCritical: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x9C02             LDR      R4,[SP, #+8]
   2342              p_seg->AddrBase         =  seg_base_addr;
   \   00000004   0x600A             STR      R2,[R1, #+0]
   2343              p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
   \   00000006   0x18A5             ADDS     R5,R4,R2
   \   00000008   0x1E6D             SUBS     R5,R5,#+1
   \   0000000A   0x604D             STR      R5,[R1, #+4]
   2344              p_seg->AddrNext         =  seg_base_addr;
   \   0000000C   0x608A             STR      R2,[R1, #+8]
   2345              p_seg->NextPtr          =  Mem_SegHeadPtr;
   \   0000000E   0x....             LDR.N    R5,??DataTable12
   \   00000010   0x682D             LDR      R5,[R5, #+0]
   \   00000012   0x60CD             STR      R5,[R1, #+12]
   2346              p_seg->PaddingAlign     =  padding_align;
   \   00000014   0x610B             STR      R3,[R1, #+16]
   2347          
   2348          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2349              p_seg->NamePtr          = p_name;
   2350              p_seg->AllocInfoHeadPtr = DEF_NULL;
   2351          #else
   2352              (void)p_name;
   2353          #endif
   2354          
   2355              Mem_SegHeadPtr = p_seg;
   \   00000016   0x....             LDR.N    R5,??DataTable12
   \   00000018   0x6029             STR      R1,[R5, #+0]
   2356          }
   \   0000001A   0xBC30             POP      {R4,R5}
   \   0000001C   0x4770             BX       LR               ;; return
   2357          
   2358          
   2359          /*
   2360          *********************************************************************************************************
   2361          *                                      Mem_SegOverlapChkCritical()
   2362          *
   2363          * Description : Checks if existing memory segment exists or overlaps with specified memory area.
   2364          *
   2365          * Argument(s) : seg_base_addr   Address of first byte of memory area.
   2366          *
   2367          *               size            Size of memory area, in bytes.
   2368          *
   2369          *               p_err       Pointer to variable that will receive the return error code from this function :
   2370          *
   2371          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
   2372          *                               LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
   2373          *
   2374          * Return(s)   : Pointer to memory segment that overlaps.
   2375          *
   2376          *               DEF_NULL, otherwise.
   2377          *
   2378          * Caller(s)   : Mem_PoolCreate(),
   2379          *               Mem_SegCreate().
   2380          *
   2381          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2382          *********************************************************************************************************
   2383          */
   2384          
   2385          #if  (LIB_MEM_CFG_HEAP_SIZE      >  0u)

   \                                 In section .text, align 2, keep-with-next
   2386          static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
   2387                                                       CPU_SIZE_T   size,
   2388                                                       LIB_ERR     *p_err)
   2389          {
   \                     Mem_SegOverlapChkCritical: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
   2390              MEM_SEG   *p_seg_chk;
   2391              CPU_ADDR   seg_new_end;
   2392              CPU_ADDR   seg_chk_start;
   2393              CPU_ADDR   seg_chk_end;
   2394          
   2395          
   2396              seg_new_end = seg_base_addr + (size - 1u);
   \   00000004   0x18C8             ADDS     R0,R1,R3
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x0005             MOVS     R5,R0
   2397              p_seg_chk   = Mem_SegHeadPtr;
   \   0000000A   0x....             LDR.N    R0,??DataTable12
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
   2398          
   2399              while (p_seg_chk != DEF_NULL) {
   \                     ??Mem_SegOverlapChkCritical_0: (+1)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD01B             BEQ.N    ??Mem_SegOverlapChkCritical_1
   2400                  seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x0006             MOVS     R6,R0
   2401                  seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x0007             MOVS     R7,R0
   2402          
   2403                  if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
   \   0000001C   0x42B3             CMP      R3,R6
   \   0000001E   0xD106             BNE.N    ??Mem_SegOverlapChkCritical_2
   \   00000020   0x42BD             CMP      R5,R7
   \   00000022   0xD104             BNE.N    ??Mem_SegOverlapChkCritical_2
   2404                     *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
   \   00000024   0xF44F 0x501E      MOV      R0,#+10112
   \   00000028   0x8010             STRH     R0,[R2, #+0]
   2405                      return (p_seg_chk);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xE012             B.N      ??Mem_SegOverlapChkCritical_3
   2406                  } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
   2407                             ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
   \                     ??Mem_SegOverlapChkCritical_2: (+1)
   \   0000002E   0x42B3             CMP      R3,R6
   \   00000030   0xD301             BCC.N    ??Mem_SegOverlapChkCritical_4
   \   00000032   0x429F             CMP      R7,R3
   \   00000034   0xD203             BCS.N    ??Mem_SegOverlapChkCritical_5
   \                     ??Mem_SegOverlapChkCritical_4: (+1)
   \   00000036   0x429E             CMP      R6,R3
   \   00000038   0xD306             BCC.N    ??Mem_SegOverlapChkCritical_6
   \   0000003A   0x42B5             CMP      R5,R6
   \   0000003C   0xD304             BCC.N    ??Mem_SegOverlapChkCritical_6
   2408                     *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
   \                     ??Mem_SegOverlapChkCritical_5: (+1)
   \   0000003E   0xF242 0x707F      MOVW     R0,#+10111
   \   00000042   0x8010             STRH     R0,[R2, #+0]
   2409                      return (p_seg_chk);
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xE005             B.N      ??Mem_SegOverlapChkCritical_3
   2410                  }
   2411          
   2412                  p_seg_chk = p_seg_chk->NextPtr;
   \                     ??Mem_SegOverlapChkCritical_6: (+1)
   \   00000048   0x68E4             LDR      R4,[R4, #+12]
   \   0000004A   0xE7E1             B.N      ??Mem_SegOverlapChkCritical_0
   2413              }
   2414          
   2415             *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_SegOverlapChkCritical_1: (+1)
   \   0000004C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000050   0x8010             STRH     R0,[R2, #+0]
   2416          
   2417              return (DEF_NULL);
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegOverlapChkCritical_3: (+1)
   \   00000054   0xBCF0             POP      {R4-R7}
   \   00000056   0x4770             BX       LR               ;; return
   2418          }
   2419          #endif
   2420          
   2421          
   2422          /*
   2423          *********************************************************************************************************
   2424          *                                       Mem_SegAllocInternal()
   2425          *
   2426          * Description : Allocates memory from specified segment.
   2427          *
   2428          * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   2429          *
   2430          *               p_seg           Pointer to segment from which to allocate memory.
   2431          *               -----           Argument validated by caller.
   2432          *
   2433          *               size            Size of memory block to allocate, in bytes.
   2434          *
   2435          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2436          *
   2437          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
   2438          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2439          *                               means no padding.
   2440          *
   2441          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   2442          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   2443          *
   2444          *               p_err           Pointer to variable that will receive the return error code from this function :
   2445          *
   2446          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   2447          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   2448          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   2449          *
   2450          *                                   ------------------RETURNED BY Mem_SegAllocExtCritical()------------------
   2451          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   2452          *
   2453          * Return(s)   : Pointer to allocated memory block, if successful.
   2454          *
   2455          *               DEF_NULL, otherwise.
   2456          *
   2457          * Caller(s)   : Mem_DynPoolBlkGet(),
   2458          *               Mem_DynPoolCreateInternal(),
   2459          *               Mem_HeapAlloc(),
   2460          *               Mem_PoolCreate(),
   2461          *               Mem_SegAlloc(),
   2462          *               Mem_SegAllocExt(),
   2463          *               Mem_SegAllocHW().
   2464          *
   2465          * Note(s)     : none.
   2466          *********************************************************************************************************
   2467          */
   2468          

   \                                 In section .text, align 2, keep-with-next
   2469          static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
   2470                                                      MEM_SEG     *p_seg,
   2471                                                      CPU_SIZE_T   size,
   2472                                                      CPU_SIZE_T   align,
   2473                                                      CPU_SIZE_T   padding_align,
   2474                                                      CPU_SIZE_T  *p_bytes_reqd,
   2475                                                      LIB_ERR     *p_err)
   2476          {
   \                     Mem_SegAllocInternal: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000010   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   \   00000014   0xF8DD 0xA038      LDR      R10,[SP, #+56]
   2477              void  *p_blk;
   2478              CPU_SR_ALLOC();
   \   00000018   0xF05F 0x0B00      MOVS     R11,#+0
   2479          
   2480          
   2481          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2482              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   2483                  CPU_SW_EXCEPTION(DEF_NULL);
   2484              }
   2485          
   2486              if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
   2487                 *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
   2488                  return (DEF_NULL);
   2489              }
   2490          
   2491              if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
   2492                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   2493                  return (DEF_NULL);
   2494              }
   2495          #endif
   2496          
   2497              CPU_CRITICAL_ENTER();
   \   0000001C   0x.... 0x....      BL       CPU_SR_Save
   \   00000020   0x4683             MOV      R11,R0
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStart
   2498              p_blk = Mem_SegAllocExtCritical(p_seg,
   2499                                              size,
   2500                                              align,
   2501                                              padding_align,
   2502                                              p_bytes_reqd,
   2503                                              p_err);
   \   00000026   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \   0000002A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000002E   0x4643             MOV      R3,R8
   \   00000030   0x003A             MOVS     R2,R7
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       Mem_SegAllocExtCritical
   \   0000003A   0x9002             STR      R0,[SP, #+8]
   2504              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000003C   0xF9BA 0x0000      LDRSH    R0,[R10, #+0]
   \   00000040   0xF242 0x7110      MOVW     R1,#+10000
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD006             BEQ.N    ??Mem_SegAllocInternal_0
   2505                  CPU_CRITICAL_EXIT();
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000004C   0x4658             MOV      R0,R11
   \   0000004E   0x.... 0x....      BL       CPU_SR_Restore
   2506                  return (DEF_NULL);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE005             B.N      ??Mem_SegAllocInternal_1
   2507              }
   2508          
   2509          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
   2510              Mem_SegAllocTrackCritical(p_name,
   2511                                        p_seg,
   2512                                        size,
   2513                                        p_err);
   2514              if (*p_err != LIB_MEM_ERR_NONE) {
   2515                  CPU_CRITICAL_EXIT();
   2516                  return (DEF_NULL);
   2517              }
   2518          #else
   2519              (void)p_name;
   2520          #endif
   2521              CPU_CRITICAL_EXIT();
   \                     ??Mem_SegAllocInternal_0: (+1)
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005A   0x4658             MOV      R0,R11
   \   0000005C   0x.... 0x....      BL       CPU_SR_Restore
   2522          
   2523              return (p_blk);
   \   00000060   0x9802             LDR      R0,[SP, #+8]
   \                     ??Mem_SegAllocInternal_1: (+1)
   \   00000062   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2524          }
   2525          
   2526          
   2527          /*
   2528          *********************************************************************************************************
   2529          *                                      Mem_SegAllocExtCritical()
   2530          *
   2531          * Description : Allocates memory from specified segment.
   2532          *
   2533          * Argument(s) : p_seg           Pointer to segment from which to allocate memory.
   2534          *
   2535          *               size            Size of memory block to allocate, in bytes.
   2536          *
   2537          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2538          *
   2539          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
   2540          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2541          *                               means no padding.
   2542          *
   2543          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   2544          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   2545          *
   2546          *               p_err           Pointer to variable that will receive the return error code from this function :
   2547          *
   2548          *                                   LIB_MEM_ERR_SEG_OVF     Allocation would overflow memory segment.
   2549          *
   2550          * Return(s)   : Pointer to allocated memory block, if successful.
   2551          *
   2552          *               DEF_NULL, otherwise.
   2553          *
   2554          * Caller(s)   : Mem_PoolCreate(),
   2555          *               Mem_SegAllocInternal(),
   2556          *               Mem_SegAllocTrackCritical().
   2557          *
   2558          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2559          *********************************************************************************************************
   2560          */
   2561          

   \                                 In section .text, align 2, keep-with-next
   2562          static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
   2563                                                  CPU_SIZE_T   size,
   2564                                                  CPU_SIZE_T   align,
   2565                                                  CPU_SIZE_T   padding_align,
   2566                                                  CPU_SIZE_T  *p_bytes_reqd,
   2567                                                  LIB_ERR     *p_err)
   2568          {
   \                     Mem_SegAllocExtCritical: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x9D08             LDR      R5,[SP, #+32]
   \   00000008   0x9E09             LDR      R6,[SP, #+36]
   2569              CPU_ADDR    blk_addr;
   2570              CPU_ADDR    addr_next;
   2571              CPU_SIZE_T  size_rem_seg;
   2572              CPU_SIZE_T  size_tot_blk;
   2573              CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
   \   0000000A   0x4293             CMP      R3,R2
   \   0000000C   0xD201             BCS.N    ??Mem_SegAllocExtCritical_0
   \   0000000E   0x4696             MOV      LR,R2
   \   00000010   0xE000             B.N      ??Mem_SegAllocExtCritical_1
   \                     ??Mem_SegAllocExtCritical_0: (+1)
   \   00000012   0x469E             MOV      LR,R3
   2574          
   2575          
   2576              blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
   2577                                                    blk_align);
   \                     ??Mem_SegAllocExtCritical_1: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0xF1BE 0x0A01      SUBS     R10,LR,#+1
   \   0000001A   0xEA10 0x0F0A      TST      R0,R10
   \   0000001E   0xD101             BNE.N    ??Mem_SegAllocExtCritical_2
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE000             B.N      ??Mem_SegAllocExtCritical_3
   \                     ??Mem_SegAllocExtCritical_2: (+1)
   \   00000024   0x4670             MOV      R0,LR
   \                     ??Mem_SegAllocExtCritical_3: (+1)
   \   00000026   0xF8D4 0x8008      LDR      R8,[R4, #+8]
   \   0000002A   0xF1BE 0x0A01      SUBS     R10,LR,#+1
   \   0000002E   0xEA38 0x080A      BICS     R8,R8,R10
   \   00000032   0xEB10 0x0808      ADDS     R8,R0,R8
   2578              addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
   2579                                                    padding_align);
   \   00000036   0xEB11 0x0008      ADDS     R0,R1,R8
   \   0000003A   0xF1B3 0x0A01      SUBS     R10,R3,#+1
   \   0000003E   0xEA10 0x0F0A      TST      R0,R10
   \   00000042   0xD101             BNE.N    ??Mem_SegAllocExtCritical_4
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE000             B.N      ??Mem_SegAllocExtCritical_5
   \                     ??Mem_SegAllocExtCritical_4: (+1)
   \   00000048   0x0018             MOVS     R0,R3
   \                     ??Mem_SegAllocExtCritical_5: (+1)
   \   0000004A   0xEB11 0x0908      ADDS     R9,R1,R8
   \   0000004E   0xF1B3 0x0A01      SUBS     R10,R3,#+1
   \   00000052   0xEA39 0x090A      BICS     R9,R9,R10
   \   00000056   0xEB10 0x0909      ADDS     R9,R0,R9
   2580              size_rem_seg = (p_seg->AddrEnd - p_seg->AddrNext) + 1u;
   \   0000005A   0x6860             LDR      R0,[R4, #+4]
   \   0000005C   0xF8D4 0xA008      LDR      R10,[R4, #+8]
   \   00000060   0xEBB0 0x000A      SUBS     R0,R0,R10
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0x0007             MOVS     R7,R0
   2581              size_tot_blk =  addr_next      - p_seg->AddrNext;           /* Compute tot blk size including align and padding.    */
   \   00000068   0x68A0             LDR      R0,[R4, #+8]
   \   0000006A   0xEBB9 0x0000      SUBS     R0,R9,R0
   \   0000006E   0x4684             MOV      R12,R0
   2582              if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
   \   00000070   0x4567             CMP      R7,R12
   \   00000072   0xD209             BCS.N    ??Mem_SegAllocExtCritical_6
   2583                  if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD002             BEQ.N    ??Mem_SegAllocExtCritical_7
   2584                     *p_bytes_reqd = size_tot_blk - size_rem_seg;
   \   00000078   0xEBBC 0x0007      SUBS     R0,R12,R7
   \   0000007C   0x6028             STR      R0,[R5, #+0]
   2585                  }
   2586          
   2587                 *p_err = LIB_MEM_ERR_SEG_OVF;
   \                     ??Mem_SegAllocExtCritical_7: (+1)
   \   0000007E   0xF242 0x70D9      MOVW     R0,#+10201
   \   00000082   0x8030             STRH     R0,[R6, #+0]
   2588                  return (DEF_NULL);
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE005             B.N      ??Mem_SegAllocExtCritical_8
   2589              }
   2590          
   2591              p_seg->AddrNext = addr_next;
   \                     ??Mem_SegAllocExtCritical_6: (+1)
   \   00000088   0xF8C4 0x9008      STR      R9,[R4, #+8]
   2592          
   2593             *p_err = LIB_MEM_ERR_NONE;
   \   0000008C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000090   0x8030             STRH     R0,[R6, #+0]
   2594          
   2595              return ((void *)blk_addr);
   \   00000092   0x4640             MOV      R0,R8
   \                     ??Mem_SegAllocExtCritical_8: (+1)
   \   00000094   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2596          }
   2597          
   2598          
   2599          /*
   2600          *********************************************************************************************************
   2601          *                                     Mem_SegAllocTrackCritical()
   2602          *
   2603          * Description : Tracks segment allocation, adding the 'size' of the allocation under the 'p_name' entry.
   2604          *
   2605          * Argument(s) : p_name  Pointer to the name of the object. This string is not copied and its memory should
   2606          *                       remain accessible at all times.
   2607          *
   2608          *               p_seg   Pointer to segment data.
   2609          *
   2610          *               size    Allocation size, in bytes.
   2611          *
   2612          *               p_err   Pointer to variable that will receive the return error code from this function :
   2613          *
   2614          *                           LIB_MEM_ERR_HEAP_EMPTY      No more memory available on heap
   2615          *
   2616          *                           --------------RETURNED BY Mem_SegAllocExtCritical()---------------
   2617          *                           LIB_MEM_ERR_SEG_OVF         Allocation would overflow memory segment.
   2618          *
   2619          * Return(s)   : none.
   2620          *
   2621          * Caller(s)   : Mem_PoolCreate(),
   2622          *               Mem_SegAllocInternal().
   2623          *
   2624          * Note(s)     : none.
   2625          *********************************************************************************************************
   2626          */
   2627          
   2628          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2629          static  void  Mem_SegAllocTrackCritical (const  CPU_CHAR    *p_name,
   2630                                                          MEM_SEG     *p_seg,
   2631                                                          CPU_SIZE_T   size,
   2632                                                          LIB_ERR     *p_err)
   2633          {
   2634              MEM_ALLOC_INFO  *p_alloc;
   2635          
   2636          
   2637                                                                          /* ------- UPDATE ALLOC INFO LIST, IF POSSIBLE -------- */
   2638              p_alloc = p_seg->AllocInfoHeadPtr;
   2639              while (p_alloc != DEF_NULL) {
   2640                  if (p_alloc->NamePtr == p_name) {
   2641                      p_alloc->Size += size;
   2642                     *p_err = LIB_MEM_ERR_NONE;
   2643                      return;
   2644                  }
   2645          
   2646                  p_alloc = p_alloc->NextPtr;
   2647              }
   2648          
   2649                                                                          /* --------- ADD NEW ALLOC INFO ENTRY IN LIST --------- */
   2650              p_alloc = (MEM_ALLOC_INFO *)Mem_SegAllocExtCritical(&Mem_SegHeap,             /* Alloc new alloc info struct on heap.                 */
   2651                                                                   sizeof(MEM_ALLOC_INFO),
   2652                                                                   sizeof(CPU_ALIGN),
   2653                                                                   LIB_MEM_PADDING_ALIGN_NONE,
   2654                                                                   DEF_NULL,
   2655                                                                   p_err);
   2656              if (*p_err != LIB_MEM_ERR_NONE) {
   2657                  return;
   2658              }
   2659          
   2660              p_alloc->NamePtr = p_name;                                  /* Populate alloc info.                                 */
   2661              p_alloc->Size    = size;
   2662          
   2663              p_alloc->NextPtr        = p_seg->AllocInfoHeadPtr;          /* Prepend new item in list.                            */
   2664              p_seg->AllocInfoHeadPtr = p_alloc;
   2665          }
   2666          #endif
   2667          
   2668          
   2669          /*
   2670          *********************************************************************************************************
   2671          *                                     Mem_DynPoolCreateInternal()
   2672          *
   2673          * Description : Creates a dynamic memory pool.
   2674          *
   2675          * Argument(s) : p_name              Pointer to pool name.
   2676          *
   2677          *               p_pool              Pointer to pool data.
   2678          *
   2679          *               p_seg               Pointer to segment from which to allocate memory.
   2680          *
   2681          *               blk_size            Size of memory block to allocate from pool, in bytes. See Note #1.
   2682          *
   2683          *               blk_align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2684          *
   2685          *               blk_padding_align   Block's padding alignment, in bytes, that will be added at the end
   2686          *                                   of block's buffer. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2687          *                                   means no padding.
   2688          *
   2689          *               blk_qty_init        Initial number of elements to be allocated in pool.
   2690          *
   2691          *               blk_qty_max         Maximum number of elements that can be allocated from this pool. Set to
   2692          *                                   LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   2693          *
   2694          *               p_err           Pointer to variable that will receive the return error code from this function :
   2695          *
   2696          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
   2697          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
   2698          *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
   2699          *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
   2700          *
   2701          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   2702          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   2703          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   2704          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   2705          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   2706          *
   2707          * Return(s)   : None.
   2708          *
   2709          * Caller(s)   : Mem_DynPoolCreate(),
   2710          *               Mem_DynPoolCreateHW().
   2711          *
   2712          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   2713          *                   block is stored in the block itself (only when free/unused).
   2714          *********************************************************************************************************
   2715          */
   2716          

   \                                 In section .text, align 2, keep-with-next
   2717          static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
   2718                                                          MEM_DYN_POOL  *p_pool,
   2719                                                          MEM_SEG       *p_seg,
   2720                                                          CPU_SIZE_T     blk_size,
   2721                                                          CPU_SIZE_T     blk_align,
   2722                                                          CPU_SIZE_T     blk_padding_align,
   2723                                                          CPU_SIZE_T     blk_qty_init,
   2724                                                          CPU_SIZE_T     blk_qty_max,
   2725                                                          LIB_ERR       *p_err)
   2726          {
   \                     Mem_DynPoolCreateInternal: (+1)
   \   00000000   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x001D             MOVS     R5,R3
   \   0000000A   0x9E0E             LDR      R6,[SP, #+56]
   \   0000000C   0x9F10             LDR      R7,[SP, #+64]
   2727              CPU_INT08U  *p_blks          = DEF_NULL;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
   2728              CPU_SIZE_T   blk_size_align;
   2729              CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
   \   00000012   0x980F             LDR      R0,[SP, #+60]
   \   00000014   0x42B0             CMP      R0,R6
   \   00000016   0xD201             BCS.N    ??Mem_DynPoolCreateInternal_0
   \   00000018   0x46B1             MOV      R9,R6
   \   0000001A   0xE001             B.N      ??Mem_DynPoolCreateInternal_1
   \                     ??Mem_DynPoolCreateInternal_0: (+1)
   \   0000001C   0xF8DD 0x903C      LDR      R9,[SP, #+60]
   2730          
   2731          
   2732          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2733              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2734                  CPU_SW_EXCEPTION(;);
   2735              }
   2736          
   2737              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   2738                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2739                  return;
   2740              }
   2741          
   2742              if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
   2743                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   2744                  return;
   2745              }
   2746          
   2747              if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
   2748                  (blk_qty_init >  blk_qty_max)) {
   2749                 *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
   2750                  return;
   2751              }
   2752          
   2753              if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
   2754                 *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   2755                  return;
   2756              }
   2757          #endif
   2758          
   2759                                                                          /* Calc blk size with align.                            */
   2760              if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
   \                     ??Mem_DynPoolCreateInternal_1: (+1)
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD20E             BCS.N    ??Mem_DynPoolCreateInternal_2
   2761                                                                          /* ... inc size to ptr size.                            */
   2762                  blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
   \   00000024   0xF1B9 0x0001      SUBS     R0,R9,#+1
   \   00000028   0x0740             LSLS     R0,R0,#+29
   \   0000002A   0xD401             BMI.N    ??Mem_DynPoolCreateInternal_3
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE000             B.N      ??Mem_DynPoolCreateInternal_4
   \                     ??Mem_DynPoolCreateInternal_3: (+1)
   \   00000030   0x4648             MOV      R0,R9
   \                     ??Mem_DynPoolCreateInternal_4: (+1)
   \   00000032   0xF1B9 0x0101      SUBS     R1,R9,#+1
   \   00000036   0x43C9             MVNS     R1,R1
   \   00000038   0xF011 0x0104      ANDS     R1,R1,#0x4
   \   0000003C   0xEB10 0x0A01      ADDS     R10,R0,R1
   \   00000040   0xE00C             B.N      ??Mem_DynPoolCreateInternal_5
   2763              } else {
   2764                  blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
   \                     ??Mem_DynPoolCreateInternal_2: (+1)
   \   00000042   0xF1B9 0x0001      SUBS     R0,R9,#+1
   \   00000046   0x4205             TST      R5,R0
   \   00000048   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_6
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE000             B.N      ??Mem_DynPoolCreateInternal_7
   \                     ??Mem_DynPoolCreateInternal_6: (+1)
   \   0000004E   0x4648             MOV      R0,R9
   \                     ??Mem_DynPoolCreateInternal_7: (+1)
   \   00000050   0xF1B9 0x0101      SUBS     R1,R9,#+1
   \   00000054   0xEA35 0x0101      BICS     R1,R5,R1
   \   00000058   0xEB10 0x0A01      ADDS     R10,R0,R1
   2765              }
   2766          
   2767              if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
   \                     ??Mem_DynPoolCreateInternal_5: (+1)
   \   0000005C   0x2F00             CMP      R7,#+0
   \   0000005E   0xD02C             BEQ.N    ??Mem_DynPoolCreateInternal_8
   2768                  CPU_SIZE_T  i;
   2769                  p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
   2770                                                              p_seg,
   2771                                                              blk_size_align * blk_qty_init,
   2772                                                              DEF_MAX(blk_align, sizeof(void *)),
   2773                                                              LIB_MEM_PADDING_ALIGN_NONE,
   2774                                                              DEF_NULL,
   2775                                                              p_err);
   \   00000060   0x2E05             CMP      R6,#+5
   \   00000062   0xD301             BCC.N    ??Mem_DynPoolCreateInternal_9
   \   00000064   0x0033             MOVS     R3,R6
   \   00000066   0xE000             B.N      ??Mem_DynPoolCreateInternal_10
   \                     ??Mem_DynPoolCreateInternal_9: (+1)
   \   00000068   0x2304             MOVS     R3,#+4
   \                     ??Mem_DynPoolCreateInternal_10: (+1)
   \   0000006A   0x9812             LDR      R0,[SP, #+72]
   \   0000006C   0x9002             STR      R0,[SP, #+8]
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0xFB07 0xF20A      MUL      R2,R7,R10
   \   0000007A   0x9904             LDR      R1,[SP, #+16]
   \   0000007C   0x9803             LDR      R0,[SP, #+12]
   \   0000007E   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000082   0x4680             MOV      R8,R0
   2776                  if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000084   0x9812             LDR      R0,[SP, #+72]
   \   00000086   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000008A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD129             BNE.N    ??Mem_DynPoolCreateInternal_11
   2777                      return;
   2778                  }
   2779          
   2780                                                                          /* ----------------- CREATE POOL DATA ----------------- */
   2781                                                                          /* Init free list.                                      */
   2782                  p_pool->BlkFreePtr = (void *)p_blks;
   \                     ??Mem_DynPoolCreateInternal_12: (+1)
   \   00000092   0xF8C4 0x8010      STR      R8,[R4, #+16]
   2783                  for (i = 0u; i < blk_qty_init - 1u; i++) {
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x4683             MOV      R11,R0
   \                     ??Mem_DynPoolCreateInternal_13: (+1)
   \   0000009A   0x1E78             SUBS     R0,R7,#+1
   \   0000009C   0x4583             CMP      R11,R0
   \   0000009E   0xD208             BCS.N    ??Mem_DynPoolCreateInternal_14
   2784                     *((void **)p_blks)  = p_blks + blk_size_align;
   \   000000A0   0xEB1A 0x0008      ADDS     R0,R10,R8
   \   000000A4   0xF8C8 0x0000      STR      R0,[R8, #+0]
   2785                      p_blks            += blk_size_align;
   \   000000A8   0xEB1A 0x0808      ADDS     R8,R10,R8
   2786                  }
   \   000000AC   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000B0   0xE7F3             B.N      ??Mem_DynPoolCreateInternal_13
   2787                 *((void **)p_blks) = DEF_NULL;
   \                     ??Mem_DynPoolCreateInternal_14: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   000000B8   0xE001             B.N      ??Mem_DynPoolCreateInternal_15
   2788              } else {
   2789                  p_pool->BlkFreePtr = DEF_NULL;
   \                     ??Mem_DynPoolCreateInternal_8: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x6120             STR      R0,[R4, #+16]
   2790              }
   2791          
   2792          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   2793              p_pool->PoolSegPtr      = ((p_seg != DEF_NULL) ? p_seg : &Mem_SegHeap);
   \                     ??Mem_DynPoolCreateInternal_15: (+1)
   \   000000BE   0x9804             LDR      R0,[SP, #+16]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD001             BEQ.N    ??Mem_DynPoolCreateInternal_16
   \   000000C4   0x9804             LDR      R0,[SP, #+16]
   \   000000C6   0xE000             B.N      ??Mem_DynPoolCreateInternal_17
   \                     ??Mem_DynPoolCreateInternal_16: (+1)
   \   000000C8   0x....             LDR.N    R0,??DataTable12_2
   \                     ??Mem_DynPoolCreateInternal_17: (+1)
   \   000000CA   0x6020             STR      R0,[R4, #+0]
   2794          #else
   2795              p_pool->PoolSegPtr      =   p_seg;
   2796          #endif
   2797              p_pool->BlkSize         =   blk_size;
   \   000000CC   0x6065             STR      R5,[R4, #+4]
   2798              p_pool->BlkAlign        =   blk_align_worst;
   \   000000CE   0xF8C4 0x9008      STR      R9,[R4, #+8]
   2799              p_pool->BlkPaddingAlign =   blk_padding_align;
   \   000000D2   0x980F             LDR      R0,[SP, #+60]
   \   000000D4   0x60E0             STR      R0,[R4, #+12]
   2800              p_pool->BlkQtyMax       =   blk_qty_max;
   \   000000D6   0x9811             LDR      R0,[SP, #+68]
   \   000000D8   0x6160             STR      R0,[R4, #+20]
   2801              p_pool->BlkAllocCnt     =   0u;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x61A0             STR      R0,[R4, #+24]
   2802          
   2803          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2804              p_pool->NamePtr = p_name;
   2805          #endif
   2806          
   2807             *p_err = LIB_MEM_ERR_NONE;
   \   000000DE   0xF242 0x7010      MOVW     R0,#+10000
   \   000000E2   0x9912             LDR      R1,[SP, #+72]
   \   000000E4   0x8008             STRH     R0,[R1, #+0]
   2808          }
   \                     ??Mem_DynPoolCreateInternal_11: (+1)
   \   000000E6   0xB005             ADD      SP,SP,#+20
   \   000000E8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     Mem_SegHeadPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     Mem_Heap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     Mem_SegHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x48 0x65          DC8 "Heap"
   \              0x61 0x70    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x55 0x6E          DC8 "Unnamed static pool"
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x69 0x63    
   \              0x20 0x70    
   \              0x6F 0x6F    
   \              0x6C 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x55 0x6E          DC8 "Unnamed static pool free blk tbl"
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x69 0x63    
   \              0x20 0x70    
   \              0x6F 0x6F    
   \              0x6C 0x20    
   \              0x66 0x72    
   \              0x65 0x65    
   \              0x20 0x62    
   \              0x6C 0x6B    
   \              0x20 0x74    
   \              0x62 0x6C    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2809          
   2810          
   2811          /*
   2812          *********************************************************************************************************
   2813          *                                      Mem_PoolBlkIsValidAddr()
   2814          *
   2815          * Description : Calculates if a given memory block address is valid for the memory pool.
   2816          *
   2817          * Argument(s) : p_pool   Pointer to memory pool structure to validate memory block address.
   2818          *               ------   Argument validated by caller.
   2819          *
   2820          *               p_mem    Pointer to memory block address to validate.
   2821          *               -----    Argument validated by caller.
   2822          *
   2823          * Return(s)   : DEF_YES, if valid memory pool block address.
   2824          *
   2825          *               DEF_NO,  otherwise.
   2826          *
   2827          * Caller(s)   : Mem_PoolBlkFree().
   2828          *
   2829          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   2830          *********************************************************************************************************
   2831          */
   2832          
   2833          #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
   2834               (LIB_MEM_CFG_HEAP_SIZE      >  0u))
   2835          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *p_pool,
   2836                                                       void      *p_mem)
   2837          {
   2838              CPU_ADDR  pool_offset;
   2839          
   2840          
   2841              if ((p_mem < p_pool->PoolAddrStart) ||
   2842                  (p_mem > p_pool->PoolAddrEnd)) {
   2843                  return (DEF_FALSE);
   2844              }
   2845          
   2846              pool_offset = (CPU_ADDR)p_mem - (CPU_ADDR)p_pool->PoolAddrStart;
   2847              if (pool_offset % p_pool->BlkSize != 0u) {
   2848                  return (DEF_FALSE);
   2849              } else {
   2850                  return (DEF_TRUE);
   2851              }
   2852          }
   2853          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Mem_Clr
        16   -> Mem_Set
      40   Mem_Cmp
      24   Mem_DynPoolBlkFree
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      40   Mem_DynPoolBlkGet
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> Mem_SegAllocInternal
      24   Mem_DynPoolBlkNbrAvailGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      56   Mem_DynPoolCreate
        56   -> Mem_DynPoolCreateInternal
      56   Mem_DynPoolCreateHW
        56   -> Mem_DynPoolCreateInternal
      56   Mem_DynPoolCreateInternal
        56   -> Mem_SegAllocInternal
      40   Mem_HeapAlloc
        40   -> Mem_SegAllocInternal
      16   Mem_HeapGetSizeRem
        16   -> Mem_SegRemSizeGet
      24   Mem_Init
        24   -> CPU_SW_Exception
        24   -> Mem_SegCreate
      56   Mem_Move
        56   -> Mem_Copy
      24   Mem_PoolBlkFree
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   Mem_PoolBlkGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   Mem_PoolBlkGetNbrAvail
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   Mem_PoolClr
      72   Mem_PoolCreate
        72   -> CPU_IntDisMeasStart
        72   -> CPU_IntDisMeasStop
        72   -> CPU_SR_Restore
        72   -> CPU_SR_Save
        72   -> Mem_PoolClr
        72   -> Mem_SegAllocExtCritical
        72   -> Mem_SegAllocInternal
        72   -> Mem_SegCreateCritical
        72   -> Mem_SegOverlapChkCritical
      40   Mem_SegAlloc
        40   -> Mem_SegAllocInternal
      48   Mem_SegAllocExt
        48   -> Mem_SegAllocInternal
      32   Mem_SegAllocExtCritical
      48   Mem_SegAllocHW
        48   -> Mem_SegAllocInternal
      48   Mem_SegAllocInternal
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Mem_SegAllocExtCritical
      16   Mem_SegClr
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      40   Mem_SegCreate
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> Mem_SegCreateCritical
       8   Mem_SegCreateCritical
      16   Mem_SegOverlapChkCritical
      40   Mem_SegRemSizeGet
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
      24   Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       8  ?_0
      20  ?_1
      36  ?_2
      18  Mem_Clr
     258  Mem_Cmp
     100  Mem_DynPoolBlkFree
     180  Mem_DynPoolBlkGet
      64  Mem_DynPoolBlkNbrAvailGet
      78  Mem_DynPoolCreate
      78  Mem_DynPoolCreateHW
     236  Mem_DynPoolCreateInternal
    1024  Mem_Heap
      64  Mem_HeapAlloc
      42  Mem_HeapGetSizeRem
      62  Mem_Init
     232  Mem_Move
      78  Mem_PoolBlkFree
      94  Mem_PoolBlkGet
      42  Mem_PoolBlkGetNbrAvail
      32  Mem_PoolClr
     348  Mem_PoolCreate
      56  Mem_SegAlloc
      66  Mem_SegAllocExt
     152  Mem_SegAllocExtCritical
      66  Mem_SegAllocHW
     102  Mem_SegAllocInternal
      40  Mem_SegClr
      72  Mem_SegCreate
      30  Mem_SegCreateCritical
       4  Mem_SegHeadPtr
      20  Mem_SegHeap
      88  Mem_SegOverlapChkCritical
     146  Mem_SegRemSizeGet
     116  Mem_Set

 
 1 048 bytes in section .bss
    64 bytes in section .rodata
 2 964 bytes in section .text
 
 2 964 bytes of CODE  memory
    64 bytes of CONST memory
 1 048 bytes of DATA  memory

Errors: none
Warnings: none

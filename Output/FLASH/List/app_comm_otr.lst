###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Dec/2017  08:42:36
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320 IC卡模块\Software\APP\comm\app_comm_otr.c
#    Command line =  
#        "F:\iar\NC136B-320 IC卡模块\Software\APP\comm\app_comm_otr.c" -D
#        RELEASE -lCN "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\app_comm_otr.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\app_comm_otr.o
#
###############################################################################

F:\iar\NC136B-320 IC卡模块\Software\APP\comm\app_comm_otr.c
      1          /*******************************************************************************
      2          *   Filename:       app_comm_otr.c
      3          *   Revised:        All copyrights reserved to redmorningcn.
      4          *   Revision:       v1.0
      5          *   Writer:	     redmorningcn.
      6          *
      7          *   Description:    双击选中 otr 按 Ctrl + H, 钩选 Match the case, Replace with
      8          *                   输入您要的名字，点击 Replace All
      9          *                   双击选中 Otr 按 Ctrl + H, 钩选 Match the case, Replace with
     10          *                   输入您要的名字，点击 Replace All
     11          *                   双击选中 OTR 按 Ctrl + H, 钩选 Match the case, Replace with
     12          *                   输入您要的名字，点击 Replace All
     13          *                   在 app_cfg.h 中指定本任务的 优先级  （ APP_TASK_COMM_PRIO     ）
     14          *                                            和 任务堆栈（ APP_TASK_COMM_STK_SIZE ）大小
     15          *
     16          *   Notes:
     17          *     				E-mail: redmorningcn@qq.com
     18          *
     19          *******************************************************************************/
     20          
     21          /*******************************************************************************
     22          * INCLUDES
     23          */
     24          #define  SNL_APP_SOURCE
     25          #include <includes.h>
     26          #include <app_comm_protocol.h>
     27          #include <app_ctrl.h>
     28          #include <app.h>
     29          #include <os_cfg_app.h>
     30          #include <RecDataTypeDef.h>
     31          
     32          
     33          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     34          const  CPU_CHAR  *app_comm_otr__c = "$Id: $";
     35          #endif
     36          
     37          #define APP_TASK_COMM_EN     DEF_ENABLED
     38          #if APP_TASK_COMM_EN == DEF_ENABLED
     39          /*******************************************************************************
     40          * CONSTANTS
     41          */
     42          
     43          /*******************************************************************************
     44          * MACROS
     45          */
     46          #define CYCLE_TIME_TICKS            (OS_TICKS_PER_SEC * 1)
     47          
     48          /*******************************************************************************
     49          * TYPEDEFS
     50          */
     51          #define		DATA_CARD           0x00000001			//数据卡------暂时未用
     52          #define		CALC_MODEL_CARD     0x00000002			//计算模型卡--暂时未用
     53          #define		IAP_CARD            0x00000004			//IAP升级-----暂时未用
     54          
     55          #define		DENSITY_CARD		0x00000020			//密度卡
     56          #define		MODEL_CARD			0x00000040			//模型卡-----暂时未用
     57          #define		TIME_CARD           0x00000100			//时间卡-----
     58          #define		COM_MODEL_CARD	    0x00000100		    //串口模型卡-暂时未用
     59          #define		HIGHT_CARD			0x00000200			//高度卡-----
     60          #define		COPY_CARD           0x00000400			//复制卡-----暂时未用
     61          #define		MODEL_SELECT_CARD	0x00001000			//模型选择卡-
     62          #define		FIX_CARD            0x00002000			//装车卡-----
     63          #define		COPY_FRAM_CARD	    0x00004000			//铁电复制卡-暂时未用
     64          #define		SET_DATA_CARD		0x00000080			//置数卡-----按时未用
     65          #define		DEBUG_CARD			0x00000800			//调试卡-----暂时未用
     66          
     67          #define		EXPAND_CARD			0x00008000			//扩展卡-----暂时未用
     68          
     69          #define		DATA_CARD_ERR		0x00008000			//IC卡错误
     70          
     71          #define		DATA_CARD_DIS		0x00010000			//数据卡指示
     72          #define		DATA_CARD_FIN		0x00020000			//数据卡结束
     73          #define		SYS_RUN_PARA		0x00040000			//系统参数卡--暂未使用
     74          #define		CLEAR_ALL			0x00080000			//清零卡，数据记录清零
     75          
     76          #define		RST_SYS				0x00100000		    //复位指令
     77          #define		CALC_PARA           0x00200000		    //计算斜率
     78          
     79          /*******************************************************************************
     80          * LOCAL VARIABLES
     81          */
     82          
     83          /*******************************************************************************
     84          * GLOBAL VARIABLES
     85          */
     86          
     87          /***********************************************
     88          * 描述： 软定时器声明
     89          */
     90          
     91          /***********************************************
     92          * 描述： 软定时器回调函数
     93          */
     94          
     95          
     96          /*******************************************************************************
     97          * LOCAL FUNCTIONS
     98          */
     99          
    100          
    101          /*******************************************************************************
    102          * GLOBAL FUNCTIONS
    103          */
    104          
    105          /*******************************************************************************
    106          * EXTERN VARIABLES
    107          */
    108          
    109          /*******************************************************************************
    110          * EXTERN FUNCTIONS
    111          */
    112          uint8   FRAM_StoreRecNumMgr(StrRecNumMgr  *SRecNumMgr);
    113          uint8   FRAM_StoreOilPara(StrOilPara  *SOilPara);
    114          void    BSP_DispClrAll(void);
    115          uint8   FRAM_StoreProductInfo(StrProductInfo  *sProductInfo);
    116          void    comm_para_flow(StrDevOtr * sDtu,uint8 addrnum);
    117          uint8 	ReadFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen);            
    118          uint32  GetRecNumAddr(uint32 FlshRecNum);
    119          INT8U	WriteFlsh(INT32U Dst, uint8 * sFlshRec, INT32U NByte);
    120          
    121          
    122          /*******************************************************************************/

   \                                 In section .bss, align 4
    123          stcModelCard            m_sModelCard;
   \                     m_sModelCard:
   \   00000000                      DS8 5956
    124          
    125          /*******************************************************************************
    126          * 名    称： DataComReadAsk
    127          * 功    能： IC卡请求数据记录。
    128          			 开始数据记录号和结束数据记录号。
    129          * 入口参数： 
    130          * 出口参数： 无
    131          * 作　  者： redmorningcn.
    132          * 创建日期： 2017-05-31
    133          * 修    改：
    134          * 修改日期：
    135          * 备    注： 任务创建函数需要在app.h文件中声明
    136          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    137          void DataComReadAsk(unsigned int startnum,unsigned int endnum)
    138          {
   \                     DataComReadAsk: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    139          	Ctrl.Otr.Wr.Code = DATA_CARD;						//数据类型
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000000C   0xF8C1 0x015C      STR      R0,[R1, #+348]
    140          	Ctrl.Otr.Wr.Info.sReqRec.StartNum 	= startnum;		//开始记录
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000014   0xF8C0 0x4160      STR      R4,[R0, #+352]
    141          	Ctrl.Otr.Wr.Info.sReqRec.EndNum	= endnum;		//结束记录
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000001C   0xF8C0 0x5164      STR      R5,[R0, #+356]
    142          	
    143          	CSNC_SendData(	Ctrl.Otr.pch,						//通讯控制块
    144                            SLAVE_ADDR_OTR,						//源地址
    145                            MASTE_ADDR_HOST,					    //目标地址
    146                            Ctrl.Otr.ConnCtrl[0].SendFramNum,	//发送帧号
    147                            0,									//帧类型，默认为0，在数据区内明确		
    148                            (uint8 *)&Ctrl.Otr.Wr,				//发送缓冲区
    149                            //发送数据区长度
    150                            sizeof(Ctrl.Otr.Wr.Code)+sizeof(Ctrl.Otr.Wr.Info.sReqRec));
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0x9002             STR      R0,[SP, #+8]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000032   0xF890 0x320E      LDRB     R3,[R0, #+526]
   \   00000036   0x2280             MOVS     R2,#+128
   \   00000038   0x21C1             MOVS     R1,#+193
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000003E   0xF8D0 0x0218      LDR      R0,[R0, #+536]
   \   00000042   0x.... 0x....      BL       CSNC_SendData
    151          }
   \   00000046   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    152          
    153          
    154          /*******************************************************************************
    155          * 名    称： 取机车信息
    156          * 功    能： 
    157          * 入口参数： 
    158          * 出口参数： 无
    159          * 作　  者： redmorningcn.
    160          * 创建日期： 2017-12-06
    161          * 修    改：
    162          * 修改日期：
    163          * 备    注： 任务创建函数需要在app.h文件中声明
    164          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    165          uint8  	JudegLocoInfo(uint8   buf[])
    166          {
   \                     JudegLocoInfo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    167              uint16  crc16;
    168              stcFlshRec	*psRec;						    //数据记录     128 	
    169              psRec       = (stcFlshRec	*)buf;
   \   00000004   0x0026             MOVS     R6,R4
    170              
    171              crc16 = GetCrc16Check(buf,sizeof(stcFlshRec)-2);
   \   00000006   0x217E             MOVS     R1,#+126
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       GetCrc16Check
   \   0000000E   0x0005             MOVS     R5,R0
    172              
    173              if(crc16 == psRec->CrcCheck){               //校验正确
   \   00000010   0xF8B6 0x007E      LDRH     R0,[R6, #+126]
   \   00000014   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD133             BNE.N    ??JudegLocoInfo_0
    174                  //机车信息错误，
    175                  if(     psRec->JcRealType   != 0xffff 
    176                     &&   psRec->JcRealNo     != 0xffff
    177                         &&    psRec->JcRealType  != 0 
    178                             &&   psRec->JcRealNo     != 0    ){
   \   0000001A   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   0000001E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD02D             BEQ.N    ??JudegLocoInfo_0
   \   00000026   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   0000002A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD027             BEQ.N    ??JudegLocoInfo_0
   \   00000032   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD023             BEQ.N    ??JudegLocoInfo_0
   \   0000003A   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD01F             BEQ.N    ??JudegLocoInfo_0
    179                                 
    180                                 if(psRec->JcRealType   == Ctrl.sProductInfo.sLocoId.Type
    181                                     &&psRec->JcRealNo     == Ctrl.sProductInfo.sLocoId.Num){
   \   00000042   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000004A   0x8B89             LDRH     R1,[R1, #+28]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD108             BNE.N    ??JudegLocoInfo_1
   \   00000050   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000058   0x8BC9             LDRH     R1,[R1, #+30]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??JudegLocoInfo_1
    182                                         return 1;                       //机车信息正确
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE010             B.N      ??JudegLocoInfo_2
    183                                     }
    184                                 
    185                                 Ctrl.sProductInfo.sLocoId.Type = psRec->JcRealType ; 
   \                     ??JudegLocoInfo_1: (+1)
   \   00000062   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000006A   0x8388             STRH     R0,[R1, #+28]
    186                                 Ctrl.sProductInfo.sLocoId.Num  = psRec->JcRealNo   ;
   \   0000006C   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000074   0x83C8             STRH     R0,[R1, #+30]
    187                                 
    188                                 FRAM_StoreProductInfo((StrProductInfo  *)&Ctrl.sProductInfo);//存机车号
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   0000007A   0x.... 0x....      BL       FRAM_StoreProductInfo
    189                                 return 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??JudegLocoInfo_2
    190                             }
    191              }
    192              
    193              return 1;
   \                     ??JudegLocoInfo_0: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \                     ??JudegLocoInfo_2: (+1)
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    194          }
    195          
    196          //stcFlshRec  sFlshRecTmp;
    197          
    198          /*******************************************************************************
    199          * 名    称： comm_rec_read
    200          * 功    能： 读取数据记录
    201          * 入口参数： 
    202          * 出口参数： 无
    203          * 作　  者： redmorningcn.
    204          * 创建日期： 2017-05-26
    205          * 修    改：
    206          * 修改日期：
    207          * 备    注： 任务创建函数需要在app.h文件中声明
    208          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          void	comm_rec_read(StrDevOtr * sDtu,uint8 addrnum)
    210          {
   \                     comm_rec_read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    211              /***********************************************
    212              * 描述： 更具数据长度，判读接收的是否为数据记录。
    213              * 		 接收长度为128，数据记录；长度小于128,接收
    214              * 		 普通数据。
    215              */ 
    216          	static	    uint8	    errtimes = 0;
    217              static     uint8       recsmalltimes = 0;//接收到的记录号小
    218              static     uint8       recbigtimes = 0; //接收到的记录号大
    219              static     uint8       rectimes = 0;
    220          	
    221          	//数据记录长度128字节
    222          	if(Ctrl.Otr.RxCtrl.Len == sizeof(Ctrl.Otr.Rd.sRec)){
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000000A   0xF890 0x0203      LDRB     R0,[R0, #+515]
   \   0000000E   0x2880             CMP      R0,#+128
   \   00000010   0xF040 0x80DE      BNE.W    ??comm_rec_read_0
    223                  
    224                  //if ( Ctrl.sRunPara.DealFlag ) {
    225                  //    return;
    226                  //}
    227          		//存数据记录//如果接收到的数据记录和想要接收的相同，则保存数据。		
    228          		if(Ctrl.Otr.Rd.sRec.StoreCnt == Ctrl.sRecNumMgr.IcRead){
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000018   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000020   0x6889             LDR      R1,[R1, #+8]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD172             BNE.N    ??comm_rec_read_1
    229                      extern uint8 GetCardStatus(void);
    230          //            
    231          //            if ( 1 == GetCardStatus() ) {
    232          //                BSP_OS_SemPost(&Bsp_Card_Sem);
    233          //                return;
    234          //            } else 
    235          //            if ( 1== Ctrl.sRunPara.plugcard ) {
    236          //                BSP_OS_TimeDly(50);
    237          //            }
    238                      //保存数据记录
    239                      recsmalltimes   = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    240                      recbigtimes     = 0;    
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    241                                     
    242          			Ctrl.sRecNumMgr.IcRead++;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000042   0x6088             STR      R0,[R1, #+8]
    243                      //先应答再存储
    244          		  	uint32	FlshAddr = GetRecNumAddr(Ctrl.Otr.Rd.sRec.StoreCnt); 
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000048   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   0000004C   0x.... 0x....      BL       GetRecNumAddr
   \   00000050   0x0006             MOVS     R6,R0
    245                      //BSP_LED_Toggle(8);
    246          
    247          			WriteFlsh(FlshAddr, (uint8 *)&Ctrl.Otr.Rd.sRec, sizeof(stcFlshRec));
   \   00000052   0x2280             MOVS     R2,#+128
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   00000058   0x0030             MOVS     R0,R6
   \   0000005A   0x.... 0x....      BL       WriteFlsh
    248                      BSP_LED_Toggle(8);
   \   0000005E   0x2008             MOVS     R0,#+8
   \   00000060   0x.... 0x....      BL       BSP_LED_Toggle
    249                      osal_start_timerEx( OS_TASK_ID_LED,
    250                                         OS_EVT_LED_TICKS,
    251                                         200);
   \   00000064   0x22C8             MOVS     R2,#+200
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x2006             MOVS     R0,#+6
   \   0000006A   0x.... 0x....      BL       osal_start_timerEx
    252                      //存储器判断
    253                      ReadFlsh(FlshAddr, (uint8 *)&Ctrl.sRec, sizeof(stcFlshRec)); 
   \   0000006E   0x2280             MOVS     R2,#+128
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable4_6
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x.... 0x....      BL       ReadFlsh
    254                      
    255          			//如果还有数据未取完，继续请求数据。
    256          			if(Ctrl.sRecNumMgr.IcRead < Ctrl.sRecNumMgr.Current){	
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000007E   0x6880             LDR      R0,[R0, #+8]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000084   0x6849             LDR      R1,[R1, #+4]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD20D             BCS.N    ??comm_rec_read_2
    257          				errtimes = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   00000090   0x7008             STRB     R0,[R1, #+0]
    258          				DataComReadAsk(Ctrl.sRecNumMgr.IcRead,Ctrl.sRecNumMgr.IcRead +1);
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000096   0x6880             LDR      R0,[R0, #+8]
   \   00000098   0x1C41             ADDS     R1,R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000009E   0x6880             LDR      R0,[R0, #+8]
   \   000000A0   0x.... 0x....      BL       DataComReadAsk
   \   000000A4   0xE019             B.N      ??comm_rec_read_3
    259          				
    260          			}else if(Ctrl.sRecNumMgr.IcRead > Ctrl.sRecNumMgr.Current){
   \                     ??comm_rec_read_2: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable4
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000000B0   0x6889             LDR      R1,[R1, #+8]
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD211             BCS.N    ??comm_rec_read_3
    261          				errtimes++;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    262          				if(errtimes > 2)									//流水号异常。
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x2803             CMP      R0,#+3
   \   000000CC   0xDB05             BLT.N    ??comm_rec_read_3
    263          					Ctrl.sRecNumMgr.IcRead = Ctrl.sRecNumMgr.Current;
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable4
   \   000000D2   0x6840             LDR      R0,[R0, #+4]
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000000D8   0x6088             STR      R0,[R1, #+8]
    264          			}
    265                     
    266                      
    267          //            uint8 storetimes = 3;
    268          //            while((Ctrl.sRec.StoreCnt +1) != Ctrl.sRecNumMgr.IcRead && storetimes-- ) //如果数据存储异常，再次存储
    269          //            {
    270          //                Ctrl.sRec.StoreCnt = Ctrl.sRecNumMgr.IcRead -1;
    271          //                WriteFlsh(FlshAddr, (uint8 *)&Ctrl.Otr.Rd.sRec, sizeof(stcFlshRec));
    272          //            
    273          //                ReadFlsh(FlshAddr, (uint8 *)&Ctrl.sRec, sizeof(stcFlshRec));       //存储器判断
    274          //            }
    275                          
    276          //           //调整未读IC卡值
    277                      if(Ctrl.sRecNumMgr.IcRead != 0xffffffff && Ctrl.sRecNumMgr.CardRead > Ctrl.sRecNumMgr.IcRead){
   \                     ??comm_rec_read_3: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable4
   \   000000DE   0x6880             LDR      R0,[R0, #+8]
   \   000000E0   0xF110 0x0F01      CMN      R0,#+1
   \   000000E4   0xD00D             BEQ.N    ??comm_rec_read_4
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable4
   \   000000EA   0x6880             LDR      R0,[R0, #+8]
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000000F0   0x6909             LDR      R1,[R1, #+16]
   \   000000F2   0x4288             CMP      R0,R1
   \   000000F4   0xD205             BCS.N    ??comm_rec_read_4
    278                          Ctrl.sRecNumMgr.CardRead = Ctrl.sRecNumMgr.IcRead;
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable4
   \   000000FA   0x6880             LDR      R0,[R0, #+8]
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000100   0x6108             STR      R0,[R1, #+16]
    279                      }
    280          			FRAM_StoreRecNumMgr((StrRecNumMgr *)&Ctrl.sRecNumMgr);	//存流水号
   \                     ??comm_rec_read_4: (+1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   00000106   0x.... 0x....      BL       FRAM_StoreRecNumMgr
   \   0000010A   0xE09F             B.N      ??comm_rec_read_5
    281                      
    282          		} else  if(Ctrl.Otr.Rd.sRec.StoreCnt +1 == Ctrl.sRecNumMgr.Current) {//无最新记录，发前条数据，不处理
   \                     ??comm_rec_read_1: (+1)
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000110   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   00000114   0x1C40             ADDS     R0,R0,#+1
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000011A   0x6849             LDR      R1,[R1, #+4]
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xF000 0x8095      BEQ.W    ??comm_rec_read_5
    283                  
    284                  } else {
    285                  //if(Ctrl.Otr.Rd.sRec.StoreCnt < Ctrl.sRecNumMgr.IcRead ) //流水号比已存的小，认为是新换盒体，重新更改流水号
    286                      recsmalltimes++;
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   00000126   0x7800             LDRB     R0,[R0, #+0]
   \   00000128   0x1C40             ADDS     R0,R0,#+1
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   0000012E   0x7008             STRB     R0,[R1, #+0]
    287                      if(recsmalltimes > 3){                                  //数据异常处理
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x2804             CMP      R0,#+4
   \   00000138   0xF2C0 0x8088      BLT.W    ??comm_rec_read_5
    288                          recsmalltimes = 0;
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   00000142   0x7008             STRB     R0,[R1, #+0]
    289                          
    290                          if(Ctrl.Otr.Rd.sRec.StoreCnt != 0xffffffff && Ctrl.Otr.Rd.sRec.StoreCnt != 0)
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000148   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   0000014C   0xF110 0x0F01      CMN      R0,#+1
   \   00000150   0xD024             BEQ.N    ??comm_rec_read_6
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000156   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD01E             BEQ.N    ??comm_rec_read_6
    291                          {     //扇区正常     
    292                              if(Ctrl.Otr.Rd.sRec.StoreCnt < Ctrl.sRecNumMgr.Current) //数据记录在已存的记录范围内
   \   0000015E   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000162   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000016A   0x6849             LDR      R1,[R1, #+4]
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xD20D             BCS.N    ??comm_rec_read_7
    293                              {
    294                                  Ctrl.sRecNumMgr.IcRead     = Ctrl.Otr.Rd.sRec.StoreCnt;               //
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000174   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000017C   0x6088             STR      R0,[R1, #+8]
    295                                  Ctrl.sRecNumMgr.CardRead   = Ctrl.sRecNumMgr.IcRead ;                 //重新x卡
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000182   0x6880             LDR      R0,[R0, #+8]
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000188   0x6108             STR      R0,[R1, #+16]
   \   0000018A   0xE00E             B.N      ??comm_rec_read_8
    296                              }else{
    297                                  Ctrl.sRecNumMgr.IcRead++;                              //如果无效，则记录号++，继续执行
   \                     ??comm_rec_read_7: (+1)
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000190   0x6880             LDR      R0,[R0, #+8]
   \   00000192   0x1C40             ADDS     R0,R0,#+1
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000198   0x6088             STR      R0,[R1, #+8]
   \   0000019A   0xE006             B.N      ??comm_rec_read_8
    298                              }
    299                          }             
    300                          else
    301                          {
    302                              Ctrl.sRecNumMgr.IcRead++;                              //如果无效，则记录号++，继续执行
   \                     ??comm_rec_read_6: (+1)
   \   0000019C   0x.... 0x....      LDR.W    R0,??DataTable4
   \   000001A0   0x6880             LDR      R0,[R0, #+8]
   \   000001A2   0x1C40             ADDS     R0,R0,#+1
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000001A8   0x6088             STR      R0,[R1, #+8]
    303                          }
    304                          
    305                          uint32	FlshAddr = GetRecNumAddr(Ctrl.sRecNumMgr.IcRead);       //先应答再存储
   \                     ??comm_rec_read_8: (+1)
   \   000001AA   0x....             LDR.N    R0,??DataTable4
   \   000001AC   0x6880             LDR      R0,[R0, #+8]
   \   000001AE   0x.... 0x....      BL       GetRecNumAddr
   \   000001B2   0x0006             MOVS     R6,R0
    306                          
    307                          WriteFlsh(FlshAddr, (uint8 *)&Ctrl.Otr.Rd.sRec, sizeof(stcFlshRec));    
   \   000001B4   0x2280             MOVS     R2,#+128
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   000001BA   0x0030             MOVS     R0,R6
   \   000001BC   0x.... 0x....      BL       WriteFlsh
    308                          
    309                          DataComReadAsk(Ctrl.sRecNumMgr.IcRead,Ctrl.sRecNumMgr.IcRead +1);
   \   000001C0   0x....             LDR.N    R0,??DataTable4
   \   000001C2   0x6880             LDR      R0,[R0, #+8]
   \   000001C4   0x1C41             ADDS     R1,R0,#+1
   \   000001C6   0x....             LDR.N    R0,??DataTable4
   \   000001C8   0x6880             LDR      R0,[R0, #+8]
   \   000001CA   0x.... 0x....      BL       DataComReadAsk
   \   000001CE   0xE03D             B.N      ??comm_rec_read_5
    310                      }
    311                  }
    312          //        else
    313          //        {
    314          //            recbigtimes++;
    315          //            if(Ctrl.sRecNumMgr.IcRead  > 5){       //该数据记录异常，跳过该记录   
    316          //                recbigtimes = 0;
    317          //                Ctrl.sRecNumMgr.IcRead++;
    318          //
    319          //            }
    320          //        }
    321                  
    322          	}
    323          	else if(    Ctrl.Otr.RxCtrl.Len == sizeof(Ctrl.Otr.Rd.sTinyRec)       //V.2.0
    324                      
    325                       ||  Ctrl.Otr.RxCtrl.Len ==  0x13                                //V.1.0
    326                       )	//统计模块发起查询
   \                     ??comm_rec_read_0: (+1)
   \   000001D0   0x....             LDR.N    R0,??DataTable4
   \   000001D2   0xF890 0x0203      LDRB     R0,[R0, #+515]
   \   000001D6   0x2814             CMP      R0,#+20
   \   000001D8   0xD004             BEQ.N    ??comm_rec_read_9
   \   000001DA   0x....             LDR.N    R0,??DataTable4
   \   000001DC   0xF890 0x0203      LDRB     R0,[R0, #+515]
   \   000001E0   0x2813             CMP      R0,#+19
   \   000001E2   0xD12C             BNE.N    ??comm_rec_read_10
    327          	{
    328          		if(Ctrl.Otr.Rd.sTinyRec.CurRecNum < Ctrl.sRecNumMgr.IcRead)
   \                     ??comm_rec_read_9: (+1)
   \   000001E4   0x....             LDR.N    R0,??DataTable4
   \   000001E6   0xF8D0 0x00C0      LDR      R0,[R0, #+192]
   \   000001EA   0x....             LDR.N    R1,??DataTable4
   \   000001EC   0x6889             LDR      R1,[R1, #+8]
   \   000001EE   0x4288             CMP      R0,R1
   \   000001F0   0xD215             BCS.N    ??comm_rec_read_11
    329          		{
    330          			errtimes++;
   \   000001F2   0x....             LDR.N    R0,??DataTable4_7
   \   000001F4   0x7800             LDRB     R0,[R0, #+0]
   \   000001F6   0x1C40             ADDS     R0,R0,#+1
   \   000001F8   0x....             LDR.N    R1,??DataTable4_7
   \   000001FA   0x7008             STRB     R0,[R1, #+0]
    331          			if( errtimes > 2 ){										//流水号异常。
   \   000001FC   0x....             LDR.N    R0,??DataTable4_7
   \   000001FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000200   0x2803             CMP      R0,#+3
   \   00000202   0xDB23             BLT.N    ??comm_rec_read_5
    332          				Ctrl.sRecNumMgr.Current = Ctrl.Otr.Rd.sTinyRec.CurRecNum;
   \   00000204   0x....             LDR.N    R0,??DataTable4
   \   00000206   0xF8D0 0x00C0      LDR      R0,[R0, #+192]
   \   0000020A   0x....             LDR.N    R1,??DataTable4
   \   0000020C   0x6048             STR      R0,[R1, #+4]
    333          				Ctrl.sRecNumMgr.IcRead = Ctrl.sRecNumMgr.Current;
   \   0000020E   0x....             LDR.N    R0,??DataTable4
   \   00000210   0x6840             LDR      R0,[R0, #+4]
   \   00000212   0x....             LDR.N    R1,??DataTable4
   \   00000214   0x6088             STR      R0,[R1, #+8]
    334                          
    335          				FRAM_StoreRecNumMgr((StrRecNumMgr *)&Ctrl.sRecNumMgr);	//存流水号
   \   00000216   0x....             LDR.N    R0,??DataTable4_8
   \   00000218   0x.... 0x....      BL       FRAM_StoreRecNumMgr
   \   0000021C   0xE016             B.N      ??comm_rec_read_5
    336          			}
    337          		}
    338          		else
    339          		{
    340          			Ctrl.sRecNumMgr.Current = Ctrl.Otr.Rd.sTinyRec.CurRecNum;
   \                     ??comm_rec_read_11: (+1)
   \   0000021E   0x....             LDR.N    R0,??DataTable4
   \   00000220   0xF8D0 0x00C0      LDR      R0,[R0, #+192]
   \   00000224   0x....             LDR.N    R1,??DataTable4
   \   00000226   0x6048             STR      R0,[R1, #+4]
    341          			DataComReadAsk(Ctrl.sRecNumMgr.IcRead,Ctrl.sRecNumMgr.IcRead +1);
   \   00000228   0x....             LDR.N    R0,??DataTable4
   \   0000022A   0x6880             LDR      R0,[R0, #+8]
   \   0000022C   0x1C41             ADDS     R1,R0,#+1
   \   0000022E   0x....             LDR.N    R0,??DataTable4
   \   00000230   0x6880             LDR      R0,[R0, #+8]
   \   00000232   0x.... 0x....      BL       DataComReadAsk
    342                      
    343          			FRAM_StoreRecNumMgr((StrRecNumMgr *)&Ctrl.sRecNumMgr);	//存流水号
   \   00000236   0x....             LDR.N    R0,??DataTable4_8
   \   00000238   0x.... 0x....      BL       FRAM_StoreRecNumMgr
   \   0000023C   0xE006             B.N      ??comm_rec_read_5
    344          		}
    345          		
    346          	}else{			
    347                  //如果其他数据，应答接受请求
    348          		DataComReadAsk(Ctrl.sRecNumMgr.IcRead,Ctrl.sRecNumMgr.IcRead +1);
   \                     ??comm_rec_read_10: (+1)
   \   0000023E   0x....             LDR.N    R0,??DataTable4
   \   00000240   0x6880             LDR      R0,[R0, #+8]
   \   00000242   0x1C41             ADDS     R1,R0,#+1
   \   00000244   0x....             LDR.N    R0,??DataTable4
   \   00000246   0x6880             LDR      R0,[R0, #+8]
   \   00000248   0x.... 0x....      BL       DataComReadAsk
    349          	}
    350          }
   \                     ??comm_rec_read_5: (+1)
   \   0000024C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 1
   \                     ??errtimes:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??recsmalltimes:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??recbigtimes:
   \   00000000                      DS8 1
    351          
    352          

   \                                 In section .bss, align 4
    353          static     	uint32      modelsendnum = 0;	//模型发送序号。
   \                     modelsendnum:
   \   00000000                      DS8 4
    354          /*******************************************************************************
    355          * 名    称： ClearModelSendNum
    356          * 功    能： 清模型发送序号。
    357          * 入口参数： 
    358          * 出口参数： 无
    359          * 作　  者： redmorningcn.
    360          * 创建日期： 2017-05-31
    361          * 修    改：
    362          * 修改日期：
    363          * 备    注： 任务创建函数需要在app.h文件中声明
    364          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    365          void	ClearModelSendNum(void)
    366          {
    367          	modelsendnum = 0;
   \                     ClearModelSendNum: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable4_9
   \   00000004   0x6008             STR      R0,[R1, #+0]
    368          }
   \   00000006   0x4770             BX       LR               ;; return
    369          
    370          /*******************************************************************************
    371          * 名    称： comm_para_flow
    372          * 功    能： 参数流。根据IC卡的类型进行操作
    373          * 入口参数： 
    374          * 出口参数： 无
    375          * 作　  者： redmorningcn.
    376          * 创建日期： 2017-05-26
    377          * 修    改：
    378          * 修改日期：
    379          * 备    注： 任务创建函数需要在app.h文件中声明
    380          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    381          void    comm_para_flow(StrDevOtr * sDtu,uint8 addrnum)
    382          {
   \                     comm_para_flow: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0004             MOVS     R4,R0
    383              OS_ERR          err;
    384              uint8       retrytimes = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    385          	uint8		Infolen = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
    386          	uint8		*p = (uint8 *)&m_sModelCard;
   \   0000000C   0x....             LDR.N    R0,??DataTable4_10
   \   0000000E   0x9004             STR      R0,[SP, #+16]
    387              
    388              /***********************************************
    389              * 描述： 根据IC卡类型进行相应操作。卡类型在插入卡后，赋值
    390              * 	     如果未插卡，则认为是普通数据卡。
    391              */ 
    392              sDtu->Wr.Code	=	Ctrl.sRunPara.CardType;
   \   00000010   0x....             LDR.N    R0,??DataTable4
   \   00000012   0xF8D0 0x00B0      LDR      R0,[R0, #+176]
   \   00000016   0xF8C4 0x00A0      STR      R0,[R4, #+160]
    393          	
    394              switch (Ctrl.sRunPara.CardType)  	
   \   0000001A   0x....             LDR.N    R0,??DataTable4
   \   0000001C   0xF8D0 0x00B0      LDR      R0,[R0, #+176]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xF000 0x811B      BEQ.W    ??comm_para_flow_0
   \   00000026   0x2820             CMP      R0,#+32
   \   00000028   0xD014             BEQ.N    ??comm_para_flow_1
   \   0000002A   0x2840             CMP      R0,#+64
   \   0000002C   0xD051             BEQ.N    ??comm_para_flow_2
   \   0000002E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000032   0xD017             BEQ.N    ??comm_para_flow_3
   \   00000034   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000038   0xD01C             BEQ.N    ??comm_para_flow_4
   \   0000003A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000003E   0xD021             BEQ.N    ??comm_para_flow_5
   \   00000040   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000044   0xD035             BEQ.N    ??comm_para_flow_6
   \   00000046   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000004A   0xD026             BEQ.N    ??comm_para_flow_7
   \   0000004C   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000050   0xD03C             BEQ.N    ??comm_para_flow_8
   \   00000052   0xE104             B.N      ??comm_para_flow_9
    395              {
    396                  //设置密度
    397              case    DENSITY_CARD: 
    398                  sDtu->Wr.Info.Density	=	Ctrl.SOilPara.Density;
   \                     ??comm_para_flow_1: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable4
   \   00000056   0xF8B0 0x00A4      LDRH     R0,[R0, #+164]
   \   0000005A   0xF8A4 0x00A4      STRH     R0,[R4, #+164]
    399                  Infolen	=	sizeof(Ctrl.SOilPara.Density);
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x0006             MOVS     R6,R0
    400                  break;
   \   00000062   0xE0FD             B.N      ??comm_para_flow_10
    401                  
    402              case    HIGHT_CARD:  
    403                  sDtu->Wr.Info.Hig	=	Ctrl.SOilPara.Hig;
   \                     ??comm_para_flow_3: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable4
   \   00000066   0xF8B0 0x00A2      LDRH     R0,[R0, #+162]
   \   0000006A   0xF8A4 0x00A4      STRH     R0,[R4, #+164]
    404                  Infolen	=	sizeof(Ctrl.SOilPara.Hig);            
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x0006             MOVS     R6,R0
    405                  break;
   \   00000072   0xE0F5             B.N      ??comm_para_flow_10
    406                  
    407                  //模型选择卡
    408              case    MODEL_SELECT_CARD:   
    409                  sDtu->Wr.Info.ModelNum	=	Ctrl.SOilPara.ModelNum;
   \                     ??comm_para_flow_4: (+1)
   \   00000074   0x....             LDR.N    R0,??DataTable4
   \   00000076   0xF890 0x00A0      LDRB     R0,[R0, #+160]
   \   0000007A   0xF884 0x00A4      STRB     R0,[R4, #+164]
    410                  Infolen	=	sizeof(Ctrl.SOilPara.ModelNum);
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x0006             MOVS     R6,R0
    411                  break;
   \   00000082   0xE0ED             B.N      ??comm_para_flow_10
    412                  
    413                  //车型车号
    414              case    FIX_CARD: 
    415                  sDtu->Wr.Info.sLocoId.Num	=	Ctrl.sProductInfo.sLocoId.Num;
   \                     ??comm_para_flow_5: (+1)
   \   00000084   0x....             LDR.N    R0,??DataTable4
   \   00000086   0x8BC0             LDRH     R0,[R0, #+30]
   \   00000088   0xF8A4 0x00A6      STRH     R0,[R4, #+166]
    416                  sDtu->Wr.Info.sLocoId.Type	=	Ctrl.sProductInfo.sLocoId.Type;
   \   0000008C   0x....             LDR.N    R0,??DataTable4
   \   0000008E   0x8B80             LDRH     R0,[R0, #+28]
   \   00000090   0xF8A4 0x00A4      STRH     R0,[R4, #+164]
    417                  
    418                  Infolen	=	sizeof(	Ctrl.sProductInfo.sLocoId.Num) +
    419                      sizeof( Ctrl.sProductInfo.sLocoId.Type	);
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0x0006             MOVS     R6,R0
    420                  break;
   \   00000098   0xE0E2             B.N      ??comm_para_flow_10
    421                  
    422                  //读数据指示
    423              case    DATA_CARD_DIS: 
    424                  
    425                  sDtu->Wr.Info.CardRecNum	=	Ctrl.sRec.StoreCnt;
   \                     ??comm_para_flow_7: (+1)
   \   0000009A   0x....             LDR.N    R0,??DataTable4
   \   0000009C   0x6A00             LDR      R0,[R0, #+32]
   \   0000009E   0xF8C4 0x00A4      STR      R0,[R4, #+164]
    426                  
    427                  Infolen	=	sizeof(Ctrl.sRec.StoreCnt);
   \   000000A2   0x2004             MOVS     R0,#+4
   \   000000A4   0x0006             MOVS     R6,R0
    428                  
    429                  sDtu->ConnCtrl[0].SendFramNum++;
   \   000000A6   0xF894 0x0152      LDRB     R0,[R4, #+338]
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0xF884 0x0152      STRB     R0,[R4, #+338]
    430                  
    431                  break;
   \   000000B0   0xE0D6             B.N      ??comm_para_flow_10
    432                  
    433              case    DATA_CARD_ERR: 
    434                  
    435                  sDtu->Wr.Info.Buf[0]	=	Ctrl.sRunPara.CardErrData;
   \                     ??comm_para_flow_6: (+1)
   \   000000B2   0x....             LDR.N    R0,??DataTable4
   \   000000B4   0xF890 0x00B4      LDRB     R0,[R0, #+180]
   \   000000B8   0xF884 0x00A4      STRB     R0,[R4, #+164]
    436                  
    437                  Infolen	=	sizeof(Ctrl.sRunPara.CardErrData);
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x0006             MOVS     R6,R0
    438                  
    439                  sDtu->ConnCtrl[0].SendFramNum++;
   \   000000C0   0xF894 0x0152      LDRB     R0,[R4, #+338]
   \   000000C4   0x1C40             ADDS     R0,R0,#+1
   \   000000C6   0xF884 0x0152      STRB     R0,[R4, #+338]
    440                  
    441                  break;
   \   000000CA   0xE0C9             B.N      ??comm_para_flow_10
    442                          
    443                  //读数据指示结束
    444              case    DATA_CARD_FIN: 
    445                  
    446                  Infolen = 0;
   \                     ??comm_para_flow_8: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x0006             MOVS     R6,R0
    447                  break; 
   \   000000D0   0xE0C6             B.N      ??comm_para_flow_10
    448                  
    449                  /***********************************************
    450                  * 描述： 设置油箱模型。
    451                  *   IC 卡模块插入IC卡后，IC卡主动应答模型。  
    452                  *   后续每200ms发送数据，序号从0开始累加。
    453                  数据发送完成后，序号为0xffffffff。
    454                  */    
    455              case    MODEL_CARD: {
    456                  modelsendnum         = 0;
   \                     ??comm_para_flow_2: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x....             LDR.N    R1,??DataTable4_9
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    457                  p = (uint8 *)&m_sModelCard;		
   \   000000D8   0x....             LDR.N    R0,??DataTable4_10
   \   000000DA   0x9004             STR      R0,[SP, #+16]
    458                  int     sendmodellen  = 0;  //已发送数据长度
   \   000000DC   0x2700             MOVS     R7,#+0
    459                  uint16   sendtimes = 0;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    460                  
    461                  OSFlagPendAbort(( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    462                                  ( OS_OPT       ) OS_OPT_PEND_ABORT_ALL,
    463                                  ( OS_ERR      *)&err );
   \   000000E4   0xAA03             ADD      R2,SP,#+12
   \   000000E6   0xF44F 0x7180      MOV      R1,#+256
   \   000000EA   0x....             LDR.N    R0,??DataTable4_11
   \   000000EC   0x.... 0x....      BL       OSFlagPendAbort
    464                  
    465                  while(sizeof(stcModelCard ) > 128 * modelsendnum ) {
   \                     ??comm_para_flow_11: (+1)
   \   000000F0   0x....             LDR.N    R0,??DataTable4_9
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x2180             MOVS     R1,#+128
   \   000000F6   0x4348             MULS     R0,R1,R0
   \   000000F8   0xF241 0x7144      MOVW     R1,#+5956
   \   000000FC   0x4288             CMP      R0,R1
   \   000000FE   0xF080 0x80AC      BCS.W    ??comm_para_flow_12
    466                      
    467                      if((sizeof(stcModelCard ) - 128 * modelsendnum) > 128 ) {
   \   00000102   0xF241 0x7044      MOVW     R0,#+5956
   \   00000106   0x....             LDR.N    R1,??DataTable4_9
   \   00000108   0x6809             LDR      R1,[R1, #+0]
   \   0000010A   0x2280             MOVS     R2,#+128
   \   0000010C   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   00000110   0x2881             CMP      R0,#+129
   \   00000112   0xD31F             BCC.N    ??comm_para_flow_13
    468                          if(modelsendnum == 0)
   \   00000114   0x....             LDR.N    R0,??DataTable4_9
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD101             BNE.N    ??comm_para_flow_14
    469                              p = (uint8 *)&m_sModelCard;		
   \   0000011C   0x....             LDR.N    R0,??DataTable4_10
   \   0000011E   0x9004             STR      R0,[SP, #+16]
    470                          //数据序号
    471                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[0],(uint8 *)&modelsendnum,sizeof(modelsendnum));	
   \                     ??comm_para_flow_14: (+1)
   \   00000120   0xF05F 0x0804      MOVS     R8,#+4
   \   00000124   0x.... 0x....      LDR.W    R9,??DataTable4_9
   \   00000128   0xF114 0x0AA4      ADDS     R10,R4,#+164
   \   0000012C   0x4642             MOV      R2,R8
   \   0000012E   0x4649             MOV      R1,R9
   \   00000130   0x4650             MOV      R0,R10
   \   00000132   0x.... 0x....      BL       __aeabi_memcpy
    472                          //数据内容
    473                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[4],&p[sendmodellen],128);
   \   00000136   0xF05F 0x0A80      MOVS     R10,#+128
   \   0000013A   0x9804             LDR      R0,[SP, #+16]
   \   0000013C   0x1838             ADDS     R0,R7,R0
   \   0000013E   0x9000             STR      R0,[SP, #+0]
   \   00000140   0xF114 0x0BA8      ADDS     R11,R4,#+168
   \   00000144   0x4652             MOV      R2,R10
   \   00000146   0x9900             LDR      R1,[SP, #+0]
   \   00000148   0x4658             MOV      R0,R11
   \   0000014A   0x.... 0x....      BL       __aeabi_memcpy
    474                          
    475                          
    476                          Infolen = sizeof(modelsendnum)+128;
   \   0000014E   0x2084             MOVS     R0,#+132
   \   00000150   0x0006             MOVS     R6,R0
   \   00000152   0xE026             B.N      ??comm_para_flow_15
    477                      } else {		
    478                          //发送结束信号
    479                          modelsendnum = 0xffffffff;
   \                     ??comm_para_flow_13: (+1)
   \   00000154   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000158   0x....             LDR.N    R1,??DataTable4_9
   \   0000015A   0x6008             STR      R0,[R1, #+0]
    480                          //数据序号
    481                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[0],(uint8 *)&modelsendnum,sizeof(modelsendnum));	
   \   0000015C   0xF05F 0x0804      MOVS     R8,#+4
   \   00000160   0x.... 0x....      LDR.W    R9,??DataTable4_9
   \   00000164   0xF114 0x0AA4      ADDS     R10,R4,#+164
   \   00000168   0x4642             MOV      R2,R8
   \   0000016A   0x4649             MOV      R1,R9
   \   0000016C   0x4650             MOV      R0,R10
   \   0000016E   0x.... 0x....      BL       __aeabi_memcpy
    482                          //数据内容
    483                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[4],&p[sendmodellen],(sizeof(stcModelCard ) - sendmodellen));
   \   00000172   0xF241 0x7044      MOVW     R0,#+5956
   \   00000176   0x1BC0             SUBS     R0,R0,R7
   \   00000178   0x9000             STR      R0,[SP, #+0]
   \   0000017A   0x9804             LDR      R0,[SP, #+16]
   \   0000017C   0xEB17 0x0A00      ADDS     R10,R7,R0
   \   00000180   0xF114 0x0BA8      ADDS     R11,R4,#+168
   \   00000184   0x9A00             LDR      R2,[SP, #+0]
   \   00000186   0x4651             MOV      R1,R10
   \   00000188   0x4658             MOV      R0,R11
   \   0000018A   0x.... 0x....      BL       __aeabi_memcpy
    484                          
    485                          Infolen = sizeof(modelsendnum) + (sizeof(stcModelCard ) - sendmodellen);
   \   0000018E   0xF1D7 0x0048      RSBS     R0,R7,#+72
   \   00000192   0x0006             MOVS     R6,R0
    486                          
    487                          sendmodellen = sizeof(stcModelCard ) ;
   \   00000194   0xF241 0x7044      MOVW     R0,#+5956
   \   00000198   0x0007             MOVS     R7,R0
    488                          //更改卡类型。退出模型卡
    489                          //modelsendnum = 0;
    490                          Ctrl.sRunPara.CardType = DATA_CARD;
   \   0000019A   0x2001             MOVS     R0,#+1
   \   0000019C   0x....             LDR.N    R1,??DataTable4
   \   0000019E   0xF8C1 0x00B0      STR      R0,[R1, #+176]
    491                      }
    492                      
    493                      
    494                      CSNC_SendData(sDtu->pch,                        //通讯控制块
    495                                    SLAVE_ADDR_OTR,					//源地址
    496                                    MASTE_ADDR_HOST,				    //目标地址
    497                                    sDtu->ConnCtrl[0].SendFramNum,	//发送帧号
    498                                    0,								//帧类型，默认为0，在数据区内明确		
    499                                    (uint8 *)&sDtu->Wr,				//发送缓冲区
    500                                    Infolen+sizeof(sDtu->Wr.Code)	//发送数据区长度
    501                                        );
   \                     ??comm_para_flow_15: (+1)
   \   000001A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001A4   0x1D30             ADDS     R0,R6,#+4
   \   000001A6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001A8   0x9002             STR      R0,[SP, #+8]
   \   000001AA   0xF114 0x00A0      ADDS     R0,R4,#+160
   \   000001AE   0x9001             STR      R0,[SP, #+4]
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x9000             STR      R0,[SP, #+0]
   \   000001B4   0xF894 0x3152      LDRB     R3,[R4, #+338]
   \   000001B8   0x2280             MOVS     R2,#+128
   \   000001BA   0x21C1             MOVS     R1,#+193
   \   000001BC   0xF8D4 0x015C      LDR      R0,[R4, #+348]
   \   000001C0   0x.... 0x....      BL       CSNC_SendData
    502                      
    503                      //数据完成
    504                      if(modelsendnum == 0xffffffff)
   \   000001C4   0x....             LDR.N    R0,??DataTable4_9
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0xF110 0x0F01      CMN      R0,#+1
   \   000001CC   0xD059             BEQ.N    ??comm_para_flow_16
    505                          return;            
    506          
    507                      OS_FLAGS    flags = 
    508                      OSFlagPend( ( OS_FLAG_GRP *)&Ctrl.Os.CommEvtFlagGrp,
    509                                 ( OS_FLAGS     ) COMM_EVT_FLAG_OTR_RX,
    510                                 ( OS_TICK      ) 250,
    511                                 ( OS_OPT       ) OS_OPT_PEND_FLAG_SET_ANY,
    512                                 ( CPU_TS      *) NULL,
    513                                 ( OS_ERR      *)&err);
   \                     ??comm_para_flow_17: (+1)
   \   000001CE   0xA803             ADD      R0,SP,#+12
   \   000001D0   0x9001             STR      R0,[SP, #+4]
   \   000001D2   0x2000             MOVS     R0,#+0
   \   000001D4   0x9000             STR      R0,[SP, #+0]
   \   000001D6   0x2308             MOVS     R3,#+8
   \   000001D8   0x22FA             MOVS     R2,#+250
   \   000001DA   0x2104             MOVS     R1,#+4
   \   000001DC   0x....             LDR.N    R0,??DataTable4_11
   \   000001DE   0x.... 0x....      BL       OSFlagPend
   \   000001E2   0x4680             MOV      R8,R0
    514                      
    515                      
    516                      /***********************************************
    517                      * 描述： 如果串口有应答，则继续发送下一帧
    518                      */
    519                      if ( err == OS_ERR_NONE ) {                
   \   000001E4   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   000001E8   0x2800             CMP      R0,#+0
   \   000001EA   0xD128             BNE.N    ??comm_para_flow_18
    520                          /***********************************************
    521                          * 描述： 清除标志位
    522                          */
    523                          OSFlagPost( ( OS_FLAG_GRP  *)&Ctrl.Os.CommEvtFlagGrp,
    524                                      ( OS_FLAGS      )COMM_EVT_FLAG_OTR_RX,
    525                                      ( OS_OPT        )OS_OPT_POST_FLAG_CLR,
    526                                      ( OS_ERR       *)&err);
   \   000001EC   0xAB03             ADD      R3,SP,#+12
   \   000001EE   0x2201             MOVS     R2,#+1
   \   000001F0   0x2104             MOVS     R1,#+4
   \   000001F2   0x....             LDR.N    R0,??DataTable4_11
   \   000001F4   0x.... 0x....      BL       OSFlagPost
    527                         
    528                          if( Ctrl.Otr.RxCtrl.FramNum == sDtu->ConnCtrl[0].SendFramNum  && 
    529                              Ctrl.Otr.Rd.modelcontrl.code == MODEL_CARD )  {
   \   000001F8   0x....             LDR.N    R0,??DataTable4
   \   000001FA   0xF890 0x0202      LDRB     R0,[R0, #+514]
   \   000001FE   0xF894 0x1152      LDRB     R1,[R4, #+338]
   \   00000202   0x4288             CMP      R0,R1
   \   00000204   0xD10D             BNE.N    ??comm_para_flow_19
   \   00000206   0x....             LDR.N    R0,??DataTable4
   \   00000208   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   0000020C   0x2840             CMP      R0,#+64
   \   0000020E   0xD108             BNE.N    ??comm_para_flow_19
    530                              retrytimes      = 0;
   \   00000210   0x2000             MOVS     R0,#+0
   \   00000212   0x0005             MOVS     R5,R0
    531                              modelsendnum++;
   \   00000214   0x....             LDR.N    R0,??DataTable4_9
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x1C40             ADDS     R0,R0,#+1
   \   0000021A   0x....             LDR.N    R1,??DataTable4_9
   \   0000021C   0x6008             STR      R0,[R1, #+0]
    532                              sendmodellen   += 128;
   \   0000021E   0x3780             ADDS     R7,R7,#+128
   \   00000220   0xE766             B.N      ??comm_para_flow_11
    533                          } else {
    534                              retrytimes++;
   \                     ??comm_para_flow_19: (+1)
   \   00000222   0x1C6D             ADDS     R5,R5,#+1
    535                              if(retrytimes > 2) {
   \   00000224   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000226   0x2D03             CMP      R5,#+3
   \   00000228   0xF6FF 0xAF62      BLT.W    ??comm_para_flow_11
    536                                  retrytimes      = 0;
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0x0005             MOVS     R5,R0
    537                                  modelsendnum++;
   \   00000230   0x....             LDR.N    R0,??DataTable4_9
   \   00000232   0x6800             LDR      R0,[R0, #+0]
   \   00000234   0x1C40             ADDS     R0,R0,#+1
   \   00000236   0x....             LDR.N    R1,??DataTable4_9
   \   00000238   0x6008             STR      R0,[R1, #+0]
    538                                  sendmodellen   += 128; 
   \   0000023A   0x3780             ADDS     R7,R7,#+128
   \   0000023C   0xE758             B.N      ??comm_para_flow_11
    539                             } 
    540                          }
    541                      /***********************************************
    542                      * 描述： 如果串口没有应答，则超时后发送下一帧
    543                      */
    544                      } else  {
    545                          retrytimes++;
   \                     ??comm_para_flow_18: (+1)
   \   0000023E   0x1C6D             ADDS     R5,R5,#+1
    546                          if(retrytimes > 2) {
   \   00000240   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000242   0x2D03             CMP      R5,#+3
   \   00000244   0xF6FF 0xAF54      BLT.W    ??comm_para_flow_11
    547                              retrytimes      = 0;
   \   00000248   0x2000             MOVS     R0,#+0
   \   0000024A   0x0005             MOVS     R5,R0
    548                              modelsendnum++;
   \   0000024C   0x....             LDR.N    R0,??DataTable4_9
   \   0000024E   0x6800             LDR      R0,[R0, #+0]
   \   00000250   0x1C40             ADDS     R0,R0,#+1
   \   00000252   0x....             LDR.N    R1,??DataTable4_9
   \   00000254   0x6008             STR      R0,[R1, #+0]
    549                              sendmodellen   += 128;
   \   00000256   0x3780             ADDS     R7,R7,#+128
   \   00000258   0xE74A             B.N      ??comm_para_flow_11
    550          
    551                          }
    552                      }
    553                  }
    554                  
    555                  return;
   \                     ??comm_para_flow_12: (+1)
   \   0000025A   0xE012             B.N      ??comm_para_flow_16
    556                  
    557              } break;
    558                  /***********************************************
    559                  * 描述： 数据卡(默认状态)。
    560                  *   对
    561                  *   后续每200ms发送数据，序号从0开始累加。
    562                  数据发送完成后，序号为0xffffffff。
    563                  */    		
    564                  //数据卡
    565              case    DATA_CARD: 
    566                  return;
   \                     ??comm_para_flow_0: (+1)
   \   0000025C   0xE011             B.N      ??comm_para_flow_16
    567                  break;
    568                  
    569                  //其他类型数据，直接退出
    570              default:
    571                  return;					   
   \                     ??comm_para_flow_9: (+1)
   \   0000025E   0xE010             B.N      ??comm_para_flow_16
    572                  
    573              }
    574              
    575          	CSNC_SendData(	sDtu->pch,						//通讯控制块
    576                            SLAVE_ADDR_OTR,					//源地址
    577                            MASTE_ADDR_HOST,				    //目标地址
    578                            sDtu->ConnCtrl[0].SendFramNum,	//发送帧号
    579                            0,								//帧类型，默认为0，在数据区内明确		
    580                            (uint8 *)&sDtu->Wr,				//发送缓冲区
    581                            Infolen+sizeof(sDtu->Wr.Code)	//发送数据区长度
    582                                );
   \                     ??comm_para_flow_10: (+1)
   \   00000260   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000262   0x1D30             ADDS     R0,R6,#+4
   \   00000264   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000266   0x9002             STR      R0,[SP, #+8]
   \   00000268   0xF114 0x00A0      ADDS     R0,R4,#+160
   \   0000026C   0x9001             STR      R0,[SP, #+4]
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0x9000             STR      R0,[SP, #+0]
   \   00000272   0xF894 0x3152      LDRB     R3,[R4, #+338]
   \   00000276   0x2280             MOVS     R2,#+128
   \   00000278   0x21C1             MOVS     R1,#+193
   \   0000027A   0xF8D4 0x015C      LDR      R0,[R4, #+348]
   \   0000027E   0x.... 0x....      BL       CSNC_SendData
    583          }
   \                     ??comm_para_flow_16: (+1)
   \   00000282   0xB007             ADD      SP,SP,#+28
   \   00000284   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    584          
    585          
    586          /*******************************************************************************
    587          * 名    称： 		GetRecNumAddr
    588          * 功    能：      取数据记录地址。
    589          flash地址;更新记录号等信息。
    590          * 入口参数： 	无
    591          * 出口参数： 	无
    592          * 作　 　者： 	redmornigcn
    593          * 创建日期： 	2017-05-15
    594          * 修    改：
    595          * 修改日期：
    596          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    597          uint32  GetRecNumAddr(uint32 FlshRecNum)
    598          {				
    599              return  (uint32)(((FlshRecNum * sizeof(stcFlshRec)) % FLSH_MAX_SIZE)); 			
   \                     GetRecNumAddr: (+1)
   \   00000000   0x2180             MOVS     R1,#+128
   \   00000002   0xFB01 0xF100      MUL      R1,R1,R0
   \   00000006   0xF45F 0x0200      MOVS     R2,#+8388608
   \   0000000A   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \   0000000E   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   00000012   0x4770             BX       LR               ;; return
    600          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     Ctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     Ctrl+0x15C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     Ctrl+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     ??recsmalltimes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     ??recbigtimes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     Ctrl+0xBC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     Ctrl+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     ??errtimes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     Ctrl+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     modelsendnum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     m_sModelCard

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     Ctrl+0x275
    601          /*******************************************************************************
    602          * 				end of file
    603          *******************************************************************************/
    604          #endif
    605          
    606          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ClearModelSendNum
      24   DataComReadAsk
        24   -> CSNC_SendData
       0   GetRecNumAddr
      16   JudegLocoInfo
        16   -> FRAM_StoreProductInfo
        16   -> GetCrc16Check
      64   comm_para_flow
        64   -> CSNC_SendData
        64   -> OSFlagPend
        64   -> OSFlagPendAbort
        64   -> OSFlagPost
        64   -> __aeabi_memcpy
      16   comm_rec_read
        16   -> BSP_LED_Toggle
        16   -> DataComReadAsk
        16   -> FRAM_StoreRecNumMgr
        16   -> GetRecNumAddr
        16   -> ReadFlsh
        16   -> WriteFlsh
        16   -> osal_start_timerEx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       8  ClearModelSendNum
      72  DataComReadAsk
      20  GetRecNumAddr
     134  JudegLocoInfo
     648  comm_para_flow
     590  comm_rec_read
       1  errtimes
    5956  m_sModelCard
       4  modelsendnum
       1  recbigtimes
       1  recsmalltimes

 
 5 963 bytes in section .bss
 1 520 bytes in section .text
 
 1 520 bytes of CODE memory
 5 963 bytes of DATA memory

Errors: none
Warnings: 4

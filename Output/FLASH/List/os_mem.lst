###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       28/Dec/2017  08:42:41
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_mem.c
#    Command line =  
#        "F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_mem.c" -D
#        RELEASE -lCN "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline
#    List file    =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\List\os_mem.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Output\FLASH\Obj\os_mem.o
#
###############################################################################

F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_mem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                             MEMORY PARTITION MANAGEMENT
     10          *
     11          * File    : OS_MEM.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define   MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_mem__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_MEM_EN == DEF_ENABLED)
     44          /*
     45          ************************************************************************************************************************
     46          *                                               CREATE A MEMORY PARTITION
     47          *
     48          * Description : Create a fixed-sized memory partition that will be managed by uC/OS-III.
     49          *
     50          * Arguments   : p_mem    is a pointer to a memory partition control block which is allocated in user memory space.
     51          *
     52          *               p_name   is a pointer to an ASCII string to provide a name to the memory partition.
     53          *
     54          *               p_addr   is the starting address of the memory partition
     55          *
     56          *               n_blks   is the number of memory blocks to create from the partition.
     57          *
     58          *               blk_size is the size (in bytes) of each block in the memory partition.
     59          *
     60          *               p_err    is a pointer to a variable containing an error message which will be set by this function to
     61          *                        either:
     62          *
     63          *                            OS_ERR_NONE                    If the memory partition has been created correctly
     64          *                            OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the memory partition after you
     65          *                                                             called OSSafetyCriticalStart()
     66          *                            OS_ERR_MEM_CREATE_ISR          If you called this function from an ISR
     67          *                            OS_ERR_MEM_INVALID_BLKS        User specified an invalid number of blocks (must be >= 2)
     68          *                            OS_ERR_MEM_INVALID_P_ADDR      If you are specifying an invalid address for the memory
     69          *                                                           storage of the partition or, the block does not align on a
     70          *                                                           pointer boundary
     71          *                            OS_ERR_MEM_INVALID_SIZE        User specified an invalid block size
     72          *                                                             - must be greater than the size of a pointer
     73          *                                                             - must be able to hold an integral number of pointers
     74          * Returns    : none
     75          *
     76          * Note(s)    : none
     77          ************************************************************************************************************************
     78          */
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void  OSMemCreate (OS_MEM       *p_mem,
     81                             CPU_CHAR     *p_name,
     82                             void         *p_addr,
     83                             OS_MEM_QTY    n_blks,
     84                             OS_MEM_SIZE   blk_size,
     85                             OS_ERR       *p_err)
     86          {
   \                     OSMemCreate: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C0E             LDR      R4,[SP, #+56]
   \   0000000E   0xF8DD 0x803C      LDR      R8,[SP, #+60]
     87          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
     88              CPU_DATA       align_msk;
     89          #endif
     90              OS_MEM_QTY     i;
     91              OS_MEM_QTY     loops;
     92              CPU_INT08U    *p_blk;
     93              void         **p_link;
     94              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0B00      MOVS     R11,#+0
     95          
     96          
     97          
     98          #ifdef OS_SAFETY_CRITICAL
     99              if (p_err == DEF_NULL) {
    100                  OS_SAFETY_CRITICAL_EXCEPTION();
    101                  return;
    102              }
    103          #endif
    104          
    105          #ifdef OS_SAFETY_CRITICAL_IEC61508
    106              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    107                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    108                  return;
    109              }
    110          #endif
    111          
    112          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    113              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000016   0x....             LDR.N    R0,??DataTable4
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD004             BEQ.N    ??OSMemCreate_0
    114                 *p_err = OS_ERR_MEM_CREATE_ISR;
   \   0000001E   0xF245 0x60B9      MOVW     R0,#+22201
   \   00000022   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    115                  return;
   \   00000026   0xE066             B.N      ??OSMemCreate_1
    116              }
    117          #endif
    118          
    119          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    120              if (p_addr == DEF_NULL) {                                   /* Must pass a valid address for the memory part.       */
   \                     ??OSMemCreate_0: (+1)
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD104             BNE.N    ??OSMemCreate_2
    121                 *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
   \   0000002C   0xF245 0x60BB      MOVW     R0,#+22203
   \   00000030   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    122                  return;
   \   00000034   0xE05F             B.N      ??OSMemCreate_1
    123              }
    124              if (n_blks < 2u) {                                          /* Must have at least 2 blocks per partition            */
   \                     ??OSMemCreate_2: (+1)
   \   00000036   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000038   0x2F02             CMP      R7,#+2
   \   0000003A   0xD204             BCS.N    ??OSMemCreate_3
    125                 *p_err = OS_ERR_MEM_INVALID_BLKS;
   \   0000003C   0xF245 0x60BC      MOVW     R0,#+22204
   \   00000040   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    126                  return;
   \   00000044   0xE057             B.N      ??OSMemCreate_1
    127              }
    128              if (blk_size < sizeof(void *)) {                            /* Must contain space for at least a pointer            */
   \                     ??OSMemCreate_3: (+1)
   \   00000046   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000048   0x2C04             CMP      R4,#+4
   \   0000004A   0xD204             BCS.N    ??OSMemCreate_4
    129                 *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   0000004C   0xF245 0x60C1      MOVW     R0,#+22209
   \   00000050   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    130                  return;
   \   00000054   0xE04F             B.N      ??OSMemCreate_1
    131              }
    132              align_msk = sizeof(void *) - 1u;
   \                     ??OSMemCreate_4: (+1)
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0x9001             STR      R0,[SP, #+4]
    133              if (align_msk > 0u) {
   \   0000005A   0x9801             LDR      R0,[SP, #+4]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD011             BEQ.N    ??OSMemCreate_5
    134                  if (((CPU_ADDR)p_addr & align_msk) != 0u){              /* Must be pointer size aligned                         */
   \   00000060   0x9801             LDR      R0,[SP, #+4]
   \   00000062   0x4206             TST      R6,R0
   \   00000064   0xD004             BEQ.N    ??OSMemCreate_6
    135                     *p_err = OS_ERR_MEM_INVALID_P_ADDR;
   \   00000066   0xF245 0x60BB      MOVW     R0,#+22203
   \   0000006A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    136                      return;
   \   0000006E   0xE042             B.N      ??OSMemCreate_1
    137                  }
    138                  if ((blk_size & align_msk) != 0u) {                     /* Block size must be a multiple address size           */
   \                     ??OSMemCreate_6: (+1)
   \   00000070   0x9901             LDR      R1,[SP, #+4]
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x4208             TST      R0,R1
   \   00000078   0xD004             BEQ.N    ??OSMemCreate_5
    139                     *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   0000007A   0xF245 0x60C1      MOVW     R0,#+22209
   \   0000007E   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    140                      return;
   \   00000082   0xE038             B.N      ??OSMemCreate_1
    141                  }
    142              }
    143          #endif
    144          
    145              p_link = (void **)p_addr;                                   /* Create linked list of free memory blocks             */
   \                     ??OSMemCreate_5: (+1)
   \   00000084   0x9600             STR      R6,[SP, #+0]
    146              p_blk  = (CPU_INT08U *)p_addr;
   \   00000086   0x46B2             MOV      R10,R6
    147              loops  = n_blks - 1u;
   \   00000088   0x1E78             SUBS     R0,R7,#+1
   \   0000008A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    148              for (i = 0u; i < loops; i++) {
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x4681             MOV      R9,R0
   \                     ??OSMemCreate_7: (+1)
   \   00000092   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000096   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000009A   0x4581             CMP      R9,R0
   \   0000009C   0xD20A             BCS.N    ??OSMemCreate_8
    149                  p_blk +=  blk_size;
   \   0000009E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000A0   0xEB14 0x0A0A      ADDS     R10,R4,R10
    150                 *p_link = (void  *)p_blk;                                /* Save pointer to NEXT block in CURRENT block          */
   \   000000A4   0x9800             LDR      R0,[SP, #+0]
   \   000000A6   0xF8C0 0xA000      STR      R10,[R0, #+0]
    151                  p_link = (void **)(void *)p_blk;                        /* Position     to NEXT block                           */
   \   000000AA   0xF8CD 0xA000      STR      R10,[SP, #+0]
    152              }
   \   000000AE   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000B2   0xE7EE             B.N      ??OSMemCreate_7
    153             *p_link             = DEF_NULL;                              /* Last memory block points to NULL                     */
   \                     ??OSMemCreate_8: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x9900             LDR      R1,[SP, #+0]
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    154          
    155              CPU_CRITICAL_ENTER();
   \   000000BA   0x.... 0x....      BL       CPU_SR_Save
   \   000000BE   0x4683             MOV      R11,R0
   \   000000C0   0x.... 0x....      BL       CPU_IntDisMeasStart
    156          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    157              p_mem->Type        = OS_OBJ_TYPE_MEM;                       /* Set the type of object                               */
   \   000000C4   0x....             LDR.N    R0,??DataTable4_1  ;; 0x204d454d
   \   000000C6   0x6028             STR      R0,[R5, #+0]
    158          #endif
    159          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    160              p_mem->NamePtr     = p_name;                                /* Save name of memory partition                        */
   \   000000C8   0x9804             LDR      R0,[SP, #+16]
   \   000000CA   0x6068             STR      R0,[R5, #+4]
    161          #else
    162              (void)p_name;
    163          #endif
    164              p_mem->AddrPtr     = p_addr;                                /* Store start address of memory partition              */
   \   000000CC   0x60AE             STR      R6,[R5, #+8]
    165              p_mem->FreeListPtr = p_addr;                                /* Initialize pointer to pool of free blocks            */
   \   000000CE   0x60EE             STR      R6,[R5, #+12]
    166              p_mem->NbrFree     = n_blks;                                /* Store number of free blocks in MCB                   */
   \   000000D0   0x82AF             STRH     R7,[R5, #+20]
    167              p_mem->NbrMax      = n_blks;
   \   000000D2   0x826F             STRH     R7,[R5, #+18]
    168              p_mem->BlkSize     = blk_size;                              /* Store block size of each memory blocks               */
   \   000000D4   0x822C             STRH     R4,[R5, #+16]
    169          
    170          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    171              OS_MemDbgListAdd(p_mem);
   \   000000D6   0x0028             MOVS     R0,R5
   \   000000D8   0x.... 0x....      BL       OS_MemDbgListAdd
    172              OSMemQty++;
   \   000000DC   0x....             LDR.N    R0,??DataTable4_2
   \   000000DE   0x8800             LDRH     R0,[R0, #+0]
   \   000000E0   0x1C40             ADDS     R0,R0,#+1
   \   000000E2   0x....             LDR.N    R1,??DataTable4_2
   \   000000E4   0x8008             STRH     R0,[R1, #+0]
    173          #endif
    174          
    175              OS_TRACE_MEM_CREATE(p_mem, p_name);
    176              CPU_CRITICAL_EXIT();
   \   000000E6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000EA   0x4658             MOV      R0,R11
   \   000000EC   0x.... 0x....      BL       CPU_SR_Restore
    177             *p_err = OS_ERR_NONE;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    178          }
   \                     ??OSMemCreate_1: (+1)
   \   000000F6   0xB005             ADD      SP,SP,#+20
   \   000000F8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    179          
    180          
    181          /*
    182          ************************************************************************************************************************
    183          *                                                  GET A MEMORY BLOCK
    184          *
    185          * Description : Get a memory block from a partition.
    186          *
    187          * Arguments   : p_mem   is a pointer to the memory partition control block
    188          *
    189          *               p_err   is a pointer to a variable containing an error message which will be set by this function to
    190          *                       either:
    191          *
    192          *                           OS_ERR_NONE               If the memory partition has been created correctly
    193          *                           OS_ERR_MEM_INVALID_P_MEM  If you passed a NULL pointer for 'p_mem'
    194          *                           OS_ERR_MEM_NO_FREE_BLKS   If there are no more free memory blocks to allocate to the caller
    195          *                           OS_ERR_OBJ_TYPE           If 'p_mem' is not pointing at a memory partition
    196          *
    197          * Returns    : A pointer to a memory block if no error is detected
    198          *              A pointer to NULL if an error is detected
    199          *
    200          * Note(s)    : none
    201          ************************************************************************************************************************
    202          */
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void  *OSMemGet (OS_MEM  *p_mem,
    205                           OS_ERR  *p_err)
    206          {
   \                     OSMemGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    207              void    *p_blk;
    208              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    209          
    210          
    211          
    212          #ifdef OS_SAFETY_CRITICAL
    213              if (p_err == DEF_NULL) {
    214                  OS_SAFETY_CRITICAL_EXCEPTION();
    215                  return (DEF_NULL);
    216              }
    217          #endif
    218          
    219              OS_TRACE_MEM_GET_ENTER(p_mem);
    220          
    221          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    222              if (p_mem == DEF_NULL) {                                    /* Must point to a valid memory partition               */
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??OSMemGet_0
    223                  OS_TRACE_MEM_GET_FAILED(p_mem);
    224                  OS_TRACE_MEM_GET_EXIT(OS_ERR_MEM_INVALID_P_MEM);
    225                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000C   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000010   0x8028             STRH     R0,[R5, #+0]
    226                  return (DEF_NULL);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE029             B.N      ??OSMemGet_1
    227              }
    228          #endif
    229          
    230          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    231              if (p_mem->Type != OS_OBJ_TYPE_MEM) {                       /* Make sure the memory block was created               */
   \                     ??OSMemGet_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable4_1  ;; 0x204d454d
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD004             BEQ.N    ??OSMemGet_2
    232                  OS_TRACE_MEM_GET_EXIT(OS_ERR_OBJ_TYPE);
    233                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000001E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000022   0x8028             STRH     R0,[R5, #+0]
    234                  return (DEF_NULL);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE020             B.N      ??OSMemGet_1
    235              }
    236          #endif
    237          
    238          
    239              CPU_CRITICAL_ENTER();
   \                     ??OSMemGet_2: (+1)
   \   00000028   0x.... 0x....      BL       CPU_SR_Save
   \   0000002C   0x0007             MOVS     R7,R0
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStart
    240              if (p_mem->NbrFree == 0u) {                                 /* See if there are any free memory blocks              */
   \   00000032   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD109             BNE.N    ??OSMemGet_3
    241                  CPU_CRITICAL_EXIT();
   \   00000038   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
    242                  OS_TRACE_MEM_GET_FAILED(p_mem);
    243                  OS_TRACE_MEM_GET_EXIT(OS_ERR_MEM_NO_FREE_BLKS);
    244                 *p_err = OS_ERR_MEM_NO_FREE_BLKS;                        /* No,  Notify caller of empty memory partition         */
   \   00000042   0xF245 0x60C2      MOVW     R0,#+22210
   \   00000046   0x8028             STRH     R0,[R5, #+0]
    245                  return (DEF_NULL);                                      /* Return NULL pointer to caller                        */
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE00E             B.N      ??OSMemGet_1
    246              }
    247              p_blk              = p_mem->FreeListPtr;                    /* Yes, point to next free memory block                 */
   \                     ??OSMemGet_3: (+1)
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0x0006             MOVS     R6,R0
    248              p_mem->FreeListPtr = *(void **)p_blk;                       /* Adjust pointer to new free list                      */
   \   00000050   0x6830             LDR      R0,[R6, #+0]
   \   00000052   0x60E0             STR      R0,[R4, #+12]
    249              p_mem->NbrFree--;                                           /* One less memory block in this partition              */
   \   00000054   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x82A0             STRH     R0,[R4, #+20]
    250              CPU_CRITICAL_EXIT();
   \   0000005A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0x.... 0x....      BL       CPU_SR_Restore
    251              OS_TRACE_MEM_GET(p_mem);
    252              OS_TRACE_MEM_GET_EXIT(OS_ERR_NONE);
    253             *p_err = OS_ERR_NONE;                                        /* No error                                             */
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x8028             STRH     R0,[R5, #+0]
    254              return (p_blk);                                             /* Return memory block to caller                        */
   \   00000068   0x0030             MOVS     R0,R6
   \                     ??OSMemGet_1: (+1)
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    255          }
    256          
    257          
    258          /*
    259          ************************************************************************************************************************
    260          *                                                 RELEASE A MEMORY BLOCK
    261          *
    262          * Description : Returns a memory block to a partition.
    263          *
    264          * Arguments   : p_mem    is a pointer to the memory partition control block
    265          *
    266          *               p_blk    is a pointer to the memory block being released.
    267          *
    268          *               p_err    is a pointer to a variable that will contain an error code returned by this function.
    269          *
    270          *                            OS_ERR_NONE               If the memory block was inserted into the partition
    271          *                            OS_ERR_MEM_FULL           If you are returning a memory block to an already FULL memory
    272          *                                                      partition (You freed more blocks than you allocated!)
    273          *                            OS_ERR_MEM_INVALID_P_BLK  If you passed a NULL pointer for the block to release.
    274          *                            OS_ERR_MEM_INVALID_P_MEM  If you passed a NULL pointer for 'p_mem'
    275          *                            OS_ERR_OBJ_TYPE           If 'p_mem' is not pointing at a memory partition
    276          *
    277          * Returns    : none
    278          *
    279          * Note(s)    : none
    280          ************************************************************************************************************************
    281          */
    282          

   \                                 In section .text, align 2, keep-with-next
    283          void  OSMemPut (OS_MEM  *p_mem,
    284                          void    *p_blk,
    285                          OS_ERR  *p_err)
    286          {
   \                     OSMemPut: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    287              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
    288          
    289          
    290          
    291          #ifdef OS_SAFETY_CRITICAL
    292              if (p_err == DEF_NULL) {
    293                  OS_SAFETY_CRITICAL_EXCEPTION();
    294                  return;
    295              }
    296          #endif
    297          
    298              OS_TRACE_MEM_PUT_ENTER(p_mem, p_blk);
    299          
    300          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    301              if (p_mem == DEF_NULL) {                                    /* Must point to a valid memory partition               */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD103             BNE.N    ??OSMemPut_0
    302                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    303                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_INVALID_P_MEM);
    304                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000E   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000012   0x8030             STRH     R0,[R6, #+0]
    305                  return;
   \   00000014   0xE02C             B.N      ??OSMemPut_1
    306              }
    307              if (p_blk == DEF_NULL) {                                    /* Must release a valid block                           */
   \                     ??OSMemPut_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD103             BNE.N    ??OSMemPut_2
    308                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    309                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_INVALID_P_BLK);
    310                 *p_err  = OS_ERR_MEM_INVALID_P_BLK;
   \   0000001A   0xF245 0x60BE      MOVW     R0,#+22206
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    311                  return;
   \   00000020   0xE026             B.N      ??OSMemPut_1
    312              }
    313          #endif
    314          
    315          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    316              if (p_mem->Type != OS_OBJ_TYPE_MEM) {                       /* Make sure the memory block was created               */
   \                     ??OSMemPut_2: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable4_1  ;; 0x204d454d
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD003             BEQ.N    ??OSMemPut_3
    317                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_OBJ_TYPE);
    318                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000002A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000002E   0x8030             STRH     R0,[R6, #+0]
    319                  return;
   \   00000030   0xE01E             B.N      ??OSMemPut_1
    320              }
    321          #endif
    322          
    323          
    324              CPU_CRITICAL_ENTER();
   \                     ??OSMemPut_3: (+1)
   \   00000032   0x.... 0x....      BL       CPU_SR_Save
   \   00000036   0x0007             MOVS     R7,R0
   \   00000038   0x.... 0x....      BL       CPU_IntDisMeasStart
    325              if (p_mem->NbrFree >= p_mem->NbrMax) {                      /* Make sure all blocks not already returned            */
   \   0000003C   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000003E   0x8A61             LDRH     R1,[R4, #+18]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD308             BCC.N    ??OSMemPut_4
    326                  CPU_CRITICAL_EXIT();
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
    327                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    328                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_FULL);
    329                 *p_err = OS_ERR_MEM_FULL;
   \   0000004E   0xF245 0x60BA      MOVW     R0,#+22202
   \   00000052   0x8030             STRH     R0,[R6, #+0]
    330                  return;
   \   00000054   0xE00C             B.N      ??OSMemPut_1
    331              }
    332              *(void **)p_blk    = p_mem->FreeListPtr;                    /* Insert released block into free block list           */
   \                     ??OSMemPut_4: (+1)
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x6028             STR      R0,[R5, #+0]
    333              p_mem->FreeListPtr = p_blk;
   \   0000005A   0x60E5             STR      R5,[R4, #+12]
    334              p_mem->NbrFree++;                                           /* One more memory block in this partition              */
   \   0000005C   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0x82A0             STRH     R0,[R4, #+20]
    335              CPU_CRITICAL_EXIT();
   \   00000062   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
    336              OS_TRACE_MEM_PUT(p_mem);
    337              OS_TRACE_MEM_PUT_EXIT(OS_ERR_NONE);
    338             *p_err              = OS_ERR_NONE;                           /* Notify caller that memory block was released         */
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8030             STRH     R0,[R6, #+0]
    339          }
   \                     ??OSMemPut_1: (+1)
   \   00000070   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    340          
    341          
    342          /*
    343          ************************************************************************************************************************
    344          *                                           ADD MEMORY PARTITION TO DEBUG LIST
    345          *
    346          * Description : This function is called by OSMemCreate() to add the memory partition to the debug table.
    347          *
    348          * Arguments   : p_mem    Is a pointer to the memory partition
    349          *
    350          * Returns     : none
    351          *
    352          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    353          ************************************************************************************************************************
    354          */
    355          
    356          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    357          void  OS_MemDbgListAdd (OS_MEM  *p_mem)
    358          {
    359              p_mem->DbgPrevPtr               = DEF_NULL;
   \                     OS_MemDbgListAdd: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6181             STR      R1,[R0, #+24]
    360              if (OSMemDbgListPtr == DEF_NULL) {
   \   00000004   0x....             LDR.N    R1,??DataTable4_3
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD102             BNE.N    ??OS_MemDbgListAdd_0
    361                  p_mem->DbgNextPtr           = DEF_NULL;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x61C1             STR      R1,[R0, #+28]
   \   00000010   0xE005             B.N      ??OS_MemDbgListAdd_1
    362              } else {
    363                  p_mem->DbgNextPtr           =  OSMemDbgListPtr;
   \                     ??OS_MemDbgListAdd_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable4_3
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    364                  OSMemDbgListPtr->DbgPrevPtr =  p_mem;
   \   00000018   0x....             LDR.N    R1,??DataTable4_3
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x6188             STR      R0,[R1, #+24]
    365              }
    366              OSMemDbgListPtr                 =  p_mem;
   \                     ??OS_MemDbgListAdd_1: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable4_3
   \   00000020   0x6008             STR      R0,[R1, #+0]
    367          }
   \   00000022   0x4770             BX       LR               ;; return
    368          #endif
    369          
    370          
    371          /*
    372          ************************************************************************************************************************
    373          *                                           INITIALIZE MEMORY PARTITION MANAGER
    374          *
    375          * Description : This function is called by uC/OS-III to initialize the memory partition manager.  Your
    376          *               application MUST NOT call this function.
    377          *
    378          * Arguments   : none
    379          *
    380          * Returns     : none
    381          *
    382          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    383          ************************************************************************************************************************
    384          */
    385          

   \                                 In section .text, align 2, keep-with-next
    386          void  OS_MemInit (OS_ERR  *p_err)
    387          {
    388          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    389              OSMemDbgListPtr = DEF_NULL;
   \                     OS_MemInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable4_3
   \   00000004   0x6011             STR      R1,[R2, #+0]
    390              OSMemQty        = 0u;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable4_2
   \   0000000A   0x8011             STRH     R1,[R2, #+0]
    391          #endif
    392             *p_err           = OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    393          }
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x204D454D         DC32     0x204d454d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     OSMemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     OSMemDbgListPtr
    394          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   OSMemCreate
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> OS_MemDbgListAdd
      24   OSMemGet
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSMemPut
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   OS_MemDbgListAdd
       0   OS_MemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
     252  OSMemCreate
     108  OSMemGet
     114  OSMemPut
      36  OS_MemDbgListAdd
      18  OS_MemInit

 
 544 bytes in section .text
 
 544 bytes of CODE memory

Errors: none
Warnings: none

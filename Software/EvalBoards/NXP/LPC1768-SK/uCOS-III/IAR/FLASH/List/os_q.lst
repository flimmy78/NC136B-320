###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       14/Dec/2017  10:39:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_q.c
#    Command line =  
#        "F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_q.c" -lCN
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\os_q.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\os_q.o
#
###############################################################################

F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_q.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                               MESSAGE QUEUE MANAGEMENT
     10          *
     11          * File    : OS_Q.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_q__c = "$Id: $";
     40          #endif
     41          
     42          
     43          #if (OS_CFG_Q_EN == DEF_ENABLED)
     44          /*
     45          ************************************************************************************************************************
     46          *                                               CREATE A MESSAGE QUEUE
     47          *
     48          * Description: This function is called by your application to create a message queue.  Message queues MUST be created
     49          *              before they can be used.
     50          *
     51          * Arguments  : p_q         is a pointer to the message queue
     52          *
     53          *              p_name      is a pointer to an ASCII string that will be used to name the message queue
     54          *
     55          *              max_qty     indicates the maximum size of the message queue (must be non-zero).  Note that it's also not
     56          *                          possible to have a size higher than the maximum number of OS_MSGs available.
     57          *
     58          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
     59          *
     60          *                              OS_ERR_NONE                    The call was successful
     61          *                              OS_ERR_CREATE_ISR              Can't create from an ISR
     62          *                              OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the Queue after you called
     63          *                                                               OSSafetyCriticalStart()
     64          *                              OS_ERR_OBJ_PTR_NULL            If you passed a NULL pointer for 'p_q'
     65          *                              OS_ERR_Q_SIZE                  If the size you specified is 0
     66          *
     67          * Returns    : none
     68          *
     69          * Note(s)    : none
     70          ************************************************************************************************************************
     71          */
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void  OSQCreate (OS_Q        *p_q,
     74                           CPU_CHAR    *p_name,
     75                           OS_MSG_QTY   max_qty,
     76                           OS_ERR      *p_err)
     77          
     78          {
   \                     OSQCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
     79              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
     80          
     81          
     82          #ifdef OS_SAFETY_CRITICAL
     83              if (p_err == DEF_NULL) {
     84                  OS_SAFETY_CRITICAL_EXCEPTION();
     85                  return;
     86              }
     87          #endif
     88          
     89          #ifdef OS_SAFETY_CRITICAL_IEC61508
     90              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     91                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     92                  return;
     93              }
     94          #endif
     95          
     96          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
     97              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD003             BEQ.N    ??OSQCreate_0
     98                 *p_err = OS_ERR_CREATE_ISR;
   \   0000001A   0xF642 0x60E1      MOVW     R0,#+12001
   \   0000001E   0x8038             STRH     R0,[R7, #+0]
     99                  return;
   \   00000020   0xE030             B.N      ??OSQCreate_1
    100              }
    101          #endif
    102          
    103          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    104              if (p_q == DEF_NULL) {                                      /* Validate arguments                                   */
   \                     ??OSQCreate_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD103             BNE.N    ??OSQCreate_2
    105                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8038             STRH     R0,[R7, #+0]
    106                  return;
   \   0000002C   0xE02A             B.N      ??OSQCreate_1
    107              }
    108              if (max_qty == 0u) {                                        /* Cannot specify a zero size queue                     */
   \                     ??OSQCreate_2: (+1)
   \   0000002E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD103             BNE.N    ??OSQCreate_3
    109                 *p_err = OS_ERR_Q_SIZE;
   \   00000034   0xF246 0x5094      MOVW     R0,#+26004
   \   00000038   0x8038             STRH     R0,[R7, #+0]
    110                  return;
   \   0000003A   0xE023             B.N      ??OSQCreate_1
    111              }
    112          #endif
    113          
    114              CPU_CRITICAL_ENTER();
   \                     ??OSQCreate_3: (+1)
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
   \   00000040   0x4680             MOV      R8,R0
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStart
    115          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    116              p_q->Type    = OS_OBJ_TYPE_Q;                               /* Mark the data structure as a message queue           */
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x55455551
   \   0000004A   0x6020             STR      R0,[R4, #+0]
    117          #endif
    118          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    119              p_q->NamePtr = p_name;
   \   0000004C   0x6065             STR      R5,[R4, #+4]
    120          #else
    121              (void)p_name;
    122          #endif
    123              OS_MsgQInit(&p_q->MsgQ,                                     /* Initialize the queue                                 */
    124                          max_qty);
   \   0000004E   0x0031             MOVS     R1,R6
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000056   0x.... 0x....      BL       OS_MsgQInit
    125              OS_PendListInit(&p_q->PendList);                            /* Initialize the waiting list                          */
   \   0000005A   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000005E   0x.... 0x....      BL       OS_PendListInit
    126          
    127          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    128              OS_QDbgListAdd(p_q);
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       OS_QDbgListAdd
    129              OSQQty++;                                                   /* One more queue created                               */
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   0000006C   0x8800             LDRH     R0,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \   00000074   0x8008             STRH     R0,[R1, #+0]
    130          #endif
    131              OS_TRACE_Q_CREATE(p_q, p_name);
    132              CPU_CRITICAL_EXIT();
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
    133             *p_err = OS_ERR_NONE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x8038             STRH     R0,[R7, #+0]
    134          }
   \                     ??OSQCreate_1: (+1)
   \   00000084   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    135          
    136          
    137          /*
    138          ************************************************************************************************************************
    139          *                                               DELETE A MESSAGE QUEUE
    140          *
    141          * Description: This function deletes a message queue and readies all tasks pending on the queue.
    142          *
    143          * Arguments  : p_q       is a pointer to the message queue you want to delete
    144          *
    145          *              opt       determines delete options as follows:
    146          *
    147          *                            OS_OPT_DEL_NO_PEND          Delete the queue ONLY if no task pending
    148          *                            OS_OPT_DEL_ALWAYS           Deletes the queue even if tasks are waiting.
    149          *                                                        In this case, all the tasks pending will be readied.
    150          *
    151          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    152          *
    153          *                            OS_ERR_NONE                    The call was successful and the queue was deleted
    154          *                            OS_ERR_DEL_ISR                 If you tried to delete the queue from an ISR
    155          *                            OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the message queue after you
    156          *                                                             called OSStart()
    157          *                            OS_ERR_OBJ_PTR_NULL            If you pass a NULL pointer for 'p_q'
    158          *                            OS_ERR_OBJ_TYPE                If the message queue was not created
    159          *                            OS_ERR_OPT_INVALID             An invalid option was specified
    160          *                            OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    161          *                            OS_ERR_TASK_WAITING            One or more tasks were waiting on the queue
    162          *
    163          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    164          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    165          *
    166          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the queue MUST
    167          *                 check the return code of OSQPend().
    168          *
    169          *              2) Because ALL tasks pending on the queue will be readied, you MUST be careful in applications where the
    170          *                 queue is used for mutual exclusion because the resource(s) will no longer be guarded by the queue.
    171          ************************************************************************************************************************
    172          */
    173          
    174          #if (OS_CFG_Q_DEL_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    175          OS_OBJ_QTY  OSQDel (OS_Q    *p_q,
    176                              OS_OPT   opt,
    177                              OS_ERR  *p_err)
    178          {
   \                     OSQDel: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    179              OS_OBJ_QTY     nbr_tasks;
    180              OS_PEND_LIST  *p_pend_list;
    181              OS_TCB        *p_tcb;
    182              CPU_TS         ts;
    183              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    184          
    185          
    186          #ifdef OS_SAFETY_CRITICAL
    187              if (p_err == DEF_NULL) {
    188                  OS_SAFETY_CRITICAL_EXCEPTION();
    189                  return (0u);
    190              }
    191          #endif
    192          
    193              OS_TRACE_Q_DEL_ENTER(p_q, opt);
    194          
    195          #ifdef OS_SAFETY_CRITICAL_IEC61508
    196              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    197                  OS_TRACE_Q_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    198                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    199                  return (0u);
    200              }
    201          #endif
    202          
    203          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    204              if (OSIntNestingCtr > 0u) {                                 /* Can't delete a message queue from an ISR             */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSQDel_0
    205                  OS_TRACE_Q_DEL_EXIT(OS_ERR_DEL_ISR);
    206                 *p_err = OS_ERR_DEL_ISR;
   \   00000018   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001C   0x8030             STRH     R0,[R6, #+0]
    207                  return (0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE074             B.N      ??OSQDel_1
    208              }
    209          #endif
    210          
    211          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    212              if (OSRunning != OS_STATE_OS_RUNNING) {
    213                  OS_TRACE_Q_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    214                 *p_err = OS_ERR_OS_NOT_RUNNING;
    215                  return (0u);
    216              }
    217          #endif
    218          
    219          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    220              if (p_q == DEF_NULL) {                                      /* Validate 'p_q'                                       */
   \                     ??OSQDel_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSQDel_2
    221                  OS_TRACE_Q_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    222                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    223                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE06D             B.N      ??OSQDel_1
    224              }
    225          #endif
    226          
    227          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    228              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQDel_2: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x55455551
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD004             BEQ.N    ??OSQDel_3
    229                  OS_TRACE_Q_DEL_EXIT(OS_ERR_OBJ_TYPE);
    230                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000003A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000003E   0x8030             STRH     R0,[R6, #+0]
    231                  return (0u);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE063             B.N      ??OSQDel_1
    232              }
    233          #endif
    234          
    235              CPU_CRITICAL_ENTER();
   \                     ??OSQDel_3: (+1)
   \   00000044   0x.... 0x....      BL       CPU_SR_Save
   \   00000048   0x4683             MOV      R11,R0
   \   0000004A   0x.... 0x....      BL       CPU_IntDisMeasStart
    236              p_pend_list = &p_q->PendList;
   \   0000004E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000052   0x4680             MOV      R8,R0
    237              nbr_tasks   = 0u;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x0007             MOVS     R7,R0
    238              switch (opt) {
   \   00000058   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD002             BEQ.N    ??OSQDel_4
   \   0000005E   0x2D01             CMP      R5,#+1
   \   00000060   0xD022             BEQ.N    ??OSQDel_5
   \   00000062   0xE049             B.N      ??OSQDel_6
    239                  case OS_OPT_DEL_NO_PEND:                                /* Delete message queue only if no task waiting         */
    240                       if (p_pend_list->HeadPtr == DEF_NULL) {
   \                     ??OSQDel_4: (+1)
   \   00000064   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD114             BNE.N    ??OSQDel_7
    241          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    242                           OS_QDbgListRemove(p_q);
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       OS_QDbgListRemove
    243                           OSQQty--;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   00000076   0x8800             LDRH     R0,[R0, #+0]
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \   0000007E   0x8008             STRH     R0,[R1, #+0]
    244          #endif
    245                           OS_TRACE_Q_DEL(p_q);
    246                           OS_QClr(p_q);
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       OS_QClr
    247                           CPU_CRITICAL_EXIT();
   \   00000086   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008A   0x4658             MOV      R0,R11
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
    248                          *p_err = OS_ERR_NONE;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x8030             STRH     R0,[R6, #+0]
   \   00000094   0xE007             B.N      ??OSQDel_8
    249                       } else {
    250                           CPU_CRITICAL_EXIT();
   \                     ??OSQDel_7: (+1)
   \   00000096   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x.... 0x....      BL       CPU_SR_Restore
    251                          *p_err = OS_ERR_TASK_WAITING;
   \   000000A0   0xF247 0x105F      MOVW     R0,#+29023
   \   000000A4   0x8030             STRH     R0,[R6, #+0]
    252                       }
    253                       break;
   \                     ??OSQDel_8: (+1)
   \   000000A6   0xE02F             B.N      ??OSQDel_9
    254          
    255                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the message queue                      */
    256          #if (OS_CFG_TS_EN == DEF_ENABLED)
    257                       ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
   \                     ??OSQDel_5: (+1)
   \   000000A8   0x.... 0x....      BL       CPU_TS_TmrRd
   \   000000AC   0x4682             MOV      R10,R0
    258          #else
    259                       ts = 0u;
    260          #endif
    261                       while (p_pend_list->HeadPtr != DEF_NULL) {         /* Remove all tasks from the pend list                  */
   \                     ??OSQDel_10: (+1)
   \   000000AE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD009             BEQ.N    ??OSQDel_11
    262                           p_tcb = p_pend_list->HeadPtr;
   \   000000B6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000BA   0x4681             MOV      R9,R0
    263                           OS_PendAbort(p_tcb,
    264                                        ts,
    265                                        OS_STATUS_PEND_DEL);
   \   000000BC   0x2202             MOVS     R2,#+2
   \   000000BE   0x4651             MOV      R1,R10
   \   000000C0   0x4648             MOV      R0,R9
   \   000000C2   0x.... 0x....      BL       OS_PendAbort
    266                           nbr_tasks++;
   \   000000C6   0x1C7F             ADDS     R7,R7,#+1
   \   000000C8   0xE7F1             B.N      ??OSQDel_10
    267                       }
    268          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    269                       OS_QDbgListRemove(p_q);
   \                     ??OSQDel_11: (+1)
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       OS_QDbgListRemove
    270                       OSQQty--;
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable8_4
   \   000000D4   0x8800             LDRH     R0,[R0, #+0]
   \   000000D6   0x1E40             SUBS     R0,R0,#+1
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable8_4
   \   000000DC   0x8008             STRH     R0,[R1, #+0]
    271          #endif
    272                       OS_TRACE_Q_DEL(p_q);
    273                       OS_QClr(p_q);
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       OS_QClr
    274                       CPU_CRITICAL_EXIT();
   \   000000E4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E8   0x4658             MOV      R0,R11
   \   000000EA   0x.... 0x....      BL       CPU_SR_Restore
    275                       OSSched();                                         /* Find highest priority task ready to run              */
   \   000000EE   0x.... 0x....      BL       OSSched
    276                      *p_err = OS_ERR_NONE;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x8030             STRH     R0,[R6, #+0]
    277                       break;
   \   000000F6   0xE007             B.N      ??OSQDel_9
    278          
    279                  default:
    280                       CPU_CRITICAL_EXIT();
   \                     ??OSQDel_6: (+1)
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FC   0x4658             MOV      R0,R11
   \   000000FE   0x.... 0x....      BL       CPU_SR_Restore
    281                      *p_err = OS_ERR_OPT_INVALID;
   \   00000102   0xF645 0x6025      MOVW     R0,#+24101
   \   00000106   0x8030             STRH     R0,[R6, #+0]
    282                       break;
    283              }
    284              OS_TRACE_Q_DEL_EXIT(*p_err);
    285              return (nbr_tasks);
   \                     ??OSQDel_9: (+1)
   \   00000108   0x0038             MOVS     R0,R7
   \   0000010A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQDel_1: (+1)
   \   0000010C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    286          }
    287          #endif
    288          
    289          
    290          /*
    291          ************************************************************************************************************************
    292          *                                                     FLUSH QUEUE
    293          *
    294          * Description : This function is used to flush the contents of the message queue.
    295          *
    296          * Arguments   : p_q        is a pointer to the message queue to flush
    297          *
    298          *               p_err      is a pointer to a variable that will contain an error code returned by this function.
    299          *
    300          *                              OS_ERR_NONE              Upon success
    301          *                              OS_ERR_FLUSH_ISR         If you called this function from an ISR
    302          *                              OS_ERR_OBJ_PTR_NULL      If you passed a NULL pointer for 'p_q'
    303          *                              OS_ERR_OBJ_TYPE          If you didn't create the message queue
    304          *                              OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    305          *
    306          * Returns     : == 0       if no entries were freed, or upon error.
    307          *               >  0       the number of freed entries.
    308          *
    309          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    310          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    311          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    312          *                  likely, need to be de-allocated (i.e. freed).
    313          ************************************************************************************************************************
    314          */
    315          
    316          #if (OS_CFG_Q_FLUSH_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    317          OS_MSG_QTY  OSQFlush (OS_Q    *p_q,
    318                                OS_ERR  *p_err)
    319          {
   \                     OSQFlush: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    320              OS_MSG_QTY  entries;
    321              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    322          
    323          
    324          
    325          #ifdef OS_SAFETY_CRITICAL
    326              if (p_err == DEF_NULL) {
    327                  OS_SAFETY_CRITICAL_EXCEPTION();
    328                  return (0u);
    329              }
    330          #endif
    331          
    332          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    333              if (OSIntNestingCtr > 0u) {                                 /* Can't flush a message queue from an ISR              */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSQFlush_0
    334                 *p_err = OS_ERR_FLUSH_ISR;
   \   00000012   0xF44F 0x506C      MOV      R0,#+15104
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    335                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE023             B.N      ??OSQFlush_1
    336              }
    337          #endif
    338          
    339          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    340              if (OSRunning != OS_STATE_OS_RUNNING) {
    341                 *p_err = OS_ERR_OS_NOT_RUNNING;
    342                  return (0u);
    343              }
    344          #endif
    345          
    346          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    347              if (p_q == DEF_NULL) {                                      /* Validate arguments                                   */
   \                     ??OSQFlush_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??OSQFlush_2
    348                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    349                  return (0u);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE01C             B.N      ??OSQFlush_1
    350              }
    351          #endif
    352          
    353          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    354              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQFlush_2: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x55455551
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD004             BEQ.N    ??OSQFlush_3
    355                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000034   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    356                  return (0u);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE012             B.N      ??OSQFlush_1
    357              }
    358          #endif
    359          
    360              CPU_CRITICAL_ENTER();
   \                     ??OSQFlush_3: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0007             MOVS     R7,R0
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStart
    361              entries = OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the OS_MSG pool                */
   \   00000048   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000004C   0x.... 0x....      BL       OS_MsgQFreeAll
   \   00000050   0x0006             MOVS     R6,R0
    362              CPU_CRITICAL_EXIT();
   \   00000052   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    363             *p_err   = OS_ERR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x8028             STRH     R0,[R5, #+0]
    364              return (entries);
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQFlush_1: (+1)
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    365          }
    366          #endif
    367          
    368          
    369          /*
    370          ************************************************************************************************************************
    371          *                                            PEND ON A QUEUE FOR A MESSAGE
    372          *
    373          * Description: This function waits for a message to be sent to a queue.
    374          *
    375          * Arguments  : p_q           is a pointer to the message queue
    376          *
    377          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    378          *                            message to arrive at the queue up to the amount of time specified by this argument.  If you
    379          *                            specify 0, however, your task will wait forever at the specified queue or, until a message
    380          *                            arrives.
    381          *
    382          *              opt           determines whether the user wants to block if the queue is empty or not:
    383          *
    384          *                                OS_OPT_PEND_BLOCKING
    385          *                                OS_OPT_PEND_NON_BLOCKING
    386          *
    387          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    388          *
    389          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    390          *                            received, pend aborted or the message queue deleted,  If you pass a NULL pointer (i.e.
    391          *                            (CPU_TS *)0) then you will not get the timestamp.  In other words, passing a NULL pointer
    392          *                            is valid and indicates that you don't need the timestamp.
    393          *
    394          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    395          *
    396          *                                OS_ERR_NONE               The call was successful and your task received a message
    397          *                                OS_ERR_OBJ_DEL            If 'p_q' was deleted
    398          *                                OS_ERR_OBJ_PTR_NULL       If you pass a NULL pointer for 'p_q'
    399          *                                OS_ERR_OBJ_TYPE           If the message queue was not created
    400          *                                OS_ERR_OPT_INVALID        You specified an invalid option
    401          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    402          *                                OS_ERR_PEND_ABORT         The pend was aborted
    403          *                                OS_ERR_PEND_ISR           If you called this function from an ISR
    404          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    405          *                                OS_ERR_PTR_INVALID        If you passed a NULL pointer of 'p_msg_size'
    406          *                                OS_ERR_SCHED_LOCKED       The scheduler is locked
    407          *                                OS_ERR_STATUS_INVALID     If the pend status has an invalid value
    408          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    409          *                                                          would lead to a suspension.
    410          *
    411          * Returns    : != (void *)0  is a pointer to the message received
    412          *              == (void *)0  if you received a NULL pointer message or,
    413          *                            if no message was received or,
    414          *                            if 'p_q' is a NULL pointer or,
    415          *                            if you didn't pass a pointer to a queue.
    416          *
    417          * Note(s)    : none
    418          ************************************************************************************************************************
    419          */
    420          

   \                                 In section .text, align 2, keep-with-next
    421          void  *OSQPend (OS_Q         *p_q,
    422                          OS_TICK       timeout,
    423                          OS_OPT        opt,
    424                          OS_MSG_SIZE  *p_msg_size,
    425                          CPU_TS       *p_ts,
    426                          OS_ERR       *p_err)
    427          {
   \                     OSQPend: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   00000010   0xF8DD 0x902C      LDR      R9,[SP, #+44]
    428              void  *p_void;
    429              CPU_SR_ALLOC();
   \   00000014   0xF05F 0x0B00      MOVS     R11,#+0
    430          
    431          
    432          #ifdef OS_SAFETY_CRITICAL
    433              if (p_err == DEF_NULL) {
    434                  OS_SAFETY_CRITICAL_EXCEPTION();
    435                  return (DEF_NULL);
    436              }
    437          #endif
    438          
    439              OS_TRACE_Q_PEND_ENTER(p_q, timeout, opt, p_msg_size, p_ts);
    440          
    441          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    442              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD005             BEQ.N    ??OSQPend_0
    443                  OS_TRACE_Q_PEND_FAILED(p_q);
    444                  OS_TRACE_Q_PEND_EXIT(OS_ERR_PEND_ISR);
    445                 *p_err = OS_ERR_PEND_ISR;
   \   00000022   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000026   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    446                  return (DEF_NULL);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE0CF             B.N      ??OSQPend_1
    447              }
    448          #endif
    449          
    450          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    451              if (OSRunning != OS_STATE_OS_RUNNING) {
    452                  OS_TRACE_Q_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    453                 *p_err = OS_ERR_OS_NOT_RUNNING;
    454                  return (DEF_NULL);
    455              }
    456          #endif
    457          
    458          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    459              if (p_q == DEF_NULL) {                                      /* Validate arguments                                   */
   \                     ??OSQPend_0: (+1)
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD105             BNE.N    ??OSQPend_2
    460                  OS_TRACE_Q_PEND_FAILED(p_q);
    461                  OS_TRACE_Q_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    462                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000032   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000036   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    463                  return (DEF_NULL);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE0C7             B.N      ??OSQPend_1
    464              }
    465              if (p_msg_size == DEF_NULL) {
   \                     ??OSQPend_2: (+1)
   \   0000003E   0x2F00             CMP      R7,#+0
   \   00000040   0xD105             BNE.N    ??OSQPend_3
    466                  OS_TRACE_Q_PEND_FAILED(p_q);
    467                  OS_TRACE_Q_PEND_EXIT(OS_ERR_PTR_INVALID);
    468                 *p_err = OS_ERR_PTR_INVALID;
   \   00000042   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000046   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    469                  return (DEF_NULL);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE0BF             B.N      ??OSQPend_1
    470              }
    471              switch (opt) {
   \                     ??OSQPend_3: (+1)
   \   0000004E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD002             BEQ.N    ??OSQPend_4
   \   00000056   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005A   0xD105             BNE.N    ??OSQPend_5
    472                  case OS_OPT_PEND_BLOCKING:
    473                  case OS_OPT_PEND_NON_BLOCKING:
    474                       break;
    475          
    476                  default:
    477                       OS_TRACE_Q_PEND_FAILED(p_q);
    478                       OS_TRACE_Q_PEND_EXIT(OS_ERR_OPT_INVALID);
    479                      *p_err = OS_ERR_OPT_INVALID;
    480                       return (DEF_NULL);
    481              }
    482          #endif
    483          
    484          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    485              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQPend_4: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x55455551
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD106             BNE.N    ??OSQPend_6
   \   00000066   0xE00B             B.N      ??OSQPend_7
   \                     ??OSQPend_5: (+1)
   \   00000068   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE0AC             B.N      ??OSQPend_1
    486                  OS_TRACE_Q_PEND_FAILED(p_q);
    487                  OS_TRACE_Q_PEND_EXIT(OS_ERR_OBJ_TYPE);
    488                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSQPend_6: (+1)
   \   00000074   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000078   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    489                  return (DEF_NULL);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE0A6             B.N      ??OSQPend_1
    490              }
    491          #endif
    492          
    493              if (p_ts != DEF_NULL) {
   \                     ??OSQPend_7: (+1)
   \   00000080   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000084   0xD002             BEQ.N    ??OSQPend_8
    494                 *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF8C8 0x0000      STR      R0,[R8, #+0]
    495              }
    496          
    497              CPU_CRITICAL_ENTER();
   \                     ??OSQPend_8: (+1)
   \   0000008C   0x.... 0x....      BL       CPU_SR_Save
   \   00000090   0x4683             MOV      R11,R0
   \   00000092   0x.... 0x....      BL       CPU_IntDisMeasStart
    498              p_void = OS_MsgQGet(&p_q->MsgQ,                             /* Any message waiting in the message queue?            */
    499                                  p_msg_size,
    500                                  p_ts,
    501                                  p_err);
   \   00000096   0x464B             MOV      R3,R9
   \   00000098   0x4642             MOV      R2,R8
   \   0000009A   0x0039             MOVS     R1,R7
   \   0000009C   0xF114 0x0020      ADDS     R0,R4,#+32
   \   000000A0   0x.... 0x....      BL       OS_MsgQGet
   \   000000A4   0x4682             MOV      R10,R0
    502              if (*p_err == OS_ERR_NONE) {
   \   000000A6   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD106             BNE.N    ??OSQPend_9
    503                  OS_TRACE_Q_PEND(p_q);
    504                  CPU_CRITICAL_EXIT();
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
    505                  OS_TRACE_Q_PEND_EXIT(OS_ERR_NONE);
    506                  return (p_void);                                        /* Yes, Return message received                         */
   \   000000B8   0x4650             MOV      R0,R10
   \   000000BA   0xE088             B.N      ??OSQPend_1
    507              }
    508          
    509              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSQPend_9: (+1)
   \   000000BC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000BE   0x0430             LSLS     R0,R6,#+16
   \   000000C0   0xD50A             BPL.N    ??OSQPend_10
    510                  CPU_CRITICAL_EXIT();
   \   000000C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C6   0x4658             MOV      R0,R11
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    511                  OS_TRACE_Q_PEND_FAILED(p_q);
    512                  OS_TRACE_Q_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    513                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \   000000CC   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000D0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    514                  return (DEF_NULL);
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xE07A             B.N      ??OSQPend_1
    515              } else {
    516                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSQPend_10: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable8_5
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD00A             BEQ.N    ??OSQPend_11
    517                      CPU_CRITICAL_EXIT();
   \   000000E2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E6   0x4658             MOV      R0,R11
   \   000000E8   0x.... 0x....      BL       CPU_SR_Restore
    518                      OS_TRACE_Q_PEND_FAILED(p_q);
    519                      OS_TRACE_Q_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    520                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000EC   0xF646 0x5063      MOVW     R0,#+28003
   \   000000F0   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    521                      return (DEF_NULL);
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xE06A             B.N      ??OSQPend_1
    522                  }
    523              }
    524          
    525              OS_Pend((OS_PEND_OBJ *)((void *)p_q),                       /* Block task pending on Message Queue                  */
    526                      OS_TASK_PEND_ON_Q,
    527                      timeout);
   \                     ??OSQPend_11: (+1)
   \   000000F8   0x002A             MOVS     R2,R5
   \   000000FA   0x2105             MOVS     R1,#+5
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x.... 0x....      BL       OS_Pend
    528              CPU_CRITICAL_EXIT();
   \   00000102   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000106   0x4658             MOV      R0,R11
   \   00000108   0x.... 0x....      BL       CPU_SR_Restore
    529              OS_TRACE_Q_PEND_BLOCK(p_q);
    530              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   0000010C   0x.... 0x....      BL       OSSched
    531          
    532              CPU_CRITICAL_ENTER();
   \   00000110   0x.... 0x....      BL       CPU_SR_Save
   \   00000114   0x4683             MOV      R11,R0
   \   00000116   0x.... 0x....      BL       CPU_IntDisMeasStart
    533              switch (OSTCBCurPtr->PendStatus) {
   \   0000011A   0x....             LDR.N    R0,??DataTable8_6
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD005             BEQ.N    ??OSQPend_12
   \   00000126   0x2802             CMP      R0,#+2
   \   00000128   0xD032             BEQ.N    ??OSQPend_13
   \   0000012A   0xD317             BCC.N    ??OSQPend_14
   \   0000012C   0x2803             CMP      R0,#+3
   \   0000012E   0xD026             BEQ.N    ??OSQPend_15
   \   00000130   0xE03F             B.N      ??OSQPend_16
    534                  case OS_STATUS_PEND_OK:                                 /* Extract message from TCB (Put there by Post)         */
    535                       p_void     = OSTCBCurPtr->MsgPtr;
   \                     ??OSQPend_12: (+1)
   \   00000132   0x....             LDR.N    R0,??DataTable8_6
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0x6E00             LDR      R0,[R0, #+96]
   \   00000138   0x4682             MOV      R10,R0
    536                      *p_msg_size = OSTCBCurPtr->MsgSize;
   \   0000013A   0x....             LDR.N    R0,??DataTable8_6
   \   0000013C   0x6800             LDR      R0,[R0, #+0]
   \   0000013E   0xF8B0 0x0064      LDRH     R0,[R0, #+100]
   \   00000142   0x8038             STRH     R0,[R7, #+0]
    537          #if (OS_CFG_TS_EN == DEF_ENABLED)
    538                       if (p_ts  != DEF_NULL) {
   \   00000144   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000148   0xD004             BEQ.N    ??OSQPend_17
    539                          *p_ts  =  OSTCBCurPtr->TS;
   \   0000014A   0x....             LDR.N    R0,??DataTable8_6
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0x6D00             LDR      R0,[R0, #+80]
   \   00000150   0xF8C8 0x0000      STR      R0,[R8, #+0]
    540                       }
    541          #endif
    542                       OS_TRACE_Q_PEND(p_q);
    543                      *p_err      = OS_ERR_NONE;
   \                     ??OSQPend_17: (+1)
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    544                       break;
   \   0000015A   0xE032             B.N      ??OSQPend_18
    545          
    546                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    547                       p_void     = DEF_NULL;
   \                     ??OSQPend_14: (+1)
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x4682             MOV      R10,R0
    548                      *p_msg_size = 0u;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x8038             STRH     R0,[R7, #+0]
    549          #if (OS_CFG_TS_EN == DEF_ENABLED)
    550                       if (p_ts  != DEF_NULL) {
   \   00000164   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000168   0xD004             BEQ.N    ??OSQPend_19
    551                          *p_ts  =  OSTCBCurPtr->TS;
   \   0000016A   0x....             LDR.N    R0,??DataTable8_6
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x6D00             LDR      R0,[R0, #+80]
   \   00000170   0xF8C8 0x0000      STR      R0,[R8, #+0]
    552                       }
    553          #endif
    554                       OS_TRACE_Q_PEND_FAILED(p_q);
    555                      *p_err      = OS_ERR_PEND_ABORT;
   \                     ??OSQPend_19: (+1)
   \   00000174   0xF246 0x10A9      MOVW     R0,#+25001
   \   00000178   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    556                       break;
   \   0000017C   0xE021             B.N      ??OSQPend_18
    557          
    558                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get event within TO          */
    559                       p_void     = DEF_NULL;
   \                     ??OSQPend_15: (+1)
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x4682             MOV      R10,R0
    560                      *p_msg_size = 0u;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x8038             STRH     R0,[R7, #+0]
    561                       OS_TRACE_Q_PEND_FAILED(p_q);
    562                      *p_err      = OS_ERR_TIMEOUT;
   \   00000186   0xF247 0x20D9      MOVW     R0,#+29401
   \   0000018A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    563                       break;
   \   0000018E   0xE018             B.N      ??OSQPend_18
    564          
    565                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    566                       p_void     = DEF_NULL;
   \                     ??OSQPend_13: (+1)
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0x4682             MOV      R10,R0
    567                      *p_msg_size = 0u;
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0x8038             STRH     R0,[R7, #+0]
    568          #if (OS_CFG_TS_EN == DEF_ENABLED)
    569                       if (p_ts  != DEF_NULL) {
   \   00000198   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000019C   0xD004             BEQ.N    ??OSQPend_20
    570                          *p_ts  =  OSTCBCurPtr->TS;
   \   0000019E   0x....             LDR.N    R0,??DataTable8_6
   \   000001A0   0x6800             LDR      R0,[R0, #+0]
   \   000001A2   0x6D00             LDR      R0,[R0, #+80]
   \   000001A4   0xF8C8 0x0000      STR      R0,[R8, #+0]
    571                       }
    572          #endif
    573                       OS_TRACE_Q_PEND_FAILED(p_q);
    574                      *p_err      = OS_ERR_OBJ_DEL;
   \                     ??OSQPend_20: (+1)
   \   000001A8   0xF645 0x50C2      MOVW     R0,#+24002
   \   000001AC   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    575                       break;
   \   000001B0   0xE007             B.N      ??OSQPend_18
    576          
    577                  default:
    578                       p_void     = DEF_NULL;
   \                     ??OSQPend_16: (+1)
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x4682             MOV      R10,R0
    579                      *p_msg_size = 0u;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x8038             STRH     R0,[R7, #+0]
    580                       OS_TRACE_Q_PEND_FAILED(p_q);
    581                      *p_err      = OS_ERR_STATUS_INVALID;
   \   000001BA   0xF646 0x602E      MOVW     R0,#+28206
   \   000001BE   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    582                       break;
    583              }
    584              CPU_CRITICAL_EXIT();
   \                     ??OSQPend_18: (+1)
   \   000001C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001C6   0x4658             MOV      R0,R11
   \   000001C8   0x.... 0x....      BL       CPU_SR_Restore
    585              OS_TRACE_Q_PEND_EXIT(*p_err);
    586              return (p_void);
   \   000001CC   0x4650             MOV      R0,R10
   \                     ??OSQPend_1: (+1)
   \   000001CE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    587          }
    588          
    589          
    590          /*
    591          ************************************************************************************************************************
    592          *                                             ABORT WAITING ON A MESSAGE QUEUE
    593          *
    594          * Description: This function aborts & readies any tasks currently waiting on a queue.  This function should be used to
    595          *              fault-abort the wait on the queue, rather than to normally signal the queue via OSQPost().
    596          *
    597          * Arguments  : p_q       is a pointer to the message queue
    598          *
    599          *              opt       determines the type of ABORT performed:
    600          *
    601          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the queue
    602          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the queue
    603          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    604          *
    605          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    606          *
    607          *                            OS_ERR_NONE                  At least one task waiting on the queue was readied and
    608          *                                                         informed of the aborted wait; check return value for the
    609          *                                                         number of tasks whose wait on the queue was aborted
    610          *                            OS_ERR_OBJ_PTR_NULL          If you pass a NULL pointer for 'p_q'
    611          *                            OS_ERR_OBJ_TYPE              If the message queue was not created
    612          *                            OS_ERR_OPT_INVALID           You specified an invalid option
    613          *                            OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    614          *                            OS_ERR_PEND_ABORT_ISR        If this function was called from an ISR
    615          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    616          *
    617          * Returns    : == 0      if no tasks were waiting on the queue, or upon error.
    618          *              >  0      if one or more tasks waiting on the queue are now readied and informed.
    619          *
    620          * Note(s)    : none
    621          ************************************************************************************************************************
    622          */
    623          
    624          #if (OS_CFG_Q_PEND_ABORT_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    625          OS_OBJ_QTY  OSQPendAbort (OS_Q    *p_q,
    626                                    OS_OPT   opt,
    627                                    OS_ERR  *p_err)
    628          {
   \                     OSQPendAbort: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    629              OS_PEND_LIST  *p_pend_list;
    630              OS_TCB        *p_tcb;
    631              CPU_TS         ts;
    632              OS_OBJ_QTY     nbr_tasks;
    633              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    634          
    635          
    636          #ifdef OS_SAFETY_CRITICAL
    637              if (p_err == DEF_NULL) {
    638                  OS_SAFETY_CRITICAL_EXCEPTION();
    639                  return (0u);
    640              }
    641          #endif
    642          
    643          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    644              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   0000000E   0x....             LDR.N    R0,??DataTable8_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSQPendAbort_0
    645                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000016   0xF246 0x10AA      MOVW     R0,#+25002
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
    646                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE05A             B.N      ??OSQPendAbort_1
    647              }
    648          #endif
    649          
    650          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    651              if (OSRunning != OS_STATE_OS_RUNNING) {
    652                 *p_err = OS_ERR_OS_NOT_RUNNING;
    653                  return (0u);
    654              }
    655          #endif
    656          
    657          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    658              if (p_q == DEF_NULL) {                                      /* Validate 'p_q'                                       */
   \                     ??OSQPendAbort_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD104             BNE.N    ??OSQPendAbort_2
    659                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8030             STRH     R0,[R6, #+0]
    660                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE053             B.N      ??OSQPendAbort_1
    661              }
    662              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSQPendAbort_2: (+1)
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD008             BEQ.N    ??OSQPendAbort_3
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xD005             BEQ.N    ??OSQPendAbort_3
   \   0000003C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000040   0xD002             BEQ.N    ??OSQPendAbort_3
   \   00000042   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000046   0xD104             BNE.N    ??OSQPendAbort_4
    663                  case OS_OPT_PEND_ABORT_1:
    664                  case OS_OPT_PEND_ABORT_ALL:
    665                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    666                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    667                       break;
    668          
    669                  default:
    670                      *p_err =  OS_ERR_OPT_INVALID;
    671                       return (0u);
    672              }
    673          #endif
    674          
    675          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    676              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure queue was created                          */
   \                     ??OSQPendAbort_3: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x....             LDR.N    R1,??DataTable8_3  ;; 0x55455551
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD105             BNE.N    ??OSQPendAbort_5
   \   00000050   0xE009             B.N      ??OSQPendAbort_6
   \                     ??OSQPendAbort_4: (+1)
   \   00000052   0xF645 0x6025      MOVW     R0,#+24101
   \   00000056   0x8030             STRH     R0,[R6, #+0]
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE03C             B.N      ??OSQPendAbort_1
    677                 *p_err =  OS_ERR_OBJ_TYPE;
   \                     ??OSQPendAbort_5: (+1)
   \   0000005C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000060   0x8030             STRH     R0,[R6, #+0]
    678                  return (0u);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE037             B.N      ??OSQPendAbort_1
    679              }
    680          #endif
    681          
    682              CPU_CRITICAL_ENTER();
   \                     ??OSQPendAbort_6: (+1)
   \   00000066   0x.... 0x....      BL       CPU_SR_Save
   \   0000006A   0x4683             MOV      R11,R0
   \   0000006C   0x.... 0x....      BL       CPU_IntDisMeasStart
    683              p_pend_list = &p_q->PendList;
   \   00000070   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000074   0x0007             MOVS     R7,R0
    684              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on queue?                           */
   \   00000076   0x6838             LDR      R0,[R7, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD109             BNE.N    ??OSQPendAbort_7
    685                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   0000007C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000080   0x4658             MOV      R0,R11
   \   00000082   0x.... 0x....      BL       CPU_SR_Restore
    686                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   00000086   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000008A   0x8030             STRH     R0,[R6, #+0]
    687                  return (0u);
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE022             B.N      ??OSQPendAbort_1
    688              }
    689          
    690              nbr_tasks = 0u;
   \                     ??OSQPendAbort_7: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x4682             MOV      R10,R0
    691          #if (OS_CFG_TS_EN == DEF_ENABLED)
    692              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
   \   00000094   0x.... 0x....      BL       CPU_TS_TmrRd
   \   00000098   0x4681             MOV      R9,R0
    693          #else
    694              ts        = 0u;
    695          #endif
    696              while (p_pend_list->HeadPtr != DEF_NULL) {
   \                     ??OSQPendAbort_8: (+1)
   \   0000009A   0x6838             LDR      R0,[R7, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD00C             BEQ.N    ??OSQPendAbort_9
    697                  p_tcb = p_pend_list->HeadPtr;
   \   000000A0   0x6838             LDR      R0,[R7, #+0]
   \   000000A2   0x4680             MOV      R8,R0
    698                  OS_PendAbort(p_tcb,
    699                               ts,
    700                               OS_STATUS_PEND_ABORT);
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0x4649             MOV      R1,R9
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0x.... 0x....      BL       OS_PendAbort
    701                  nbr_tasks++;
   \   000000AE   0xF11A 0x0A01      ADDS     R10,R10,#+1
    702                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   000000B2   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000B4   0xF5B5 0x7F80      CMP      R5,#+256
   \   000000B8   0xD0EF             BEQ.N    ??OSQPendAbort_8
    703                      break;                                              /* No                                                   */
    704                  }
    705              }
    706              CPU_CRITICAL_EXIT();
   \                     ??OSQPendAbort_9: (+1)
   \   000000BA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BE   0x4658             MOV      R0,R11
   \   000000C0   0x.... 0x....      BL       CPU_SR_Restore
    707          
    708              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000C4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000C6   0x0428             LSLS     R0,R5,#+16
   \   000000C8   0xD401             BMI.N    ??OSQPendAbort_10
    709                  OSSched();                                              /* Run the scheduler                                    */
   \   000000CA   0x.... 0x....      BL       OSSched
    710              }
    711          
    712             *p_err = OS_ERR_NONE;
   \                     ??OSQPendAbort_10: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x8030             STRH     R0,[R6, #+0]
    713              return (nbr_tasks);
   \   000000D2   0x4650             MOV      R0,R10
   \   000000D4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQPendAbort_1: (+1)
   \   000000D6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    714          }
    715          #endif
    716          
    717          
    718          /*
    719          ************************************************************************************************************************
    720          *                                               POST MESSAGE TO A QUEUE
    721          *
    722          * Description: This function sends a message to a queue.  With the 'opt' argument, you can specify whether the message
    723          *              is broadcast to all waiting tasks and/or whether you post the message to the front of the queue (LIFO)
    724          *              or normally (FIFO) at the end of the queue.
    725          *
    726          * Arguments  : p_q           is a pointer to a message queue that must have been created by OSQCreate().
    727          *
    728          *              p_void        is a pointer to the message to send.
    729          *
    730          *              msg_size      specifies the size of the message (in bytes)
    731          *
    732          *              opt           determines the type of POST performed:
    733          *
    734          *                                OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the queue.  This option
    735          *                                                         can be added to either OS_OPT_POST_FIFO or OS_OPT_POST_LIFO
    736          *                                OS_OPT_POST_FIFO         POST message to end of queue (FIFO) and wake up a single
    737          *                                                         waiting task.
    738          *                                OS_OPT_POST_LIFO         POST message to the front of the queue (LIFO) and wake up
    739          *                                                         a single waiting task.
    740          *                                OS_OPT_POST_NO_SCHED     Do not call the scheduler
    741          *
    742          *                            Note(s): 1) OS_OPT_POST_NO_SCHED can be added (or OR'd) with one of the other options.
    743          *                                     2) OS_OPT_POST_ALL      can be added (or OR'd) with one of the other options.
    744          *                                     3) Possible combination of options are:
    745          *
    746          *                                        OS_OPT_POST_FIFO
    747          *                                        OS_OPT_POST_LIFO
    748          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL
    749          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL
    750          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_NO_SCHED
    751          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_NO_SCHED
    752          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    753          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    754          *
    755          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    756          *
    757          *                                OS_ERR_NONE              The call was successful and the message was sent
    758          *                                OS_ERR_MSG_POOL_EMPTY    If there are no more OS_MSGs to use to place the message into
    759          *                                OS_ERR_OBJ_PTR_NULL      If 'p_q' is a NULL pointer
    760          *                                OS_ERR_OBJ_TYPE          If the message queue was not initialized
    761          *                                OS_ERR_OPT_INVALID       You specified an invalid option
    762          *                                OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    763          *                                OS_ERR_Q_MAX             If the queue is full
    764          *
    765          * Returns    : None
    766          *
    767          * Note(s)    : none
    768          ************************************************************************************************************************
    769          */
    770          

   \                                 In section .text, align 2, keep-with-next
    771          void  OSQPost (OS_Q         *p_q,
    772                         void         *p_void,
    773                         OS_MSG_SIZE   msg_size,
    774                         OS_OPT        opt,
    775                         OS_ERR       *p_err)
    776          {
   \                     OSQPost: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8038      LDR      R8,[SP, #+56]
    777              OS_OPT         post_type;
    778              OS_PEND_LIST  *p_pend_list;
    779              OS_TCB        *p_tcb;
    780              OS_TCB        *p_tcb_next;
    781              CPU_TS         ts;
    782              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0B00      MOVS     R11,#+0
    783          
    784          
    785          #ifdef OS_SAFETY_CRITICAL
    786              if (p_err == DEF_NULL) {
    787                  OS_SAFETY_CRITICAL_EXCEPTION();
    788                  return;
    789              }
    790          #endif
    791          
    792              OS_TRACE_Q_POST_ENTER(p_q, p_void, msg_size, opt);
    793          
    794          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    795              if (OSRunning != OS_STATE_OS_RUNNING) {
    796                  OS_TRACE_Q_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    797                 *p_err = OS_ERR_OS_NOT_RUNNING;
    798                  return;
    799              }
    800          #endif
    801          
    802          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    803              if (p_q == DEF_NULL) {                                      /* Validate 'p_q'                                       */
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD104             BNE.N    ??OSQPost_0
    804                  OS_TRACE_Q_POST_FAILED(p_q);
    805                  OS_TRACE_Q_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    806                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000001A   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000001E   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    807                  return;
   \   00000022   0xE079             B.N      ??OSQPost_1
    808              }
    809              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSQPost_0: (+1)
   \   00000024   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD015             BEQ.N    ??OSQPost_2
   \   0000002C   0x2810             CMP      R0,#+16
   \   0000002E   0xD013             BEQ.N    ??OSQPost_2
   \   00000030   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000034   0xD010             BEQ.N    ??OSQPost_2
   \   00000036   0xF5B0 0x7F04      CMP      R0,#+528
   \   0000003A   0xD00D             BEQ.N    ??OSQPost_2
   \   0000003C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000040   0xD00A             BEQ.N    ??OSQPost_2
   \   00000042   0xF248 0x0110      MOVW     R1,#+32784
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD006             BEQ.N    ??OSQPost_2
   \   0000004A   0xF5B0 0x4F02      CMP      R0,#+33280
   \   0000004E   0xD003             BEQ.N    ??OSQPost_2
   \   00000050   0xF248 0x2110      MOVW     R1,#+33296
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD104             BNE.N    ??OSQPost_3
    810                  case OS_OPT_POST_FIFO:
    811                  case OS_OPT_POST_LIFO:
    812                  case OS_OPT_POST_FIFO | OS_OPT_POST_ALL:
    813                  case OS_OPT_POST_LIFO | OS_OPT_POST_ALL:
    814                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
    815                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
    816                  case OS_OPT_POST_FIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    817                  case OS_OPT_POST_LIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    818                       break;
    819          
    820                  default:
    821                       OS_TRACE_Q_POST_FAILED(p_q);
    822                       OS_TRACE_Q_POST_EXIT(OS_ERR_OPT_INVALID);
    823                      *p_err =  OS_ERR_OPT_INVALID;
    824                       return;
    825              }
    826          #endif
    827          
    828          #if (OS_CFG_OBJ_TYPE_CHK_EN == DEF_ENABLED)
    829              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQPost_2: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x....             LDR.N    R1,??DataTable8_3  ;; 0x55455551
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD105             BNE.N    ??OSQPost_4
   \   00000060   0xE009             B.N      ??OSQPost_5
   \                     ??OSQPost_3: (+1)
   \   00000062   0xF645 0x6025      MOVW     R0,#+24101
   \   00000066   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000006A   0xE055             B.N      ??OSQPost_1
    830                  OS_TRACE_Q_POST_FAILED(p_q);
    831                  OS_TRACE_Q_POST_EXIT(OS_ERR_OBJ_TYPE);
    832                 *p_err = OS_ERR_OBJ_TYPE;
   \                     ??OSQPost_4: (+1)
   \   0000006C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000070   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    833                  return;
   \   00000074   0xE050             B.N      ??OSQPost_1
    834              }
    835          #endif
    836          #if (OS_CFG_TS_EN == DEF_ENABLED)
    837              ts = OS_TS_GET();                                           /* Get timestamp                                        */
   \                     ??OSQPost_5: (+1)
   \   00000076   0x.... 0x....      BL       CPU_TS_TmrRd
   \   0000007A   0x4682             MOV      R10,R0
    838          #else
    839              ts = 0u;
    840          #endif
    841          
    842              OS_TRACE_Q_POST(p_q);
    843          
    844              CPU_CRITICAL_ENTER();
   \   0000007C   0x.... 0x....      BL       CPU_SR_Save
   \   00000080   0x4683             MOV      R11,R0
   \   00000082   0x.... 0x....      BL       CPU_IntDisMeasStart
    845              p_pend_list = &p_q->PendList;
   \   00000086   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000008A   0x9003             STR      R0,[SP, #+12]
    846              if (p_pend_list->HeadPtr == DEF_NULL) {                     /* Any task waiting on message queue?                   */
   \   0000008C   0x9803             LDR      R0,[SP, #+12]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD11C             BNE.N    ??OSQPost_6
    847                  if ((opt & OS_OPT_POST_LIFO) == 0u) {                   /* Determine whether we post FIFO or LIFO               */
   \   00000094   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000096   0x06F8             LSLS     R0,R7,#+27
   \   00000098   0xD403             BMI.N    ??OSQPost_7
    848                      post_type = OS_OPT_POST_FIFO;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \   000000A0   0xE002             B.N      ??OSQPost_8
    849                  } else {
    850                      post_type = OS_OPT_POST_LIFO;
   \                     ??OSQPost_7: (+1)
   \   000000A2   0x2010             MOVS     R0,#+16
   \   000000A4   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    851                  }
    852                  OS_MsgQPut(&p_q->MsgQ,                                  /* Place message in the message queue                   */
    853                             p_void,
    854                             msg_size,
    855                             post_type,
    856                             ts,
    857                             p_err);
   \                     ??OSQPost_8: (+1)
   \   000000A8   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   000000AC   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   000000B0   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \   000000B4   0x0032             MOVS     R2,R6
   \   000000B6   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000B8   0x0029             MOVS     R1,R5
   \   000000BA   0xF114 0x0020      ADDS     R0,R4,#+32
   \   000000BE   0x.... 0x....      BL       OS_MsgQPut
    858                  CPU_CRITICAL_EXIT();
   \   000000C2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C6   0x4658             MOV      R0,R11
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    859                  OS_TRACE_Q_POST_EXIT(*p_err);
    860                  return;
   \   000000CC   0xE024             B.N      ??OSQPost_1
    861              }
    862          
    863              p_tcb = p_pend_list->HeadPtr;
   \                     ??OSQPost_6: (+1)
   \   000000CE   0x9803             LDR      R0,[SP, #+12]
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x4681             MOV      R9,R0
    864              while (p_tcb != DEF_NULL) {
   \                     ??OSQPost_9: (+1)
   \   000000D4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D8   0xD011             BEQ.N    ??OSQPost_10
    865                  p_tcb_next = p_tcb->PendNextPtr;
   \   000000DA   0xF8D9 0x0030      LDR      R0,[R9, #+48]
   \   000000DE   0x9004             STR      R0,[SP, #+16]
    866                  OS_Post((OS_PEND_OBJ *)((void *)p_q),
    867                          p_tcb,
    868                          p_void,
    869                          msg_size,
    870                          ts);
   \   000000E0   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   000000E4   0x0033             MOVS     R3,R6
   \   000000E6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000E8   0x002A             MOVS     R2,R5
   \   000000EA   0x4649             MOV      R1,R9
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       OS_Post
    871                  if ((opt & OS_OPT_POST_ALL) == 0u)  {                   /* Post message to all tasks waiting?                   */
   \   000000F2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000F4   0x05B8             LSLS     R0,R7,#+22
   \   000000F6   0xD502             BPL.N    ??OSQPost_10
    872                      break;                                              /* No                                                   */
    873                  }
    874                  p_tcb = p_tcb_next;
   \                     ??OSQPost_11: (+1)
   \   000000F8   0x9804             LDR      R0,[SP, #+16]
   \   000000FA   0x4681             MOV      R9,R0
   \   000000FC   0xE7EA             B.N      ??OSQPost_9
    875              }
    876          
    877              CPU_CRITICAL_EXIT();
   \                     ??OSQPost_10: (+1)
   \   000000FE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000102   0x4658             MOV      R0,R11
   \   00000104   0x.... 0x....      BL       CPU_SR_Restore
    878          
    879              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000108   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000010A   0x0438             LSLS     R0,R7,#+16
   \   0000010C   0xD401             BMI.N    ??OSQPost_12
    880                  OSSched();                                              /* Run the scheduler                                    */
   \   0000010E   0x.... 0x....      BL       OSSched
    881              }
    882          
    883             *p_err = OS_ERR_NONE;
   \                     ??OSQPost_12: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    884              OS_TRACE_Q_POST_EXIT(*p_err);
    885          }
   \                     ??OSQPost_1: (+1)
   \   00000118   0xB005             ADD      SP,SP,#+20
   \   0000011A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    886          
    887          
    888          /*
    889          ************************************************************************************************************************
    890          *                                        CLEAR THE CONTENTS OF A MESSAGE QUEUE
    891          *
    892          * Description: This function is called by OSQDel() to clear the contents of a message queue
    893          *
    894          
    895          * Argument(s): p_q      is a pointer to the queue to clear
    896          *              ---
    897          *
    898          * Returns    : none
    899          *
    900          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    901          ************************************************************************************************************************
    902          */
    903          

   \                                 In section .text, align 2, keep-with-next
    904          void  OS_QClr (OS_Q  *p_q)
    905          {
   \                     OS_QClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    906              (void)OS_MsgQFreeAll(&p_q->MsgQ);                           /* Return all OS_MSGs to the free list                  */
   \   00000004   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000008   0x.... 0x....      BL       OS_MsgQFreeAll
    907          #if (OS_OBJ_TYPE_REQ == DEF_ENABLED)
    908              p_q->Type    =  OS_OBJ_TYPE_NONE;                           /* Mark the data structure as a NONE                    */
   \   0000000C   0x....             LDR.N    R0,??DataTable8_7  ;; 0x454e4f4e
   \   0000000E   0x6020             STR      R0,[R4, #+0]
    909          #endif
    910          #if (OS_CFG_DBG_EN == DEF_ENABLED)
    911              p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
   \   00000010   0x....             ADR.N    R0,??DataTable8  ;; 0x3F, 0x51, 0x00, 0x00
   \   00000012   0x6060             STR      R0,[R4, #+4]
    912          #endif
    913              OS_MsgQInit(&p_q->MsgQ,                                     /* Initialize the list of OS_MSGs                       */
    914                          0u);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF114 0x0020      ADDS     R0,R4,#+32
   \   0000001A   0x.... 0x....      BL       OS_MsgQInit
    915              OS_PendListInit(&p_q->PendList);                            /* Initialize the waiting list                          */
   \   0000001E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000022   0x.... 0x....      BL       OS_PendListInit
    916          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    917          
    918          
    919          /*
    920          ************************************************************************************************************************
    921          *                                      ADD/REMOVE MESSAGE QUEUE TO/FROM DEBUG LIST
    922          *
    923          * Description: These functions are called by uC/OS-III to add or remove a message queue to/from a message queue debug
    924          *              list.
    925          *
    926          * Arguments  : p_q     is a pointer to the message queue to add/remove
    927          *
    928          * Returns    : none
    929          *
    930          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    931          ************************************************************************************************************************
    932          */
    933          
    934          #if (OS_CFG_DBG_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    935          void  OS_QDbgListAdd (OS_Q  *p_q)
    936          {
    937              p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \                     OS_QDbgListAdd: (+1)
   \   00000000   0x....             ADR.N    R1,??DataTable8_1  ;; " "
   \   00000002   0x61C1             STR      R1,[R0, #+28]
    938              p_q->DbgPrevPtr               = DEF_NULL;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6141             STR      R1,[R0, #+20]
    939              if (OSQDbgListPtr == DEF_NULL) {
   \   00000008   0x....             LDR.N    R1,??DataTable8_8
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??OS_QDbgListAdd_0
    940                  p_q->DbgNextPtr           = DEF_NULL;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
   \   00000014   0xE005             B.N      ??OS_QDbgListAdd_1
    941              } else {
    942                  p_q->DbgNextPtr           =  OSQDbgListPtr;
   \                     ??OS_QDbgListAdd_0: (+1)
   \   00000016   0x....             LDR.N    R1,??DataTable8_8
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x6181             STR      R1,[R0, #+24]
    943                  OSQDbgListPtr->DbgPrevPtr =  p_q;
   \   0000001C   0x....             LDR.N    R1,??DataTable8_8
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6148             STR      R0,[R1, #+20]
    944              }
    945              OSQDbgListPtr                 =  p_q;
   \                     ??OS_QDbgListAdd_1: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable8_8
   \   00000024   0x6008             STR      R0,[R1, #+0]
    946          }
   \   00000026   0x4770             BX       LR               ;; return
    947          
    948          

   \                                 In section .text, align 2, keep-with-next
    949          void  OS_QDbgListRemove (OS_Q  *p_q)
    950          {
    951              OS_Q  *p_q_next;
    952              OS_Q  *p_q_prev;
    953          
    954          
    955              p_q_prev = p_q->DbgPrevPtr;
   \                     OS_QDbgListRemove: (+1)
   \   00000000   0x6943             LDR      R3,[R0, #+20]
   \   00000002   0x001A             MOVS     R2,R3
    956              p_q_next = p_q->DbgNextPtr;
   \   00000004   0x6983             LDR      R3,[R0, #+24]
   \   00000006   0x0019             MOVS     R1,R3
    957          
    958              if (p_q_prev == DEF_NULL) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD108             BNE.N    ??OS_QDbgListRemove_0
    959                  OSQDbgListPtr = p_q_next;
   \   0000000C   0x....             LDR.N    R3,??DataTable8_8
   \   0000000E   0x6019             STR      R1,[R3, #+0]
    960                  if (p_q_next != DEF_NULL) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ.N    ??OS_QDbgListRemove_1
    961                      p_q_next->DbgPrevPtr = DEF_NULL;
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x614B             STR      R3,[R1, #+20]
    962                  }
    963                  p_q->DbgNextPtr = DEF_NULL;
   \                     ??OS_QDbgListRemove_1: (+1)
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x6183             STR      R3,[R0, #+24]
   \   0000001C   0xE00C             B.N      ??OS_QDbgListRemove_2
    964          
    965              } else if (p_q_next == DEF_NULL) {
   \                     ??OS_QDbgListRemove_0: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OS_QDbgListRemove_3
    966                  p_q_prev->DbgNextPtr = DEF_NULL;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x6193             STR      R3,[R2, #+24]
    967                  p_q->DbgPrevPtr      = DEF_NULL;
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x6143             STR      R3,[R0, #+20]
   \   0000002A   0xE005             B.N      ??OS_QDbgListRemove_2
    968          
    969              } else {
    970                  p_q_prev->DbgNextPtr =  p_q_next;
   \                     ??OS_QDbgListRemove_3: (+1)
   \   0000002C   0x6191             STR      R1,[R2, #+24]
    971                  p_q_next->DbgPrevPtr =  p_q_prev;
   \   0000002E   0x614A             STR      R2,[R1, #+20]
    972                  p_q->DbgNextPtr      = DEF_NULL;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x6183             STR      R3,[R0, #+24]
    973                  p_q->DbgPrevPtr      = DEF_NULL;
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x6143             STR      R3,[R0, #+20]
    974              }
    975          }
   \                     ??OS_QDbgListRemove_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x3F 0x51          DC8      0x3F, 0x51, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x55455551         DC32     0x55455551

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSQQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     OSQDbgListPtr

   \                                 In section .rodata, align 4
   \   00000000   0x3F 0x51          DC8 "?Q"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "
    976          #endif
    977          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSQCreate
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQInit
        24   -> OS_PendListInit
        24   -> OS_QDbgListAdd
      40   OSQDel
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_PendAbort
        40   -> OS_QClr
        40   -> OS_QDbgListRemove
      24   OSQFlush
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQFreeAll
      40   OSQPend
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_MsgQGet
        40   -> OS_Pend
      40   OSQPendAbort
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_TS_TmrRd
        40   -> OSSched
        40   -> OS_PendAbort
      56   OSQPost
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> CPU_TS_TmrRd
        56   -> OSSched
        56   -> OS_MsgQPut
        56   -> OS_Post
       8   OS_QClr
         8   -> OS_MsgQFreeAll
         8   -> OS_MsgQInit
         8   -> OS_PendListInit
       0   OS_QDbgListAdd
       0   OS_QDbgListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ?_0
       2  ?_1
     136  OSQCreate
     272  OSQDel
     102  OSQFlush
     466  OSQPend
     218  OSQPendAbort
     286  OSQPost
      40  OS_QClr
      40  OS_QDbgListAdd
      58  OS_QDbgListRemove

 
     6 bytes in section .rodata
 1 654 bytes in section .text
 
 1 654 bytes of CODE  memory
     6 bytes of CONST memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       18/Dec/2017  15:36:22
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320 IC卡模块\Application\Library\CardOperations\Card.c
#    Command line =  
#        "F:\iar\NC136B-320 IC卡模块\Application\Library\CardOperations\Card.c"
#        -lCN "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\Card.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\Card.o
#
###############################################################################

F:\iar\NC136B-320 IC卡模块\Application\Library\CardOperations\Card.c
      1          //#include 	"config.h"
      2          //#include 	"string.h"
      3          //#include 	"CpuDrive.h"
      4          //#include 	"HardDrive.h"
      5          
      6          #include    "includes.h"  
      7          #include    "card.h"  
      8          
      9          
     10          #define		SCK_IC	120//P004  
     11          #define		MISO_IC	123//P005  
     12          #define		MOSI_IC	124//P006 
     13          #define     SSEL0	7//P007
     14          
     15          #define		CS_IC	127//P228	
     16          #define		SOFT_SPI_CS_IC	CS_IC//P228	
     17          #define		POW_IC	211//P028
     18          
     19          #define		IC_SWT	200//P029
     20          #define		IC_RST	212//P230
     21          #define		FINISH		1
     22          #define		UNFINISH	0
     23          

   \                                 In section .bss, align 4
     24          uint32		l_Spi0Len 	= 0;
   \                     l_Spi0Len:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     25          uint32		l_Spi0Point = 0;
   \                     l_Spi0Point:
   \   00000000                      DS8 4
     26          //uint8_t		Spi0SendBuf[256*1];
     27          //uint8_t		Spi0RevBuf[256*1];

   \                                 In section .data, align 1
     28          uint8_t		Spi0FinishFlg = FINISH;
   \                     Spi0FinishFlg:
   \   00000000   0x01               DC8 1
     29          
     30          
     31          /***********************************************
     32          * 描述: OS接口
     33          */
     34          

   \                                 In section .bss, align 4
     35          OS_SEM			    Bsp_Card_Sem;    	//信号量 IC卡的信号量
   \                     Bsp_Card_Sem:
   \   00000000                      DS8 40
     36          
     37              
     38          

   \                                 In section .text, align 2, keep-with-next
     39          void SSP0_Init(void)
     40          {
   \                     SSP0_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     41          	SSP_CFG_Type SSP_ConfigStruct;
     42          
     43          	SSP_ConfigStructInit(&SSP_ConfigStruct);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       SSP_ConfigStructInit
     44          	// Initialize SSP peripheral with parameter given in structure above
     45          	SSP_Init(LPC_SSP0, &SSP_ConfigStruct);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   00000010   0x.... 0x....      BL       SSP_Init
     46          
     47          	// Enable SSP peripheral
     48          	SSP_Cmd(LPC_SSP0, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   0000001A   0x.... 0x....      BL       SSP_Cmd
     49          }		 
   \   0000001E   0xB007             ADD      SP,SP,#+28
   \   00000020   0xBD00             POP      {PC}             ;; return
     50          
     51          /*******************************************************************************
     52           * 名    称： InitCardIO
     53           * 功    能： IC卡接口初始化。
     54          
     55           * 入口参数： 无
     56           * 出口参数： 无
     57           * 作　 　者： redmorningcn.
     58           * 创建日期： 2017-05-31
     59           * 修    改：
     60           * 修改日期：
     61           * 备    注： 任务创建函数需要在app.h文件中声明
     62           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     63          void InitCardIO( void )
     64          {
   \                     InitCardIO: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     65          	//初始化SPI接口，CS控制端口、SW接口
     66              GPIO_PinselConfig(SCK_IC,3);
   \   00000002   0x2103             MOVS     R1,#+3
   \   00000004   0x2078             MOVS     R0,#+120
   \   00000006   0x.... 0x....      BL       GPIO_PinselConfig
     67          	GPIO_PinselConfig(MOSI_IC,3);
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x207C             MOVS     R0,#+124
   \   0000000E   0x.... 0x....      BL       GPIO_PinselConfig
     68          	GPIO_PinselConfig(MISO_IC,3);
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x207B             MOVS     R0,#+123
   \   00000016   0x.... 0x....      BL       GPIO_PinselConfig
     69          	GPIO_PinselConfig(SOFT_SPI_CS_IC,0);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x207F             MOVS     R0,#+127
   \   0000001E   0x.... 0x....      BL       GPIO_PinselConfig
     70          	GPIO_PinselConfig(IC_SWT,0);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x20C8             MOVS     R0,#+200
   \   00000026   0x.... 0x....      BL       GPIO_PinselConfig
     71          
     72              //SSP0初始化
     73          	SSP0_Init();
   \   0000002A   0x.... 0x....      BL       SSP0_Init
     74              
     75              //OS接口。
     76          //    #if ( OS_VERSION > 30000U )
     77                  BSP_OS_SemCreate(&Bsp_Card_Sem, 0, "card Sem");     //IC卡信号量
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable19_1
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000038   0x.... 0x....      BL       BSP_OS_SemCreate
     78          //    #endif
     79          }
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
     80          
     81          
     82          //------------------------------------------------------------------------
     83          //  名  称 ：void WriteMOSI_IC( uint8_t temp )
     84          //  功  能 ：设置 MOSI_IC
     85          // 入口参数：无
     86          // 出口参数：无
     87          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     88          void WriteSoftSpiCSIC(uint8_t temp)
     89          {	
   \                     WriteSoftSpiCSIC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     90          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteSoftSpiCSIC_0
     91          	{
     92          		GPIO_SetOrClearValue(SOFT_SPI_CS_IC,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x207F             MOVS     R0,#+127
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteSoftSpiCSIC_1
     93          	}
     94          	else
     95          	{
     96          		GPIO_SetOrClearValue(SOFT_SPI_CS_IC,0);		
   \                     ??WriteSoftSpiCSIC_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x207F             MOVS     R0,#+127
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
     97          	}	
     98          
     99          	nop();		
   \                     ??WriteSoftSpiCSIC_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
    100          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    101          

   \                                 In section .text, align 2, keep-with-next
    102          uint8_t SendOrRecByte_SPI_IC(uint8_t data)
    103          {
   \                     SendOrRecByte_SPI_IC: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    104          	uint8_t	tmp;
    105          
    106              while((LPC_SSP0->SR & 0x04) == 0x04)
   \                     ??SendOrRecByte_SPI_IC_0: (+1)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable19_3  ;; 0x4008800c
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0752             LSLS     R2,R2,#+29
   \   0000000A   0xD504             BPL.N    ??SendOrRecByte_SPI_IC_1
    107          	{
    108          		tmp	= LPC_SSP0->DR; 
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable19_4  ;; 0x40088008
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x0010             MOVS     R0,R2
   \   00000014   0xE7F5             B.N      ??SendOrRecByte_SPI_IC_0
    109          	}
    110          	while ((LPC_SSP0->SR & 0x02) == 0);                                 /* 等待发送FIFO留出空间         */   
   \                     ??SendOrRecByte_SPI_IC_1: (+1)
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable19_3  ;; 0x4008800c
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x0792             LSLS     R2,R2,#+30
   \   0000001E   0xD5FA             BPL.N    ??SendOrRecByte_SPI_IC_1
    111              LPC_SSP0->DR = data;
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable19_4  ;; 0x40088008
   \   00000026   0x6011             STR      R1,[R2, #+0]
    112              while ((LPC_SSP0->SR & 0x10) == 0x10);                              /* 等待数据帧发送完毕           */ 
   \                     ??SendOrRecByte_SPI_IC_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable19_3  ;; 0x4008800c
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x06D2             LSLS     R2,R2,#+27
   \   00000030   0xD4FA             BMI.N    ??SendOrRecByte_SPI_IC_2
    113          	
    114          	while((LPC_SSP0->SR & 0x04) == 0x04)
   \                     ??SendOrRecByte_SPI_IC_3: (+1)
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable19_3  ;; 0x4008800c
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0x0752             LSLS     R2,R2,#+29
   \   0000003A   0xD504             BPL.N    ??SendOrRecByte_SPI_IC_4
    115          	{
    116          		tmp	= LPC_SSP0->DR; 
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable19_4  ;; 0x40088008
   \   00000040   0x6812             LDR      R2,[R2, #+0]
   \   00000042   0x0010             MOVS     R0,R2
   \   00000044   0xE7F5             B.N      ??SendOrRecByte_SPI_IC_3
    117          	}
    118              return tmp;
   \                     ??SendOrRecByte_SPI_IC_4: (+1)
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x4770             BX       LR               ;; return
    119          }
    120          
    121          
    122          

   \                                 In section .text, align 2, keep-with-next
    123          void	SendByte_SPI_IC(uint8_t	ch)
    124          {
   \                     SendByte_SPI_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    125          	SendOrRecByte_SPI_IC(ch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendOrRecByte_SPI_IC
    126          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    127          

   \                                 In section .text, align 2, keep-with-next
    128          uint8_t	RecByte_SPI_IC(void)
    129          {
   \                     RecByte_SPI_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    130          	uint8_t		ch =0;
   \   00000002   0x2400             MOVS     R4,#+0
    131          	return	SendOrRecByte_SPI_IC(ch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendOrRecByte_SPI_IC
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    132          }
    133          
    134          
    135          
    136          //------------------------------------------------------------------------
    137          // 名    称：   uint8_t SentByte_SPI(uint8_t  Dat8)
    138          // 功    能：   SPI口0串口发送1个数据
    139          // 入口参数：   Dat8:数据缓
    140          // 出口参数：	(主机)
    141          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    142          uint8_t SentByte_SPI(uint8_t  Dat8)
    143          {
   \                     SentByte_SPI: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    144          	SendByte_SPI_IC(Dat8);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendByte_SPI_IC
    145          	return 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    146          }
    147          
    148          //------------------------------------------------------------------------
    149          // 名    称：   uint8_t RevByte_SPI(void)
    150          // 功    能：   SPI0查询方式接收数据                  	
    151          // 入口参数：  
    152          // 出口参数：	接收到的数据
    153          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    154          uint8_t RevByte_SPI(void)
    155          {
   \                     RevByte_SPI: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    156              uint8_t	Tmp;
    157              
    158          	Tmp = RecByte_SPI_IC();
   \   00000002   0x.... 0x....      BL       RecByte_SPI_IC
   \   00000006   0x0004             MOVS     R4,R0
    159                  
    160              return  Tmp;                  			//清发送完成标识
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    161          }
    162          
    163          //------------------------------------------------------------------------
    164          //  名  称 ：void WritePOW_IC( uint8_t temp )
    165          //  功  能 ：设置 POW_IC
    166          // 入口参数：无
    167          // 出口参数：无
    168          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    169          void WritePOW_IC(uint8_t temp)
    170          {
   \                     WritePOW_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    171          	nop();		
   \   00000004   0x.... 0x....      BL       `nop`
    172          	
    173          	if(temp)		
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD004             BEQ.N    ??WritePOW_IC_0
    174          	{
    175          		GPIO_SetOrClearValue(POW_IC,1);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x20D3             MOVS     R0,#+211
   \   00000012   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000016   0xE003             B.N      ??WritePOW_IC_1
    176          	}
    177          	else
    178          	{
    179          		GPIO_SetOrClearValue(POW_IC,0);		
   \                     ??WritePOW_IC_0: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x20D3             MOVS     R0,#+211
   \   0000001C   0x.... 0x....      BL       GPIO_SetOrClearValue
    180          	}	
    181          
    182          	nop();		
   \                     ??WritePOW_IC_1: (+1)
   \   00000020   0x.... 0x....      BL       `nop`
    183          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    184          
    185          //------------------------------------------------------------------------------------------
    186          //  名  称 ：void WriteCS_IC( uint8_t temp )
    187          //  功  能 ：设置 CS_IC
    188          // 入口参数：无
    189          // 出口参数：无
    190          //-----------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    191          void WriteCS_IC(uint8_t temp)
    192          {
   \                     WriteCS_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    193          	GPIO_PinselConfig(CS_IC,0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x207F             MOVS     R0,#+127
   \   00000008   0x.... 0x....      BL       GPIO_PinselConfig
    194          	
    195          	nop();
   \   0000000C   0x.... 0x....      BL       `nop`
    196          	if(temp)		
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD004             BEQ.N    ??WriteCS_IC_0
    197          	{
    198          		GPIO_SetOrClearValue(CS_IC,1);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x207F             MOVS     R0,#+127
   \   0000001A   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000001E   0xE003             B.N      ??WriteCS_IC_1
    199          	}
    200          	else
    201          	{
    202          		GPIO_SetOrClearValue(CS_IC,0);		
   \                     ??WriteCS_IC_0: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x207F             MOVS     R0,#+127
   \   00000024   0x.... 0x....      BL       GPIO_SetOrClearValue
    203          	}
    204          	nop();	
   \                     ??WriteCS_IC_1: (+1)
   \   00000028   0x.... 0x....      BL       `nop`
    205          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    206          
    207          //--------------------------------------------------------------------------------------------
    208          //  名  称 ：void WriteIC_RST( uint8_t temp )
    209          //  功  能 ：设置 IC_RST
    210          // 入口参数：无
    211          // 出口参数：无
    212          //----------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    213          void WriteIC_RST(uint8_t temp)
    214          {
   \                     WriteIC_RST: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    215          	GPIO_PinselConfig(IC_RST,0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x20D4             MOVS     R0,#+212
   \   00000008   0x.... 0x....      BL       GPIO_PinselConfig
    216          	
    217          	if(temp)		
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD004             BEQ.N    ??WriteIC_RST_0
    218          	{
    219          		GPIO_SetOrClearValue(IC_RST,1);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x20D4             MOVS     R0,#+212
   \   00000016   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000001A   0xE003             B.N      ??WriteIC_RST_1
    220          	}
    221          	else
    222          	{
    223          		GPIO_SetOrClearValue(IC_RST,0);		
   \                     ??WriteIC_RST_0: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x20D4             MOVS     R0,#+212
   \   00000020   0x.... 0x....      BL       GPIO_SetOrClearValue
    224          	}		
    225          }
   \                     ??WriteIC_RST_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    226          //--------------------------------------------------------------------------------------------
    227          //  名  称 ：void WriteIC_SWT( uint8_t temp )
    228          //  功  能 ：设置 IC_SWT
    229          // 入口参数：无
    230          // 出口参数：无
    231          //---------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    232          void WriteIC_SWT(uint8_t temp)
    233          {
   \                     WriteIC_SWT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    234          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteIC_SWT_0
    235          	{
    236          		GPIO_SetOrClearValue(IC_SWT,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x20C8             MOVS     R0,#+200
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteIC_SWT_1
    237          	}
    238          	else
    239          	{
    240          		GPIO_SetOrClearValue(IC_SWT,0);		
   \                     ??WriteIC_SWT_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x20C8             MOVS     R0,#+200
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    241          	}	
    242          }
   \                     ??WriteIC_SWT_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    243          
    244          //-----------------------------------------------------------------------------------------------
    245          //  名  称 ：uint8_t ReadIC_SWT(void)
    246          //  功  能 ：读取 IC_SWT 的值
    247          // 入口参数：无
    248          // 出口参数：无
    249          //------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    250          uint8_t ReadIC_SWT(void)
    251          {
   \                     ReadIC_SWT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    252          	uint8_t	Tmp;
    253          
    254          	nop();	
   \   00000002   0x.... 0x....      BL       `nop`
    255          	Tmp = 	GPIO_ReadIoVal(IC_SWT);
   \   00000006   0x20C8             MOVS     R0,#+200
   \   00000008   0x.... 0x....      BL       GPIO_ReadIoVal
   \   0000000C   0x0004             MOVS     R4,R0
    256          
    257          	return Tmp;	
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    258          }
    259          
    260          
    261          
    262          //定义AT45DB041D命令    命令针对于PAGESIZE=l_CardPageSize-------------------------------------- 
    263          #define    	READ_STU               0x57            //读状态字命令
    264          #define    	CON_ARR_READ           0xe8            //continuous array read code
    265          #define    	BUFF1_WRITE            0x84            //write buffer1
    266          #define    	BUFF2_WRITE            0x87            //write buffer2
    267          #define    	BUFF1_TO_MEM           0x83            //BUFFER1 to Main Memory Page Program with Built-in Erase
    268          #define    	BUFF2_TO_MEM           0x86            //BUFFER1 to Main Memory Page Program with Built-in Erase
    269          
    270          //#define    BUFF1_READ             0xD4            //read Buff1
    271          //#define    BUFF2_READ             0xD6            //read Buff2
    272          #define    	BUFF1_READ             0x54            //read Buff1
    273          #define   	BUFF2_READ             0x56            //read Buff2
    274          #define    	MEM_TO_BUFF1           0x53            //
    275          #define    	MEM_TO_BUFF2           0x55            //
    276          //IC卡参数

   \                                 In section .bss, align 4
    277          uint32		l_CardPageSize;	
   \                     l_CardPageSize:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    278          uint32		l_CardStartAddr;	
   \                     l_CardStartAddr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    279          uint32		l_CardPageNum;
   \                     l_CardPageNum:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    280          uint8_t		l_CardTypeFlg;
   \                     l_CardTypeFlg:
   \   00000000                      DS8 1
    281          
    282          //-------------------------------------------------------------------------------
    283          //Status Register Format:
    284          //   -----------------------------------------------------------------------
    285          //  |  bit7  |  bit6   |  bit5  |  bit4  |  bit3  |  bit2  |  bit1  |  bit0  |
    286          //  |--------|---------|---------|--------|---------|---------|---------|--------|
    287          //  |RDY/BUSY|  COMP  |   0    |   1    |   1    |   1    |   X    |   X    | */
    288          //
    289          //bit7 - 忙标记，0为忙1为不忙
    290          //当Status Register的位0移出之后，接下来的时钟脉冲序列将使SPI器件继续将最新的状态字节送出。
    291          //bit6 - 标记最近一次Main Memory Page和Buffer的比较结果，0相同，1不同。
    292          //bit5
    293          //bit4
    294          //bit3
    295          //bit2 - 这4位用来标记器件密度，对于AT45DB041B，这4位应该是0111，一共能标记16种不同密度的器件
    296          //bit1
    297          //bit0 - 这2位暂时无效
    298          //函数实现对AT45DB041D芯片状态字读出功能
    299          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    300          uint8_t   StatusRegisterRead_Card(void)
    301          {
   \                     StatusRegisterRead_Card: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    302              uint8_t Statues;
    303          
    304              WriteCS_IC(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       WriteCS_IC
    305              
    306          	WriteCS_IC(0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       WriteCS_IC
    307              WriteCS_IC(0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       WriteCS_IC
    308              
    309              SentByte_SPI(READ_STU);                          	//发送读状态存储器命令
   \   00000014   0x2057             MOVS     R0,#+87
   \   00000016   0x.... 0x....      BL       SentByte_SPI
    310              Statues = RevByte_SPI();                       		//读取状态寄存器命令
   \   0000001A   0x.... 0x....      BL       RevByte_SPI
   \   0000001E   0x0004             MOVS     R4,R0
    311          
    312              WriteCS_IC(1);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       WriteCS_IC
    313          
    314              return Statues;
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    315          }
    316          
    317          //------------------------------------------------------------------------
    318          // 名    称：   void   InitCardInfo(void)				
    319          // 功    能：   初始化IC卡参数     	
    320          // 入口参数：  	无
    321          // 出口参数：	无
    322          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    323          void   InitCardInfo(void)								
    324          {
   \                     InitCardInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    325          	uint8_t	CardState;
    326          	CardState = StatusRegisterRead_Card();
   \   00000002   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000006   0x0004             MOVS     R4,R0
    327          	
    328          	if((CardState & 0x3c) == AT45DB041)
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000000E   0x281C             CMP      R0,#+28
   \   00000010   0xD112             BNE.N    ??InitCardInfo_0
    329          	{
    330          		l_CardPageSize	= 256;	
   \   00000012   0xF44F 0x7080      MOV      R0,#+256
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    331          		l_CardStartAddr	= 0;	
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable19_6
   \   00000022   0x6008             STR      R0,[R1, #+0]
    332          		l_CardPageNum	= 2048;
   \   00000024   0xF44F 0x6000      MOV      R0,#+2048
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable19_7
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    333          		l_CardTypeFlg	= AT45DB041;
   \   0000002E   0x201C             MOVS     R0,#+28
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable19_8
   \   00000034   0x7008             STRB     R0,[R1, #+0]
   \   00000036   0xE046             B.N      ??InitCardInfo_1
    334          	}
    335          	else if((CardState & 0x3c) == AT45DB161)
   \                     ??InitCardInfo_0: (+1)
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000003E   0x282C             CMP      R0,#+44
   \   00000040   0xD112             BNE.N    ??InitCardInfo_2
    336          	{
    337          		l_CardPageSize	= 512;	
   \   00000042   0xF44F 0x7000      MOV      R0,#+512
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    338          		l_CardStartAddr	= 0;	
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable19_6
   \   00000052   0x6008             STR      R0,[R1, #+0]
    339          		l_CardPageNum	= 4096;
   \   00000054   0xF44F 0x5080      MOV      R0,#+4096
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable19_7
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    340          		l_CardTypeFlg	= AT45DB161;		
   \   0000005E   0x202C             MOVS     R0,#+44
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable19_8
   \   00000064   0x7008             STRB     R0,[R1, #+0]
   \   00000066   0xE02E             B.N      ??InitCardInfo_1
    341          	}	
    342          	else if((CardState & 0x3c) == AT45DB321)
   \                     ??InitCardInfo_2: (+1)
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000006E   0x2834             CMP      R0,#+52
   \   00000070   0xD112             BNE.N    ??InitCardInfo_3
    343          	{
    344          		l_CardPageSize	= 512;	
   \   00000072   0xF44F 0x7000      MOV      R0,#+512
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    345          		l_CardStartAddr	= 0;	
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable19_6
   \   00000082   0x6008             STR      R0,[R1, #+0]
    346          		l_CardPageNum	= 8192;
   \   00000084   0xF44F 0x5000      MOV      R0,#+8192
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable19_7
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    347          		l_CardTypeFlg	= AT45DB321;		
   \   0000008E   0x2034             MOVS     R0,#+52
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable19_8
   \   00000094   0x7008             STRB     R0,[R1, #+0]
   \   00000096   0xE016             B.N      ??InitCardInfo_1
    348          	}	
    349          	else if((CardState & 0x3c) == AT45DB642)
   \                     ??InitCardInfo_3: (+1)
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000009E   0x283C             CMP      R0,#+60
   \   000000A0   0xD111             BNE.N    ??InitCardInfo_1
    350          	{
    351          		l_CardPageSize	= 1024;	
   \   000000A2   0xF44F 0x6080      MOV      R0,#+1024
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    352          		l_CardStartAddr	= 0;	
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable19_6
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    353          		l_CardPageNum	= 8192;
   \   000000B4   0xF44F 0x5000      MOV      R0,#+8192
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable19_7
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    354          		l_CardTypeFlg	= AT45DB642;		
   \   000000BE   0x203C             MOVS     R0,#+60
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable19_8
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
    355          	}		
    356          	
    357          	//printfcom0("\r\n l_CardPageSize %d l_CardStartAddr %d l_CardPageNum %d l_CardTypeFlg %d ",l_CardPageSize,l_CardStartAddr,l_CardPageNum,l_CardTypeFlg);	
    358          }
   \                     ??InitCardInfo_1: (+1)
   \   000000C6   0xBD10             POP      {R4,PC}          ;; return
    359          
    360          //------------------------------------------------------------------------
    361          // 名    称：   uint32   GetCardPageSize(void)			//取IC卡页大小
    362          // 功    能：   初始化IC卡参数     	
    363          // 入口参数：  
    364          // 出口参数：	
    365          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    366          uint32   GetCardPageSize(void)							//取IC卡页大小
    367          {
    368          	return	l_CardPageSize;
   \                     GetCardPageSize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    369          }
    370          
    371          //-------------------------------------------------------------------------------
    372          //描述：
    373          //    When the Flsh bit in the main memory array has been read,the device will
    374          //    continue reading back at the beginning of the first page of memory.As w-
    375          //    ith crossing over page boundaries,no Delays will be incurred when wrapp-
    376          //    ing around from the end of the array to the beginning of the array.
    377          //参数：
    378          //    PA      - 页地址，0~2047
    379          //    BFA     - 指定BUFFER中的起始写入地址
    380          //    pHeader - 指定数据的首地址
    381          //    len     - 指定数据的长度
    382          //函数现象连续读取AT45DB041D存储空间功能
    383          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    384          void    ContinuousArrayRead_Card(uint16 PA,uint16 BFA,uint8_t *pHeader,uint16 Len)
    385          {
   \                     ContinuousArrayRead_Card: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
    386              uint16 i = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    387          /**/
    388              while(i++ < 255)                                  		//确认AT45DB041D准备,确认256次后退出等待
   \                     ??ContinuousArrayRead_Card_0: (+1)
   \   0000000E   0x0038             MOVS     R0,R7
   \   00000010   0x1C47             ADDS     R7,R0,#+1
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xDA03             BGE.N    ??ContinuousArrayRead_Card_1
    389              {
    390                  if(StatusRegisterRead_Card() & 0x80)              	//准备完成,进行后续操作
   \   00000018   0x.... 0x....      BL       StatusRegisterRead_Card
   \   0000001C   0x0600             LSLS     R0,R0,#+24
   \   0000001E   0xD5F6             BPL.N    ??ContinuousArrayRead_Card_0
    391                  {
    392                      break;
    393                  }
    394                  
    395                  //SysHoldTast();
    396              }
    397          
    398              WriteCS_IC(0);
   \                     ??ContinuousArrayRead_Card_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       WriteCS_IC
    399              
    400              SentByte_SPI(CON_ARR_READ);                             //送连续读命令
   \   00000026   0x20E8             MOVS     R0,#+232
   \   00000028   0x.... 0x....      BL       SentByte_SPI
    401              
    402              if(l_CardTypeFlg == AT45DB041)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x281C             CMP      R0,#+28
   \   00000034   0xD112             BNE.N    ??ContinuousArrayRead_Card_2
    403              {
    404          			SentByte_SPI((uint8_t)(PA>>7));            		//送页地址
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x09C0             LSRS     R0,R0,#+7
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x.... 0x....      BL       SentByte_SPI
    405          			SentByte_SPI((uint8_t)((PA<<1)|(BFA>>8)));   		//
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0xEA50 0x0048      ORRS     R0,R0,R8, LSL #+1
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x.... 0x....      BL       SentByte_SPI
    406          			SentByte_SPI((uint8_t)BFA);                   	//送Buffer地址
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x.... 0x....      BL       SentByte_SPI
   \   0000005A   0xE046             B.N      ??ContinuousArrayRead_Card_3
    407          		}
    408          		else if(l_CardTypeFlg == AT45DB161)
   \                     ??ContinuousArrayRead_Card_2: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x282C             CMP      R0,#+44
   \   00000064   0xD112             BNE.N    ??ContinuousArrayRead_Card_4
    409          		{
    410          			SentByte_SPI((uint8_t)(PA>>6));            		//送页地址
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0x0980             LSRS     R0,R0,#+6
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x.... 0x....      BL       SentByte_SPI
    411          			SentByte_SPI((uint8_t)((PA<<2)|(BFA>>8)));     	//
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x0A00             LSRS     R0,R0,#+8
   \   00000078   0xEA50 0x0088      ORRS     R0,R0,R8, LSL #+2
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x.... 0x....      BL       SentByte_SPI
    412          			SentByte_SPI((uint8_t)BFA);   
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x.... 0x....      BL       SentByte_SPI
   \   0000008A   0xE02E             B.N      ??ContinuousArrayRead_Card_3
    413          		}
    414          		else if(l_CardTypeFlg == AT45DB321)
   \                     ??ContinuousArrayRead_Card_4: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x2834             CMP      R0,#+52
   \   00000094   0xD112             BNE.N    ??ContinuousArrayRead_Card_5
    415          		{
    416          			SentByte_SPI((uint8_t)(PA>>6));              		//送页地址
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x0980             LSRS     R0,R0,#+6
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x.... 0x....      BL       SentByte_SPI
    417          			SentByte_SPI((uint8_t)((PA<<2)|(BFA>>8)));     	//
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A6   0x0A00             LSRS     R0,R0,#+8
   \   000000A8   0xEA50 0x0088      ORRS     R0,R0,R8, LSL #+2
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x.... 0x....      BL       SentByte_SPI
    418          			SentByte_SPI((uint8_t)BFA);   
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x.... 0x....      BL       SentByte_SPI
   \   000000BA   0xE016             B.N      ??ContinuousArrayRead_Card_3
    419          		}	
    420          		else if(l_CardTypeFlg == AT45DB642)
   \                     ??ContinuousArrayRead_Card_5: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x283C             CMP      R0,#+60
   \   000000C4   0xD111             BNE.N    ??ContinuousArrayRead_Card_3
    421          		{
    422          			SentByte_SPI((uint8_t)(PA>>5));                	//送页地址
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CA   0x0940             LSRS     R0,R0,#+5
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0x.... 0x....      BL       SentByte_SPI
    423          			SentByte_SPI((uint8_t)((PA<<3)|(BFA>>8)));      	//
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D6   0x0A00             LSRS     R0,R0,#+8
   \   000000D8   0xEA50 0x00C8      ORRS     R0,R0,R8, LSL #+3
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x.... 0x....      BL       SentByte_SPI
    424          			SentByte_SPI((uint8_t)BFA);   
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0x.... 0x....      BL       SentByte_SPI
    425          		}		
    426          
    427              SentByte_SPI(0x00);                                     //时续要求
   \                     ??ContinuousArrayRead_Card_3: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x.... 0x....      BL       SentByte_SPI
    428              SentByte_SPI(0x00);
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x.... 0x....      BL       SentByte_SPI
    429              SentByte_SPI(0x00);
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x.... 0x....      BL       SentByte_SPI
    430              SentByte_SPI(0x00);
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x.... 0x....      BL       SentByte_SPI
    431          
    432              for(i=0;i<Len;i++)                                    	//读数
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x0007             MOVS     R7,R0
   \                     ??ContinuousArrayRead_Card_6: (+1)
   \   00000106   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000108   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000010A   0x42B7             CMP      R7,R6
   \   0000010C   0xD205             BCS.N    ??ContinuousArrayRead_Card_7
    433              {
    434                  pHeader[i] = RevByte_SPI();
   \   0000010E   0x.... 0x....      BL       RevByte_SPI
   \   00000112   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000114   0x5578             STRB     R0,[R7, R5]
    435              }
   \   00000116   0x1C7F             ADDS     R7,R7,#+1
   \   00000118   0xE7F5             B.N      ??ContinuousArrayRead_Card_6
    436              
    437              WriteCS_IC(1);
   \                     ??ContinuousArrayRead_Card_7: (+1)
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x.... 0x....      BL       WriteCS_IC
    438          }
   \   00000120   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    439          
    440          //-----------------------------------------------------------------------------
    441          //描述：
    442          //    将指定数据写入从某个地址（0~263）开始的页中：包含2个动作，首先将指定数据
    443          //    写入到BUFFER 1或者BUFFER 2中，其中可以指定BUFFER中的起始写入地址，此写入
    444          //    动作不影响BUFFER中其它地址中的数据，然后再将BUFFER中的整个数据写入到某指
    445          //    定页中(带预擦除)。
    446          //参数：
    447          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    448          //    PA      - 页地址，0~2047
    449          //    BFA     - 指定BUFFER中的起始写入地址
    450          //    pHeader - 指定数据的首地址
    451          //    len     - 指定数据的长度
    452          //--------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    453          void    MainMemoryToBuff(uint8_t Buffer,uint16 PA)
    454          {
   \                     MainMemoryToBuff: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    455              uint16 i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    456          
    457              while(i++<3000)                                         //确认AT45DB041D为不忙,确认1000次后退出等待
   \                     ??MainMemoryToBuff_0: (+1)
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x1C46             ADDS     R6,R0,#+1
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xDA03             BGE.N    ??MainMemoryToBuff_1
    458              {
    459                  if(StatusRegisterRead_Card()&0x80)
   \   00000016   0x.... 0x....      BL       StatusRegisterRead_Card
   \   0000001A   0x0600             LSLS     R0,R0,#+24
   \   0000001C   0xD5F4             BPL.N    ??MainMemoryToBuff_0
    460                  {
    461                      break;
    462                  }
    463                  
    464                  //SysHoldTast();
    465              }
    466          
    467              WriteCS_IC(0);
   \                     ??MainMemoryToBuff_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       WriteCS_IC
    468              
    469              switch(Buffer)                                          //选Buffer
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD002             BEQ.N    ??MainMemoryToBuff_2
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD004             BEQ.N    ??MainMemoryToBuff_3
   \   00000030   0xE006             B.N      ??MainMemoryToBuff_4
    470              {
    471                  case 1:SentByte_SPI(MEM_TO_BUFF1);break;
   \                     ??MainMemoryToBuff_2: (+1)
   \   00000032   0x2053             MOVS     R0,#+83
   \   00000034   0x.... 0x....      BL       SentByte_SPI
   \   00000038   0xE002             B.N      ??MainMemoryToBuff_4
    472                  case 2:SentByte_SPI(MEM_TO_BUFF2);break;
   \                     ??MainMemoryToBuff_3: (+1)
   \   0000003A   0x2055             MOVS     R0,#+85
   \   0000003C   0x.... 0x....      BL       SentByte_SPI
    473              }
    474              if(l_CardTypeFlg == AT45DB041)
   \                     ??MainMemoryToBuff_4: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x281C             CMP      R0,#+28
   \   00000048   0xD10A             BNE.N    ??MainMemoryToBuff_5
    475              {
    476          	    SentByte_SPI((uint8_t)(PA>>7));                       //确定页地址
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   0x09C0             LSRS     R0,R0,#+7
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x.... 0x....      BL       SentByte_SPI
    477          	    SentByte_SPI((uint8_t)(PA<<1));
   \   00000056   0x0068             LSLS     R0,R5,#+1
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x.... 0x....      BL       SentByte_SPI
   \   0000005E   0xE02E             B.N      ??MainMemoryToBuff_6
    478          	}
    479          	else if(l_CardTypeFlg == AT45DB161)
   \                     ??MainMemoryToBuff_5: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x282C             CMP      R0,#+44
   \   00000068   0xD10A             BNE.N    ??MainMemoryToBuff_7
    480          	{
    481          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006E   0x0980             LSRS     R0,R0,#+6
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       SentByte_SPI
    482          	    SentByte_SPI((uint8_t)(PA<<2));
   \   00000076   0x00A8             LSLS     R0,R5,#+2
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x.... 0x....      BL       SentByte_SPI
   \   0000007E   0xE01E             B.N      ??MainMemoryToBuff_6
    483          	}
    484          	else if(l_CardTypeFlg == AT45DB321)
   \                     ??MainMemoryToBuff_7: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2834             CMP      R0,#+52
   \   00000088   0xD10A             BNE.N    ??MainMemoryToBuff_8
    485          	{
    486          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008E   0x0980             LSRS     R0,R0,#+6
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x.... 0x....      BL       SentByte_SPI
    487          	    SentByte_SPI((uint8_t)(PA<<2));
   \   00000096   0x00A8             LSLS     R0,R5,#+2
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x.... 0x....      BL       SentByte_SPI
   \   0000009E   0xE00E             B.N      ??MainMemoryToBuff_6
    488          	}	
    489          	else if(l_CardTypeFlg == AT45DB642)
   \                     ??MainMemoryToBuff_8: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x283C             CMP      R0,#+60
   \   000000A8   0xD109             BNE.N    ??MainMemoryToBuff_6
    490          	{
    491          		SentByte_SPI((uint8_t)(PA>>5));                       //确定页地址
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AE   0x0940             LSRS     R0,R0,#+5
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x.... 0x....      BL       SentByte_SPI
    492          	    SentByte_SPI((uint8_t)(PA<<3));
   \   000000B6   0x00E8             LSLS     R0,R5,#+3
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x.... 0x....      BL       SentByte_SPI
    493          	}		
    494          		
    495              SentByte_SPI(0x00);
   \                     ??MainMemoryToBuff_6: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       SentByte_SPI
    496          
    497              WriteCS_IC(1);
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x.... 0x....      BL       WriteCS_IC
    498          }
   \   000000CA   0xBD70             POP      {R4-R6,PC}       ;; return
    499          
    500          
    501          //------------------------------------------------------------------------------
    502          //描述：
    503          //    将指定数据写入从某个地址（0~263）开始的BUFFER中。
    504          //参数：
    505          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    506          //              在该指令序列中，操作码84H选择BUFFER 1，87H选择BUFFER 2
    507          //    BFA     - BUFFER中的起始地址，0~263
    508          //    pHeader - 待存数据的头指针
    509          //    len     - 待存数据的长度1~l_CardPageSize
    510          //----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    511          void    BufferRead_Card(uint8_t Buffer,uint16 PA,uint16 BFA,uint8_t *pHeader,uint16 Len)
    512          {
   \                     BufferRead_Card: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C08             LDR      R4,[SP, #+32]
    513              uint16 i = 0;
   \   0000000E   0xF05F 0x0900      MOVS     R9,#+0
    514          
    515          	MainMemoryToBuff(Buffer,PA);							//读取指定的页内容
   \   00000012   0x0031             MOVS     R1,R6
   \   00000014   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       MainMemoryToBuff
    516          
    517              while(i++<5000)                                       	//确认AT45DB041D为不忙,确认500次后退出等待
   \                     ??BufferRead_Card_0: (+1)
   \   0000001E   0x4648             MOV      R0,R9
   \   00000020   0xF110 0x0901      ADDS     R9,R0,#+1
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0xF241 0x3188      MOVW     R1,#+5000
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xDA03             BGE.N    ??BufferRead_Card_1
    518              {
    519                  if(StatusRegisterRead_Card() & 0x80)
   \   0000002E   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000032   0x0600             LSLS     R0,R0,#+24
   \   00000034   0xD5F3             BPL.N    ??BufferRead_Card_0
    520                  {
    521                      break;
    522                  }
    523                  
    524                  //SysHoldTast();
    525              }
    526          
    527              WriteCS_IC(0);
   \                     ??BufferRead_Card_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      BL       WriteCS_IC
    528          
    529              switch(Buffer)                                       	//选择buffer
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD002             BEQ.N    ??BufferRead_Card_2
   \   00000044   0x2802             CMP      R0,#+2
   \   00000046   0xD004             BEQ.N    ??BufferRead_Card_3
   \   00000048   0xE006             B.N      ??BufferRead_Card_4
    530              {
    531                  case 1:SentByte_SPI(BUFF1_READ);break;             	//送buffer1 写命令
   \                     ??BufferRead_Card_2: (+1)
   \   0000004A   0x2054             MOVS     R0,#+84
   \   0000004C   0x.... 0x....      BL       SentByte_SPI
   \   00000050   0xE002             B.N      ??BufferRead_Card_4
    532                  case 2:SentByte_SPI(BUFF2_READ);break;             	//送buffer2 写命令
   \                     ??BufferRead_Card_3: (+1)
   \   00000052   0x2056             MOVS     R0,#+86
   \   00000054   0x.... 0x....      BL       SentByte_SPI
    533              }
    534              
    535              SentByte_SPI(0x00);
   \                     ??BufferRead_Card_4: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       SentByte_SPI
    536              SentByte_SPI((uint8_t)(BFA>>8));                          //A8地址
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000062   0x0A00             LSRS     R0,R0,#+8
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x.... 0x....      BL       SentByte_SPI
    537              SentByte_SPI((uint8_t)BFA);                               //A7~A0
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x.... 0x....      BL       SentByte_SPI
    538              SentByte_SPI(0x00);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       SentByte_SPI
    539          
    540              for(i=0;i<Len;i++)                                 		//写Buffer
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x4681             MOV      R9,R0
   \                     ??BufferRead_Card_5: (+1)
   \   0000007C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000080   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000082   0x45A1             CMP      R9,R4
   \   00000084   0xD208             BCS.N    ??BufferRead_Card_6
    541              {
    542                  pHeader[i] = RevByte_SPI();
   \   00000086   0x.... 0x....      BL       RevByte_SPI
   \   0000008A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000008E   0xF809 0x0008      STRB     R0,[R9, R8]
    543              }
   \   00000092   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000096   0xE7F1             B.N      ??BufferRead_Card_5
    544          
    545              WriteCS_IC(1);
   \                     ??BufferRead_Card_6: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      BL       WriteCS_IC
    546          }
   \   0000009E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    547          
    548          //---------------------------------------------------------------------------
    549          //描述：
    550          //    将指定数据写入从某个地址（0~263）开始的BUFFER中。
    551          //参数：
    552          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    553          //              在该指令序列中，操作码84H选择BUFFER 1，87H选择BUFFER 2
    554          //    BFA     - BUFFER中的起始地址，0~263
    555          //    pHeader - 待存数据的头指针
    556          //    len     - 待存数据的长度1~l_CardPageSize
    557          //----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    558          void    BufferWrite_Card(uint8_t Buffer,uint16 BFA,uint8_t *pHeader,uint16 Len)
    559          {
   \                     BufferWrite_Card: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    560              uint16 i;
    561          /*
    562              while(i++<500)                                      	//确认AT45DB041D为不忙,确认500次后退出等待
    563              {
    564                  if(StatusRegisterRead_Card() & 0x80)
    565                  {
    566                      break;
    567                  }
    568              }
    569          */
    570              WriteCS_IC(0);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       WriteCS_IC
    571          
    572              switch(Buffer)                                        	//选择buffer
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD002             BEQ.N    ??BufferWrite_Card_0
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD004             BEQ.N    ??BufferWrite_Card_1
   \   0000001E   0xE006             B.N      ??BufferWrite_Card_2
    573              {
    574                  case 1:SentByte_SPI(BUFF1_WRITE);break;             //送buffer1 写命令
   \                     ??BufferWrite_Card_0: (+1)
   \   00000020   0x2084             MOVS     R0,#+132
   \   00000022   0x.... 0x....      BL       SentByte_SPI
   \   00000026   0xE002             B.N      ??BufferWrite_Card_2
    575                  case 2:SentByte_SPI(BUFF2_WRITE);break;             //送buffer2 写命令
   \                     ??BufferWrite_Card_1: (+1)
   \   00000028   0x2087             MOVS     R0,#+135
   \   0000002A   0x.... 0x....      BL       SentByte_SPI
    576              }
    577              
    578              SentByte_SPI(0x00);
   \                     ??BufferWrite_Card_2: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       SentByte_SPI
    579              SentByte_SPI((uint8_t)(BFA>>8));                          //A8地址
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0x0A00             LSRS     R0,R0,#+8
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       SentByte_SPI
    580              SentByte_SPI((uint8_t)BFA);                               //A7~A0
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       SentByte_SPI
    581          
    582              for(i=0;i<Len;i++)                                   	//写Buffer
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4680             MOV      R8,R0
   \                     ??BufferWrite_Card_3: (+1)
   \   0000004C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000050   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000052   0x45B8             CMP      R8,R7
   \   00000054   0xD208             BCS.N    ??BufferWrite_Card_4
    583              {
    584                  SentByte_SPI(pHeader[i]);
   \   00000056   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000005A   0xF818 0x0006      LDRB     R0,[R8, R6]
   \   0000005E   0x.... 0x....      BL       SentByte_SPI
    585              }
   \   00000062   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000066   0xE7F1             B.N      ??BufferWrite_Card_3
    586          
    587              WriteCS_IC(1);
   \                     ??BufferWrite_Card_4: (+1)
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x.... 0x....      BL       WriteCS_IC
    588          }
   \   0000006E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    589          
    590          //-----------------------------------------------------------------------------
    591          //描述：
    592          //    将指定数据写入从某个地址（0~263）开始的页中：包含2个动作，首先将指定数据
    593          //    写入到BUFFER 1或者BUFFER 2中，其中可以指定BUFFER中的起始写入地址，此写入
    594          //    动作不影响BUFFER中其它地址中的数据，然后再将BUFFER中的整个数据写入到某指
    595          //    定页中(带预擦除)。
    596          //参数：
    597          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    598          //    PA      - 页地址，0~2047
    599          //    BFA     - 指定BUFFER中的起始写入地址
    600          //    pHeader - 指定数据的首地址
    601          //    len     - 指定数据的长度
    602          //--------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    603          void    BufferToMainMemoryPageProgramWithBuilt_inErase_Card(uint8_t Buffer,uint16 PA,uint16 BFA,uint8_t *pHeader,uint16 Len)
    604          {
   \                     BufferToMainMemoryPageProgramWithBuilt_inErase_Card: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C08             LDR      R4,[SP, #+32]
    605              uint16 i = 0;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    606          
    607              BufferWrite_Card(Buffer,BFA,pHeader,Len);         		//写buffer操作
   \   00000012   0x0023             MOVS     R3,R4
   \   00000014   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   0x003A             MOVS     R2,R7
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       BufferWrite_Card
    608          
    609              while(i++<3000)                                         //确认AT45DB041D为不忙,确认1000次后退出等待
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_0: (+1)
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xF110 0x0801      ADDS     R8,R0,#+1
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xDA03             BGE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_1
    610              {
    611                  if(StatusRegisterRead_Card()&0x80)
   \   00000034   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000038   0x0600             LSLS     R0,R0,#+24
   \   0000003A   0xD5F3             BPL.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_0
    612                  {
    613                      break;
    614                  }
    615                  
    616                  //SysHoldTast();
    617              }
    618          
    619              WriteCS_IC(0);
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_1: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       WriteCS_IC
    620              
    621              switch(Buffer)                                          //选Buffer
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD002             BEQ.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_2
   \   0000004A   0x2802             CMP      R0,#+2
   \   0000004C   0xD004             BEQ.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_3
   \   0000004E   0xE006             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_4
    622              {
    623                  case 1:SentByte_SPI(BUFF1_TO_MEM);break;
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_2: (+1)
   \   00000050   0x2083             MOVS     R0,#+131
   \   00000052   0x.... 0x....      BL       SentByte_SPI
   \   00000056   0xE002             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_4
    624                  case 2:SentByte_SPI(BUFF2_TO_MEM);break;
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_3: (+1)
   \   00000058   0x2086             MOVS     R0,#+134
   \   0000005A   0x.... 0x....      BL       SentByte_SPI
    625              }
    626              if(l_CardTypeFlg == AT45DB041)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_4: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x281C             CMP      R0,#+28
   \   00000066   0xD10B             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_5
    627              {
    628          	    SentByte_SPI((uint8_t)(PA>>7));                       //确定页地址
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0x09C0             LSRS     R0,R0,#+7
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x.... 0x....      BL       SentByte_SPI
    629          	    SentByte_SPI((uint8_t)(PA<<1));
   \   00000074   0xEA5F 0x0049      LSLS     R0,R9,#+1
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x.... 0x....      BL       SentByte_SPI
   \   0000007E   0xE031             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    630          	}
    631          	else if(l_CardTypeFlg == AT45DB161)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_5: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x282C             CMP      R0,#+44
   \   00000088   0xD10B             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_7
    632          	{
    633          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   0000008A   0x4648             MOV      R0,R9
   \   0000008C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008E   0x0980             LSRS     R0,R0,#+6
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x.... 0x....      BL       SentByte_SPI
    634          	    SentByte_SPI((uint8_t)(PA<<2));
   \   00000096   0xEA5F 0x0089      LSLS     R0,R9,#+2
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x.... 0x....      BL       SentByte_SPI
   \   000000A0   0xE020             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    635          	}
    636          	else if(l_CardTypeFlg == AT45DB321)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_7: (+1)
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2834             CMP      R0,#+52
   \   000000AA   0xD10B             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_8
    637          	{
    638          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B0   0x0980             LSRS     R0,R0,#+6
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x.... 0x....      BL       SentByte_SPI
    639          	    SentByte_SPI((uint8_t)(PA<<2));
   \   000000B8   0xEA5F 0x0089      LSLS     R0,R9,#+2
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0x.... 0x....      BL       SentByte_SPI
   \   000000C2   0xE00F             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    640          	}	
    641          	else if(l_CardTypeFlg == AT45DB642)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_8: (+1)
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable19_8
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x283C             CMP      R0,#+60
   \   000000CC   0xD10A             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    642          	{
    643          		SentByte_SPI((uint8_t)(PA>>5));                       //确定页地址
   \   000000CE   0x4648             MOV      R0,R9
   \   000000D0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D2   0x0940             LSRS     R0,R0,#+5
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x.... 0x....      BL       SentByte_SPI
    644          	    SentByte_SPI((uint8_t)(PA<<3));
   \   000000DA   0xEA5F 0x00C9      LSLS     R0,R9,#+3
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x.... 0x....      BL       SentByte_SPI
    645          	}		
    646          	
    647              SentByte_SPI(0x00);
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_6: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x.... 0x....      BL       SentByte_SPI
    648          
    649              WriteCS_IC(1);
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0x.... 0x....      BL       WriteCS_IC
    650          }
   \   000000F0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    651          

   \                                 In section .bss, align 1
    652          static	uint8_t	l_CardBufNum;
   \                     l_CardBufNum:
   \   00000000                      DS8 1
    653          //extern	SysFastHoldTast(void);
    654          //---------------------------------------------------------------------
    655          //名    称：   ReadCard(uint32 Addr,uint32 *buf,uint32 Len)
    656          //功    能：   将指定区IC卡值读出。
    657          //入口参数：   Addr    读取数据的地址       地址：0~Sizeof(IC)
    658          //             buf     读取后放置的缓冲区
    659          //             Len     读出的数据长度  以8位的数据为长度单位
    660          //出口参数：   无
    661          //----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    662          uint8_t ReadCard(uint32 Addr,uint8_t *TargetBuf,uint32 Len)
    663          {
   \                     ReadCard: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    664              uint16	PageNum;                                                    //页
    665          	uint16	PageOffset;                                                 //页内地址
    666          	uint16  ReadPageTimes;                                              //读页次数       
    667          	uint16  LenTemp;                                                  	//长度         
    668          	uint16  i;
    669          	uint32  BufOffset = 0;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    670              uint32  AddrTemp; 
    671          	uint32	PageNoReadSize;
    672          	uint32	BufNoReadSize;
    673          	
    674          	AddrTemp =  Addr; 
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x4683             MOV      R11,R0
    675              AddrTemp += l_CardStartAddr;                                      	//映射到IC卡内部
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable19_6
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xEB10 0x0B0B      ADDS     R11,R0,R11
    676                         
    677              if(AddrTemp + Len > l_CardStartAddr + l_CardPageNum*l_CardPageSize)    
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable19_6
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable19_7
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable19_5
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000032   0xEB15 0x010B      ADDS     R1,R5,R11
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD201             BCS.N    ??ReadCard_0
    678              {
    679                 //printfcom0("\r\n READ AddrTemp + Len %d > l_CardStartAddr + l_CardPageNum*l_CardPageSize %d  ", 
    680          //       								AddrTemp + Len,l_CardStartAddr + l_CardPageNum*l_CardPageSize);
    681                 return  FALSE;                                                   //地址超阶
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE064             B.N      ??ReadCard_1
    682              }
    683          
    684              PageNum         = AddrTemp / l_CardPageSize ;                     	//求页
   \                     ??ReadCard_0: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000048   0x0006             MOVS     R6,R0
    685              PageOffset      = AddrTemp % l_CardPageSize ;                     	//求页内地址
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0xFB01 0xB010      MLS      R0,R1,R0,R11
   \   0000005E   0x0007             MOVS     R7,R0
    686              ReadPageTimes   = (Len + PageOffset  + (l_CardPageSize - 1)) / l_CardPageSize;            
   \   00000060   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000062   0x1978             ADDS     R0,R7,R5
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x1808             ADDS     R0,R1,R0
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000078   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    687              /* 																	//读页次数        
    688              for(i = 0; i < ReadPageTimes; i++)
    689              {
    690                  PageNoReadSize = 	l_CardPageSize - (PageOffset + BufOffset)
    691                  					 % l_CardPageSize;							//计算IC卡一页内未写地址
    692                  BufNoReadSize	=	Len - BufOffset;							//缓冲区未读入字节长度
    693                  LenTemp = (PageNoReadSize < BufNoReadSize ? PageNoReadSize:BufNoReadSize);
    694                  																//取将一页写满或将未读入字节长度
    695          	    BufferRead_Card(((l_CardBufNum++%2)+1),PageNum,PageOffset
    696          	    							,(uint8_t *)&TargetBuf[BufOffset],LenTemp);	
    697          	    																//取数 
    698                  BufOffset += LenTemp;
    699                  PageNum++; 
    700              }
    701              */
    702              
    703              for(i = 0; i <= ReadPageTimes; i++)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x4681             MOV      R9,R0
   \                     ??ReadCard_2: (+1)
   \   00000080   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000084   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000088   0x4548             CMP      R0,R9
   \   0000008A   0xD33C             BCC.N    ??ReadCard_3
    704              {
    705              	//SysFastHoldTast();
    706          
    707                  PageNoReadSize = 	l_CardPageSize - (PageOffset + BufOffset)
    708                  					 % l_CardPageSize;						//计算IC卡一页内未写地址
   \   0000008C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008E   0xEB1A 0x0107      ADDS     R1,R10,R7
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x1A40             SUBS     R0,R0,R1
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable19_5
   \   0000009E   0x6812             LDR      R2,[R2, #+0]
   \   000000A0   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable19_5
   \   000000A8   0x6812             LDR      R2,[R2, #+0]
   \   000000AA   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000AE   0x9001             STR      R0,[SP, #+4]
    709                  BufNoReadSize	=	Len - BufOffset;						//缓冲区未读入字节长度
   \   000000B0   0xEBB5 0x000A      SUBS     R0,R5,R10
   \   000000B4   0x9000             STR      R0,[SP, #+0]
    710                  LenTemp = (PageNoReadSize < BufNoReadSize ? PageNoReadSize:BufNoReadSize);
   \   000000B6   0x9801             LDR      R0,[SP, #+4]
   \   000000B8   0x9900             LDR      R1,[SP, #+0]
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD202             BCS.N    ??ReadCard_4
   \   000000BE   0xF8DD 0x8004      LDR      R8,[SP, #+4]
   \   000000C2   0xE001             B.N      ??ReadCard_5
   \                     ??ReadCard_4: (+1)
   \   000000C4   0xF8DD 0x8000      LDR      R8,[SP, #+0]
    711                  																//取将一页写满或将未读入字节长度  
    712                  ContinuousArrayRead_Card(PageNum,PageOffset,(uint8_t *)&TargetBuf[BufOffset],LenTemp);	//取数 
   \                     ??ReadCard_5: (+1)
   \   000000C8   0x4643             MOV      R3,R8
   \   000000CA   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000CC   0xEB1A 0x0204      ADDS     R2,R10,R4
   \   000000D0   0x0039             MOVS     R1,R7
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x0030             MOVS     R0,R6
   \   000000D6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D8   0x.... 0x....      BL       ContinuousArrayRead_Card
    713                          
    714                  BufOffset += LenTemp;
   \   000000DC   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000E0   0xEB18 0x0A0A      ADDS     R10,R8,R10
    715                  PageOffset += LenTemp;
   \   000000E4   0xEB18 0x0707      ADDS     R7,R8,R7
    716                  PageOffset %= l_CardPageSize;
   \   000000E8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000000F8   0x6809             LDR      R1,[R1, #+0]
   \   000000FA   0xFB01 0x7710      MLS      R7,R1,R0,R7
    717                  
    718                  PageNum++; 
   \   000000FE   0x1C76             ADDS     R6,R6,#+1
    719              }
   \   00000100   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000104   0xE7BC             B.N      ??ReadCard_2
    720              
    721              //NOP(); 
    722              return  TRUE;	                                                    //正确                   
   \                     ??ReadCard_3: (+1)
   \   00000106   0x2001             MOVS     R0,#+1
   \                     ??ReadCard_1: (+1)
   \   00000108   0xB005             ADD      SP,SP,#+20
   \   0000010A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    723          }
    724          
    725          //---------------------------------------------------------------------
    726          //名    称：   uint8_t WriteCardPartPage(uint16 PageNum,SegmentNum,uint8_t *Buf,uint32 Len)
    727          
    728          //功    能：   写页中的一部分,要求SegmentNum+Len <= l_CardPageSize
    729          //入口参数：   PageNum  页号        地址：0~Sizeof(IC)
    730          //             Buf:     数据缓冲    
    731          //出口参数：   写成功
    732          //----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    733          uint8_t WriteCardPage(uint16 PageNum,uint16 SegmentNum,uint8_t *Buf,uint32 Len)
    734          {
   \                     WriteCardPage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x6D81      SUB      SP,SP,#+1032
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
   \   0000000C   0x0016             MOVS     R6,R2
   \   0000000E   0x001F             MOVS     R7,R3
    735              uint8_t   IC_BufTemp[256*4];  
    736          
    737              if(PageNum > l_CardPageNum || (SegmentNum + Len) > l_CardPageSize )
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19_7
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xD306             BCC.N    ??WriteCardPage_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x1979             ADDS     R1,R7,R5
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD201             BCS.N    ??WriteCardPage_1
    738              {
    739                  return  FALSE;
   \                     ??WriteCardPage_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE04D             B.N      ??WriteCardPage_2
    740              }     
    741              if(Len == l_CardPageSize)                                         //写完整页
   \                     ??WriteCardPage_1: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x4287             CMP      R7,R0
   \   00000036   0xD11C             BNE.N    ??WriteCardPage_3
    742              {
    743                  BufferToMainMemoryPageProgramWithBuilt_inErase_Card(((l_CardBufNum++%2)+1),PageNum,0,Buf,l_CardPageSize);
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable19_9
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x1C41             ADDS     R1,R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable19_9
   \   00000044   0x7011             STRB     R1,[R2, #+0]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004E   0x9100             STR      R1,[SP, #+0]
   \   00000050   0x0033             MOVS     R3,R6
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0xF05F 0x0C02      MOVS     R12,#+2
   \   0000005E   0xFB90 0xFEFC      SDIV     LR,R0,R12
   \   00000062   0xFB0E 0x0E1C      MLS      LR,LR,R12,R0
   \   00000066   0xF11E 0x0001      ADDS     R0,LR,#+1
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x.... 0x....      BL       BufferToMainMemoryPageProgramWithBuilt_inErase_Card
   \   00000070   0xE02A             B.N      ??WriteCardPage_4
    744              }
    745              else 
    746              {
    747                  ContinuousArrayRead_Card(PageNum, 0 , IC_BufTemp, l_CardPageSize); 				//IC卡读第PageNum页
   \                     ??WriteCardPage_3: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable19_5
   \   00000074   0x6803             LDR      R3,[R0, #+0]
   \   00000076   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000078   0xAA01             ADD      R2,SP,#+4
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000080   0x.... 0x....      BL       ContinuousArrayRead_Card
    748                  memcpy((uint8_t *)&IC_BufTemp[SegmentNum], Buf ,Len);                            //将数据填充
   \   00000084   0xA801             ADD      R0,SP,#+4
   \   00000086   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000088   0xEB15 0x0800      ADDS     R8,R5,R0
   \   0000008C   0x003A             MOVS     R2,R7
   \   0000008E   0x0031             MOVS     R1,R6
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       __aeabi_memcpy
    749          
    750                  BufferToMainMemoryPageProgramWithBuilt_inErase_Card(((l_CardBufNum++%2)+1),PageNum,0,IC_BufTemp,l_CardPageSize);
   \   00000096   0x....             LDR.N    R0,??DataTable19_9
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x1C41             ADDS     R1,R0,#+1
   \   0000009C   0x....             LDR.N    R2,??DataTable19_9
   \   0000009E   0x7011             STRB     R1,[R2, #+0]
   \   000000A0   0x....             LDR.N    R1,??DataTable19_5
   \   000000A2   0x6809             LDR      R1,[R1, #+0]
   \   000000A4   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A6   0x9100             STR      R1,[SP, #+0]
   \   000000A8   0xAB01             ADD      R3,SP,#+4
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0x0021             MOVS     R1,R4
   \   000000AE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0xF05F 0x0C02      MOVS     R12,#+2
   \   000000B6   0xFB90 0xFEFC      SDIV     LR,R0,R12
   \   000000BA   0xFB0E 0x0E1C      MLS      LR,LR,R12,R0
   \   000000BE   0xF11E 0x0001      ADDS     R0,LR,#+1
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x.... 0x....      BL       BufferToMainMemoryPageProgramWithBuilt_inErase_Card
    751              }
    752              
    753              //NOP();
    754              return  TRUE;    
   \                     ??WriteCardPage_4: (+1)
   \   000000C8   0x2001             MOVS     R0,#+1
   \                     ??WriteCardPage_2: (+1)
   \   000000CA   0xF50D 0x6D81      ADD      SP,SP,#+1032
   \   000000CE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    755          }
    756          
    757          //---------------------------------------------------------------------
    758          // 名    称：   WriteCard()
    759          // 功    能：   指定缓冲区数据编程。
    760          // 入口参数：   Addr    编程地址(内部地址)
    761          //						地址从00 ~ CARD_SIZE  
    762          //
    763          //              buf     编程数据缓冲区 注意：此为16位字
    764          
    765          //              Len     编程数据长度  以8位的写入数据为长度单位，相当于 Len 个字节数目
    766          
    767          // 出口参数：   返回TRUE表示操作成功，返回FALSE表示操作失败
    768          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    769          uint8_t WriteCard(uint32 Addr,uint8_t *SourceBuf,uint16 Len)
    770          {
   \                     WriteCard: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    771              uint16	PageNum;                                                    //页
    772          	uint16	PageOffset;                                                 //页内地址
    773          	uint32  AddrTemp; 
    774          	uint16  WritePageTimes;                                             //写页次数       
    775          	uint16  LenTemp;                                                  	//长度         
    776          	uint16  i;
    777          	uint16  BufOffset = 0;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    778          	uint32	PageNoWriteSize;
    779          	uint32	BufNoWriteSize;
    780          	
    781          	AddrTemp =  Addr; 
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x4683             MOV      R11,R0
    782              AddrTemp += l_CardStartAddr;                                      	//映射到IC卡内部
   \   00000012   0x....             LDR.N    R0,??DataTable19_6
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xEB10 0x0B0B      ADDS     R11,R0,R11
    783                        
    784              if(AddrTemp + Len > l_CardStartAddr + l_CardPageNum*l_CardPageSize)    
   \   0000001A   0x....             LDR.N    R0,??DataTable19_6
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x....             LDR.N    R1,??DataTable19_7
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x....             LDR.N    R2,??DataTable19_5
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xEB15 0x010B      ADDS     R1,R5,R11
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD201             BCS.N    ??WriteCard_0
    785              {
    786                 return  FALSE;                                                   //地址超阶
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE061             B.N      ??WriteCard_1
    787              }
    788          
    789              PageNum         = AddrTemp / l_CardPageSize ;                     	//求页
   \                     ??WriteCard_0: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable19_5
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000040   0x0006             MOVS     R6,R0
    790              PageOffset      = AddrTemp % l_CardPageSize ;                     	//求页内地址
   \   00000042   0x....             LDR.N    R0,??DataTable19_5
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   0000004A   0x....             LDR.N    R1,??DataTable19_5
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0xFB01 0xB010      MLS      R0,R1,R0,R11
   \   00000052   0x0007             MOVS     R7,R0
    791              WritePageTimes  = (Len + PageOffset + (l_CardPageSize - 1)) / l_CardPageSize;            	//读页次数
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000058   0x1978             ADDS     R0,R7,R5
   \   0000005A   0x....             LDR.N    R1,??DataTable19_5
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x1808             ADDS     R0,R1,R0
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable19_5
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    792              
    793              for(i = 0; i < WritePageTimes; i++)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x4681             MOV      R9,R0
   \                     ??WriteCard_2: (+1)
   \   00000072   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000076   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007A   0x4581             CMP      R9,R0
   \   0000007C   0xD23D             BCS.N    ??WriteCard_3
    794              {
    795              	//SysFastHoldTast();
    796          
    797                  PageNoWriteSize = 	l_CardPageSize - (PageOffset + BufOffset)
    798                  					 % l_CardPageSize;							//计算IC卡一页内未写地址
   \   0000007E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000080   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000084   0xEB1A 0x0107      ADDS     R1,R10,R7
   \   00000088   0x....             LDR.N    R0,??DataTable19_5
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x1A40             SUBS     R0,R0,R1
   \   0000008E   0x....             LDR.N    R2,??DataTable19_5
   \   00000090   0x6812             LDR      R2,[R2, #+0]
   \   00000092   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000096   0x....             LDR.N    R2,??DataTable19_5
   \   00000098   0x6812             LDR      R2,[R2, #+0]
   \   0000009A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000009E   0x9001             STR      R0,[SP, #+4]
    799                  BufNoWriteSize	=	Len - BufOffset;							//缓冲区未写字节长度
   \   000000A0   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A2   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000A6   0xEBB5 0x000A      SUBS     R0,R5,R10
   \   000000AA   0x9000             STR      R0,[SP, #+0]
    800                  LenTemp = (PageNoWriteSize < BufNoWriteSize ? PageNoWriteSize:BufNoWriteSize);
   \   000000AC   0x9801             LDR      R0,[SP, #+4]
   \   000000AE   0x9900             LDR      R1,[SP, #+0]
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xD202             BCS.N    ??WriteCard_4
   \   000000B4   0xF8DD 0x8004      LDR      R8,[SP, #+4]
   \   000000B8   0xE001             B.N      ??WriteCard_5
   \                     ??WriteCard_4: (+1)
   \   000000BA   0xF8DD 0x8000      LDR      R8,[SP, #+0]
    801                  																//取将一页写满或将缓冲共写完字节长度
    802                  WriteCardPage(PageNum,PageOffset,(uint8_t *)&SourceBuf[BufOffset],LenTemp);     //取数 
   \                     ??WriteCard_5: (+1)
   \   000000BE   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000C2   0x4643             MOV      R3,R8
   \   000000C4   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000C8   0xEB1A 0x0204      ADDS     R2,R10,R4
   \   000000CC   0x0039             MOVS     R1,R7
   \   000000CE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D0   0x0030             MOVS     R0,R6
   \   000000D2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D4   0x.... 0x....      BL       WriteCardPage
    803          
    804                  BufOffset += LenTemp;
   \   000000D8   0xEB18 0x0A0A      ADDS     R10,R8,R10
    805                  PageOffset += LenTemp;
   \   000000DC   0xEB18 0x0707      ADDS     R7,R8,R7
    806                  PageOffset %= l_CardPageSize;
   \   000000E0   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000E2   0x....             LDR.N    R0,??DataTable19_5
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   000000EA   0x....             LDR.N    R1,??DataTable19_5
   \   000000EC   0x6809             LDR      R1,[R1, #+0]
   \   000000EE   0xFB01 0x7710      MLS      R7,R1,R0,R7
    807                  
    808                  PageNum++; 
   \   000000F2   0x1C76             ADDS     R6,R6,#+1
    809              }
   \   000000F4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000F8   0xE7BB             B.N      ??WriteCard_2
    810          
    811              return  TRUE;	                                                    //正确  
   \                     ??WriteCard_3: (+1)
   \   000000FA   0x2001             MOVS     R0,#+1
   \                     ??WriteCard_1: (+1)
   \   000000FC   0xB005             ADD      SP,SP,#+20
   \   000000FE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    812          }
    813          
    814          //---------------------------------------------------------------------
    815          // 名    称：   uint32 GetToEndLen(uint32 Addr)
    816          // 功    能：   指定到指定地址到卡的结束的长度
    817          // 入口参数：   Addr    指定地址
    818          // 出口参数：   返回长度
    819          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    820          uint32 GetToEndLen(uint32 Addr)
    821          {
    822          	return	(l_CardStartAddr + l_CardPageNum*l_CardPageSize - Addr);
   \                     GetToEndLen: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable19_6
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x....             LDR.N    R2,??DataTable19_7
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x....             LDR.N    R3,??DataTable19_5
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
   \   0000000C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0x4770             BX       LR               ;; return
    823          }
    824          

   \                                 In section .bss, align 1
    825          static	uint8_t   mPlugInFlg = NO_PLUG_IN_CARD;                     		//卡片插入标识
   \                     mPlugInFlg:
   \   00000000                      DS8 1
    826          

   \                                 In section .bss, align 4
    827          static uint32   mPlugTime  = 0;											//没有插卡次数
   \                     mPlugTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    828          static uint32   mNoPlugTime= 0;
   \                     mNoPlugTime:
   \   00000000                      DS8 4
    829          

   \                                 In section .data, align 1
    830          uint8_t		l_CardErrorFlg = NO_ERROR;
   \                     l_CardErrorFlg:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    831          uint8_t		l_LongTimePlugCardErrFlg = NO_ERROR;
   \                     l_LongTimePlugCardErrFlg:
   \   00000000   0x01               DC8 1
    832          
    833          //---------------------------------------------------------------------
    834          // 名    称：   void   PlugCard( void )
    835          // 功    能：   判断是否有卡片插入
    836          // 入口参数：   无
    837          // 出口参数：   无
    838          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    839          void   PlugCard( void )
    840          {
   \                     PlugCard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    841              if(ReadIC_SWT() == 1)                               //判断是否插入卡片
   \   00000002   0x.... 0x....      BL       ReadIC_SWT
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10F             BNE.N    ??PlugCard_0
    842              {
    843                  mPlugTime++;                                   	//判卡次数
   \   0000000A   0x....             LDR.N    R0,??DataTable19_10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable19_10
   \   00000012   0x6008             STR      R0,[R1, #+0]
    844          
    845                  if( mPlugTime > 20)                          	//去抖动,是否插入卡片
   \   00000014   0x....             LDR.N    R0,??DataTable19_10
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2815             CMP      R0,#+21
   \   0000001A   0xD318             BCC.N    ??PlugCard_1
    846                  {
    847                      mPlugInFlg = PLUG_IN_CARD;              	//有卡
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable19_11
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    848                      
    849                      mNoPlugTime = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable19_12
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0xE011             B.N      ??PlugCard_1
    850                  }
    851              }
    852              else
    853              {            
    854                  mNoPlugTime++;                                   //判卡次数
   \                     ??PlugCard_0: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable19_12
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable19_12
   \   00000032   0x6008             STR      R0,[R1, #+0]
    855          
    856                  if( mNoPlugTime > 20)                            //去抖动,是否插入卡片
   \   00000034   0x....             LDR.N    R0,??DataTable19_12
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x2815             CMP      R0,#+21
   \   0000003A   0xD308             BCC.N    ??PlugCard_1
    857                  {
    858                      mPlugInFlg = NO_PLUG_IN_CARD;             	//无卡
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable19_11
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    859          
    860                    	l_LongTimePlugCardErrFlg = NO_ERROR;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable19_13
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    861          
    862                      mPlugTime = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x....             LDR.N    R1,??DataTable19_10
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    863                      
    864                	//	ReStartPluse();							//开柴速测量
    865                  }
    866              }
    867              
    868              ////printfcom0("\r\n mPlugInFlg %d",mPlugInFlg);
    869          }
   \                     ??PlugCard_1: (+1)
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
    870          
    871          
    872          //---------------------------------------------------------------------
    873          // 名    称：   void   HoldCard( void )
    874          // 功    能：   IC卡插入维护
    875          // 入口参数：   无
    876          // 出口参数：   无
    877          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    878          void   HoldCard( void )
    879          {
   \                     HoldCard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    880          	PlugCard();
   \   00000002   0x.... 0x....      BL       PlugCard
    881          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    882          
    883          //---------------------------------------------------------------------
    884          // 名    称：   uint8_t   GetPlugFlg()
    885          // 功    能：   返回插卡标志
    886          // 入口参数：   无
    887          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
    888          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    889          uint32   GetPlugTime(void)
    890          {
    891              return  mPlugTime;
   \                     GetPlugTime: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19_10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    892          }
    893          
    894          //extern	void ClosePluseInput(void);
    895          //---------------------------------------------------------------------
    896          // 名    称：   uint8_t   GetPlugFlg()
    897          // 功    能：   返回插卡标志
    898          // 入口参数：   无
    899          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
    900          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    901          uint8_t   GetPlugFlg(void)
    902          {
   \                     GetPlugFlg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    903          	if(mPlugInFlg == NO_PLUG_IN_CARD)
   \   00000002   0x....             LDR.N    R0,??DataTable19_11
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE.N    ??GetPlugFlg_0
    904          	{
    905          		WritePOW_IC( 1 );								//关电源
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       WritePOW_IC
   \   00000010   0xE002             B.N      ??GetPlugFlg_1
    906          	}
    907          	else
    908          	{
    909          		WritePOW_IC( 0 );								//开电源
   \                     ??GetPlugFlg_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       WritePOW_IC
    910          	}
    911          		
    912              return  mPlugInFlg;
   \                     ??GetPlugFlg_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable19_11
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    913          }
    914          
    915          //---------------------------------------------------------------------
    916          // 名    称：   uint8_t   GetPlugFlg()
    917          // 功    能：   返回插卡标志
    918          // 入口参数：   无
    919          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
    920          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    921          void   ResetPlugFlgEvt(void)
    922          {
    923              //mPlugInFlg = NO_PLUG_IN_CARD;						//卡拔表示自动判断
    924          }
   \                     ResetPlugFlgEvt: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    925          
    926          //---------------------------------------------------------------------
    927          // 名    称：   void   LongTimePlugCard( void )
    928          // 功    能：   长时间插入IC卡错误
    929          // 入口参数：   无
    930          // 出口参数：   无
    931          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    932          uint8_t   LongTimePlugCard( void )
    933          {
   \                     LongTimePlugCard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    934          	l_LongTimePlugCardErrFlg = NO_ERROR;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable19_13
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    935          	
    936          	if(GetPlugTime() > 10*60*100)
   \   00000008   0x.... 0x....      BL       GetPlugTime
   \   0000000C   0xF64E 0x2161      MOVW     R1,#+60001
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD302             BCC.N    ??LongTimePlugCard_0
    937          	{
    938          		l_LongTimePlugCardErrFlg = ERROR;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable19_13
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    939          	}
    940          	
    941          	return	l_LongTimePlugCardErrFlg;
   \                     ??LongTimePlugCard_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable19_13
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    942          }
    943          
    944          //---------------------------------------------------------------------
    945          // 名    称：   void   GetLongTimePlugCardErrFlg( void )
    946          // 功    能：   长时间插入IC卡错误
    947          // 入口参数：   无
    948          // 出口参数：   无
    949          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    950          uint8_t   GetLongTimePlugCardErrFlg( void )
    951          {
    952          	return	l_LongTimePlugCardErrFlg;
   \                     GetLongTimePlugCardErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19_13
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    953          }
    954          
    955          

   \                                 In section .text, align 2, keep-with-next
    956          uint8    InitCardPageInfo(void)
    957          {
   \                     InitCardPageInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    958              uint8_t	CardSta;
    959          
    960              CardSta = StatusRegisterRead_Card();			//读IC卡状态
   \   00000002   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000006   0x0004             MOVS     R4,R0
    961              
    962              if(	(	((CardSta & AT45DB041) == AT45DB041) 
    963                  || 	((CardSta & AT45DB161) == AT45DB161)
    964                  || 	((CardSta & AT45DB321) == AT45DB321)
    965                  || 	((CardSta & AT45DB642) == AT45DB642))
    966                  && 	( CardSta != 0xff) )
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF014 0x001C      ANDS     R0,R4,#0x1C
   \   0000000E   0x281C             CMP      R0,#+28
   \   00000010   0xD00E             BEQ.N    ??InitCardPageInfo_0
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0xF014 0x002C      ANDS     R0,R4,#0x2C
   \   00000018   0x282C             CMP      R0,#+44
   \   0000001A   0xD009             BEQ.N    ??InitCardPageInfo_0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0xF014 0x0034      ANDS     R0,R4,#0x34
   \   00000022   0x2834             CMP      R0,#+52
   \   00000024   0xD004             BEQ.N    ??InitCardPageInfo_0
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000002C   0x283C             CMP      R0,#+60
   \   0000002E   0xD109             BNE.N    ??InitCardPageInfo_1
   \                     ??InitCardPageInfo_0: (+1)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2CFF             CMP      R4,#+255
   \   00000034   0xD006             BEQ.N    ??InitCardPageInfo_1
    967              {
    968                  l_CardErrorFlg = NO_ERROR;					//清卡类型错误
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x....             LDR.N    R1,??DataTable19_14
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    969                  
    970                  InitCardInfo();								//初始化卡信息
   \   0000003C   0x.... 0x....      BL       InitCardInfo
    971          
    972                  return TRUE; 								//返回1	
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??InitCardPageInfo_2
    973              }
    974              return FALSE;
   \                     ??InitCardPageInfo_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??InitCardPageInfo_2: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    975          }
    976          
    977          //void	ReStartPluse(void);										//关柴速测量
    978          //---------------------------------------------------------------------
    979          // 名    称：   uint8_t   PlugICCard(void)
    980          // 功    能：   判断是否插入IC卡
    981          // 入口参数：   无
    982          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
    983          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    984          uint8_t PlugICCard(void)
    985          {
   \                     PlugICCard: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    986          	uint8_t	CardSta;
    987          	uint8_t	Flg;
    988          	uint8_t	Times;
    989          
    990              Times 	= 3; 
   \   00000004   0x2003             MOVS     R0,#+3
   \   00000006   0x0006             MOVS     R6,R0
    991              Flg 	= FALSE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0005             MOVS     R5,R0
    992                        
    993              while(Times-- && Flg == FALSE) 							//判断3次
   \                     ??PlugICCard_0: (+1)
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x1E46             SUBS     R6,R0,#+1
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD042             BEQ.N    ??PlugICCard_1
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD13F             BNE.N    ??PlugICCard_1
    994              {        
    995          	    NOP();
   \   0000001C   0x.... 0x....      BL       `NOP`
    996          		if(GetPlugFlg() == PLUG_IN_CARD)					//有卡插入
   \   00000020   0x.... 0x....      BL       GetPlugFlg
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD134             BNE.N    ??PlugICCard_2
    997          	    {
    998          	    	WritePOW_IC( 0 );								//开电源
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       WritePOW_IC
    999          
   1000          			//DelayX10ms(20);
   1001                      OS_ERR  os_err;
   1002                      OSTimeDlyHMSM(0, 0, 0, 20,
   1003                            OS_OPT_TIME_HMSM_STRICT, &os_err);
   \   0000002E   0xA802             ADD      R0,SP,#+8
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0x2314             MOVS     R3,#+20
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       OSTimeDlyHMSM
   1004                                          
   1005          			CardSta = StatusRegisterRead_Card();			//读IC卡状态
   \   00000042   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000046   0x0004             MOVS     R4,R0
   1006          			
   1007          			if(	(	((CardSta & AT45DB041) == AT45DB041) 
   1008          				|| 	((CardSta & AT45DB161) == AT45DB161)
   1009          		 		|| 	((CardSta & AT45DB321) == AT45DB321)
   1010          		 		|| 	((CardSta & AT45DB642) == AT45DB642))
   1011          				&& 	( CardSta != 0xff) )
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0xF014 0x001C      ANDS     R0,R4,#0x1C
   \   0000004E   0x281C             CMP      R0,#+28
   \   00000050   0xD00E             BEQ.N    ??PlugICCard_3
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0xF014 0x002C      ANDS     R0,R4,#0x2C
   \   00000058   0x282C             CMP      R0,#+44
   \   0000005A   0xD009             BEQ.N    ??PlugICCard_3
   \   0000005C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005E   0xF014 0x0034      ANDS     R0,R4,#0x34
   \   00000062   0x2834             CMP      R0,#+52
   \   00000064   0xD004             BEQ.N    ??PlugICCard_3
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000006C   0x283C             CMP      R0,#+60
   \   0000006E   0xD10A             BNE.N    ??PlugICCard_4
   \                     ??PlugICCard_3: (+1)
   \   00000070   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000072   0x2CFF             CMP      R4,#+255
   \   00000074   0xD007             BEQ.N    ??PlugICCard_4
   1012          			{
   1013          				l_CardErrorFlg = NO_ERROR;					//清卡类型错误
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x....             LDR.N    R1,??DataTable19_14
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
   1014          				
   1015          				InitCardInfo();								//初始化卡信息
   \   0000007C   0x.... 0x....      BL       InitCardInfo
   1016          
   1017          				Flg = TRUE; 								//返回1	
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x0005             MOVS     R5,R0
   1018          				break;		
   \   00000084   0xE00A             B.N      ??PlugICCard_1
   1019          			}	
   1020          			else
   1021          			{		 
   1022          				l_CardErrorFlg = ERROR;						//置卡错误
   \                     ??PlugICCard_4: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x....             LDR.N    R1,??DataTable19_14
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
   1023          				
   1024          				Flg = FALSE;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x0005             MOVS     R5,R0
   \   00000090   0xE7BC             B.N      ??PlugICCard_0
   1025          			}	
   1026          
   1027          		}
   1028          		else
   1029          		{
   1030          			l_CardErrorFlg = NO_ERROR;							//卡类
   \                     ??PlugICCard_2: (+1)
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x....             LDR.N    R1,??DataTable19_14
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   1031          			
   1032          			Flg = FALSE;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x0005             MOVS     R5,R0
   1033          
   1034          			break;	
   1035          		}
   1036          	}
   1037          	
   1038          	if(Flg == FALSE)
   \                     ??PlugICCard_1: (+1)
   \   0000009C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009E   0x2D00             CMP      R5,#+0
   \   000000A0   0xD102             BNE.N    ??PlugICCard_5
   1039          	{
   1040          		WritePOW_IC( 1 );										//非卡，关电源
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x.... 0x....      BL       WritePOW_IC
   1041          	}
   1042          	
   1043          	return 	Flg;
   \                     ??PlugICCard_5: (+1)
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xB004             ADD      SP,SP,#+16
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
   1044          }
   1045          
   1046          //---------------------------------------------------------------------
   1047          // 名    称：   uint8_t   GetCardErrorFlg()
   1048          // 功    能：   返回插卡错误标志
   1049          // 入口参数：   无
   1050          // 出口参数：   TRUE:插入卡类型正确,FALSE:插入卡类型错误 
   1051          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1052          uint8_t   GetCardErrorFlg(void)
   1053          {
   1054              return  l_CardErrorFlg;
   \                     GetCardErrorFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19_14
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1055          }
   1056          
   1057          #define		RIGHT_DATA					0xff
   1058          #define		CARD_TYPE_ERR				62
   1059          #define		CARD_PLUG_LONG_TIME_ERR		61
   1060          #define		USB_TYPE_ERR				66
   1061          
   1062          extern	uint8_t	l_UsbErrFlg;
   1063          #define		ERR_USB_UNKNOWN 			0xFA
   1064          
   1065          //extern	uint8_t	TestCH376Host( void );
   1066          //-------------------------------------------------------------------------------------------------
   1067          //函数名称:            	uint8_t  JudgeCardError(void) 
   1068          //函数功能:             对IC卡的卡类型进行判断
   1069          //入口参数:            
   1070          //出口参数:             
   1071          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1072          uint8_t  JudgeCardError(void) 
   1073          {
   \                     JudgeCardError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1074          	uint8_t		ErrorType;
   1075          	
   1076          	#ifdef	HARD_VER_111122	
   1077          	static		uint32	Times = 0;
   1078          	#endif
   1079          	
   1080          	ErrorType = RIGHT_DATA;
   \   00000002   0x20FF             MOVS     R0,#+255
   \   00000004   0x0004             MOVS     R4,R0
   1081          	
   1082          	if(GetCardErrorFlg() == ERROR)
   \   00000006   0x.... 0x....      BL       GetCardErrorFlg
   1083          	{
   1084          //		ErrorType = CARD_TYPE_ERR;
   1085          	}
   1086          	
   1087          	if(GetLongTimePlugCardErrFlg() == ERROR)
   \   0000000A   0x.... 0x....      BL       GetLongTimePlugCardErrFlg
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??JudgeCardError_0
   1088          	{
   1089          		ErrorType = CARD_PLUG_LONG_TIME_ERR;
   \   00000012   0x203D             MOVS     R0,#+61
   \   00000014   0x0004             MOVS     R4,R0
   1090          	}
   1091          	
   1092          	#ifdef	HARD_VER_111122	
   1093          	if(TestCH376Host() == ERR_USB_UNKNOWN)
   1094          	{
   1095          		if(Times++ < 10)
   1096          		{
   1097          			mInitCH376Host();
   1098          		}
   1099          
   1100          		ErrorType = USB_TYPE_ERR;
   1101          	}
   1102          	else
   1103          	{
   1104          		Times = 0;
   1105          	}
   1106          	#endif
   1107          	
   1108          	return	ErrorType;
   \                     ??JudgeCardError_0: (+1)
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1109          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40088000         DC32     0x40088000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     Bsp_Card_Sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x4008800C         DC32     0x4008800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x40088008         DC32     0x40088008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     l_CardPageSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x........         DC32     l_CardStartAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x........         DC32     l_CardPageNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x........         DC32     l_CardTypeFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0x........         DC32     l_CardBufNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \   00000000   0x........         DC32     mPlugTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \   00000000   0x........         DC32     mPlugInFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_12:
   \   00000000   0x........         DC32     mNoPlugTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_13:
   \   00000000   0x........         DC32     l_LongTimePlugCardErrFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_14:
   \   00000000   0x........         DC32     l_CardErrorFlg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x63 0x61          DC8 "card Sem"
   \              0x72 0x64    
   \              0x20 0x53    
   \              0x65 0x6D    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1110          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   BufferRead_Card
        32   -> MainMemoryToBuff
        32   -> RevByte_SPI
        32   -> SentByte_SPI
        32   -> StatusRegisterRead_Card
        32   -> WriteCS_IC
      32   BufferToMainMemoryPageProgramWithBuilt_inErase_Card
        32   -> BufferWrite_Card
        32   -> SentByte_SPI
        32   -> StatusRegisterRead_Card
        32   -> WriteCS_IC
      24   BufferWrite_Card
        24   -> SentByte_SPI
        24   -> WriteCS_IC
      24   ContinuousArrayRead_Card
        24   -> RevByte_SPI
        24   -> SentByte_SPI
        24   -> StatusRegisterRead_Card
        24   -> WriteCS_IC
       0   GetCardErrorFlg
       0   GetCardPageSize
       0   GetLongTimePlugCardErrFlg
       8   GetPlugFlg
         8   -> WritePOW_IC
       0   GetPlugTime
       0   GetToEndLen
       8   HoldCard
         8   -> PlugCard
       8   InitCardIO
         8   -> BSP_OS_SemCreate
         8   -> GPIO_PinselConfig
         8   -> SSP0_Init
       8   InitCardInfo
         8   -> StatusRegisterRead_Card
       8   InitCardPageInfo
         8   -> InitCardInfo
         8   -> StatusRegisterRead_Card
       8   JudgeCardError
         8   -> GetCardErrorFlg
         8   -> GetLongTimePlugCardErrFlg
       8   LongTimePlugCard
         8   -> GetPlugTime
      16   MainMemoryToBuff
        16   -> SentByte_SPI
        16   -> StatusRegisterRead_Card
        16   -> WriteCS_IC
       8   PlugCard
         8   -> ReadIC_SWT
      32   PlugICCard
        32   -> GetPlugFlg
        32   -> InitCardInfo
        32   -> NOP
        32   -> OSTimeDlyHMSM
        32   -> StatusRegisterRead_Card
        32   -> WritePOW_IC
      56   ReadCard
        56   -> ContinuousArrayRead_Card
       8   ReadIC_SWT
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   RecByte_SPI_IC
         8   -> SendOrRecByte_SPI_IC
       0   ResetPlugFlgEvt
       8   RevByte_SPI
         8   -> RecByte_SPI_IC
      32   SSP0_Init
        32   -> SSP_Cmd
        32   -> SSP_ConfigStructInit
        32   -> SSP_Init
       8   SendByte_SPI_IC
         8   -> SendOrRecByte_SPI_IC
       0   SendOrRecByte_SPI_IC
       8   SentByte_SPI
         8   -> SendByte_SPI_IC
       8   StatusRegisterRead_Card
         8   -> RevByte_SPI
         8   -> SentByte_SPI
         8   -> WriteCS_IC
       8   WriteCS_IC
         8   -> GPIO_PinselConfig
         8   -> GPIO_SetOrClearValue
         8   -> nop
      56   WriteCard
        56   -> WriteCardPage
    1056   WriteCardPage
      1056   -> BufferToMainMemoryPageProgramWithBuilt_inErase_Card
      1056   -> ContinuousArrayRead_Card
      1056   -> __aeabi_memcpy
       8   WriteIC_RST
         8   -> GPIO_PinselConfig
         8   -> GPIO_SetOrClearValue
       8   WriteIC_SWT
         8   -> GPIO_SetOrClearValue
       8   WritePOW_IC
         8   -> GPIO_SetOrClearValue
         8   -> nop
       8   WriteSoftSpiCSIC
         8   -> GPIO_SetOrClearValue
         8   -> nop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      12  ?_0
      40  Bsp_Card_Sem
     162  BufferRead_Card
     244  BufferToMainMemoryPageProgramWithBuilt_inErase_Card
     114  BufferWrite_Card
     292  ContinuousArrayRead_Card
       6  GetCardErrorFlg
       8  GetCardPageSize
       6  GetLongTimePlugCardErrFlg
      30  GetPlugFlg
       6  GetPlugTime
      20  GetToEndLen
       8  HoldCard
      62  InitCardIO
     200  InitCardInfo
      72  InitCardPageInfo
      28  JudgeCardError
      32  LongTimePlugCard
     204  MainMemoryToBuff
      80  PlugCard
     176  PlugICCard
     270  ReadCard
      20  ReadIC_SWT
      14  RecByte_SPI_IC
       2  ResetPlugFlgEvt
      14  RevByte_SPI
      34  SSP0_Init
      14  SendByte_SPI_IC
      74  SendOrRecByte_SPI_IC
      16  SentByte_SPI
       1  Spi0FinishFlg
      44  StatusRegisterRead_Card
      46  WriteCS_IC
     258  WriteCard
     210  WriteCardPage
      38  WriteIC_RST
      30  WriteIC_SWT
      38  WritePOW_IC
      34  WriteSoftSpiCSIC
       1  l_CardBufNum
       1  l_CardErrorFlg
       4  l_CardPageNum
       4  l_CardPageSize
       4  l_CardStartAddr
       1  l_CardTypeFlg
       1  l_LongTimePlugCardErrFlg
       4  l_Spi0Len
       4  l_Spi0Point
       4  mNoPlugTime
       1  mPlugInFlg
       4  mPlugTime

 
    71 bytes in section .bss
     3 bytes in section .data
    12 bytes in section .rodata
 2 966 bytes in section .text
 
 2 966 bytes of CODE  memory
    12 bytes of CONST memory
    74 bytes of DATA  memory

Errors: none
Warnings: none

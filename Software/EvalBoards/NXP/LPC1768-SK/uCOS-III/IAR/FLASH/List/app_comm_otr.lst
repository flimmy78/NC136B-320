###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       18/Dec/2017  17:20:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320 IC卡模块\Software\APP\comm\app_comm_otr.c
#    Command line =  
#        "F:\iar\NC136B-320 IC卡模块\Software\APP\comm\app_comm_otr.c" -lCN
#        "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\app_comm_otr.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC卡模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\app_comm_otr.o
#
###############################################################################

F:\iar\NC136B-320 IC卡模块\Software\APP\comm\app_comm_otr.c
      1          /*******************************************************************************
      2          *   Filename:       app_comm_otr.c
      3          *   Revised:        All copyrights reserved to redmorningcn.
      4          *   Revision:       v1.0
      5          *   Writer:	     redmorningcn.
      6          *
      7          *   Description:    双击选中 otr 按 Ctrl + H, 钩选 Match the case, Replace with
      8          *                   输入您要的名字，点击 Replace All
      9          *                   双击选中 Otr 按 Ctrl + H, 钩选 Match the case, Replace with
     10          *                   输入您要的名字，点击 Replace All
     11          *                   双击选中 OTR 按 Ctrl + H, 钩选 Match the case, Replace with
     12          *                   输入您要的名字，点击 Replace All
     13          *                   在 app_cfg.h 中指定本任务的 优先级  （ APP_TASK_COMM_PRIO     ）
     14          *                                            和 任务堆栈（ APP_TASK_COMM_STK_SIZE ）大小
     15          *
     16          *   Notes:
     17          *     				E-mail: redmorningcn@qq.com
     18          *
     19          *******************************************************************************/
     20          
     21          /*******************************************************************************
     22          * INCLUDES
     23          */
     24          #define  SNL_APP_SOURCE
     25          #include <includes.h>
     26          #include <app_comm_protocol.h>
     27          #include <app_ctrl.h>
     28          #include <app.h>
     29          #include <os_cfg_app.h>
     30          #include <RecDataTypeDef.h>
     31          
     32          
     33          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     34          const  CPU_CHAR  *app_comm_otr__c = "$Id: $";
     35          #endif
     36          
     37          #define APP_TASK_COMM_EN     DEF_ENABLED
     38          #if APP_TASK_COMM_EN == DEF_ENABLED
     39          /*******************************************************************************
     40          * CONSTANTS
     41          */
     42          
     43          /*******************************************************************************
     44          * MACROS
     45          */
     46          #define CYCLE_TIME_TICKS            (OS_TICKS_PER_SEC * 1)
     47          
     48          /*******************************************************************************
     49          * TYPEDEFS
     50          */
     51          #define		DATA_CARD           0x00000001			//数据卡------暂时未用
     52          #define		CALC_MODEL_CARD     0x00000002			//计算模型卡--暂时未用
     53          #define		IAP_CARD            0x00000004			//IAP升级-----暂时未用
     54          
     55          #define		DENSITY_CARD		0x00000020			//密度卡
     56          #define		MODEL_CARD			0x00000040			//模型卡-----暂时未用
     57          #define		TIME_CARD           0x00000100			//时间卡-----
     58          #define		COM_MODEL_CARD	    0x00000100		    //串口模型卡-暂时未用
     59          #define		HIGHT_CARD			0x00000200			//高度卡-----
     60          #define		COPY_CARD           0x00000400			//复制卡-----暂时未用
     61          #define		MODEL_SELECT_CARD	0x00001000			//模型选择卡-
     62          #define		FIX_CARD            0x00002000			//装车卡-----
     63          #define		COPY_FRAM_CARD	    0x00004000			//铁电复制卡-暂时未用
     64          #define		SET_DATA_CARD		0x00000080			//置数卡-----按时未用
     65          #define		DEBUG_CARD			0x00000800			//调试卡-----暂时未用
     66          
     67          #define		EXPAND_CARD			0x00008000			//扩展卡-----暂时未用
     68          
     69          #define		DATA_CARD_ERR		0x00008000			//IC卡错误
     70          
     71          #define		DATA_CARD_DIS		0x00010000			//数据卡指示
     72          #define		DATA_CARD_FIN		0x00020000			//数据卡结束
     73          #define		SYS_RUN_PARA		0x00040000			//系统参数卡--暂未使用
     74          #define		CLEAR_ALL			0x00080000			//清零卡，数据记录清零
     75          
     76          #define		RST_SYS				0x00100000		    //复位指令
     77          #define		CALC_PARA           0x00200000		    //计算斜率
     78          
     79          /*******************************************************************************
     80          * LOCAL VARIABLES
     81          */
     82          
     83          /*******************************************************************************
     84          * GLOBAL VARIABLES
     85          */
     86          
     87          /***********************************************
     88          * 描述： 软定时器声明
     89          */
     90          
     91          /***********************************************
     92          * 描述： 软定时器回调函数
     93          */
     94          
     95          
     96          /*******************************************************************************
     97          * LOCAL FUNCTIONS
     98          */
     99          
    100          
    101          /*******************************************************************************
    102          * GLOBAL FUNCTIONS
    103          */
    104          
    105          /*******************************************************************************
    106          * EXTERN VARIABLES
    107          */
    108          
    109          /*******************************************************************************
    110          * EXTERN FUNCTIONS
    111          */
    112          uint8   FRAM_StoreRecNumMgr(StrRecNumMgr  *SRecNumMgr);
    113          uint8   FRAM_StoreOilPara(StrOilPara  *SOilPara);
    114          void    BSP_DispClrAll(void);
    115          uint8   FRAM_StoreProductInfo(StrProductInfo  *sProductInfo);
    116          void    comm_para_flow(StrDevOtr * sDtu,uint8 addrnum);
    117          uint8 	ReadFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen);            
    118          uint32  GetRecNumAddr(uint32 FlshRecNum);
    119          INT8U	WriteFlsh(INT32U Dst, uint8 * sFlshRec, INT32U NByte);
    120          
    121          
    122          /*******************************************************************************/
    123          extern  stcSysCtrl      sCtrl;

   \                                 In section .bss, align 4
    124          stcModelCard            m_sModelCard;
   \                     m_sModelCard:
   \   00000000                      DS8 5956
    125          
    126          /*******************************************************************************
    127          * 名    称： DataComReadAsk
    128          * 功    能： IC卡请求数据记录。
    129          			 开始数据记录号和结束数据记录号。
    130          * 入口参数： 
    131          * 出口参数： 无
    132          * 作　  者： redmorningcn.
    133          * 创建日期： 2017-05-31
    134          * 修    改：
    135          * 修改日期：
    136          * 备    注： 任务创建函数需要在app.h文件中声明
    137          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    138          void DataComReadAsk(unsigned int startnum,unsigned int endnum)
    139          {
   \                     DataComReadAsk: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    140          	sCtrl.Otr.Wr.Code = DATA_CARD;						//数据类型
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000000C   0xF8C1 0x015C      STR      R0,[R1, #+348]
    141          	sCtrl.Otr.Wr.Info.sReqRec.StartNum 	= startnum;		//开始记录
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000014   0xF8C0 0x4160      STR      R4,[R0, #+352]
    142          	sCtrl.Otr.Wr.Info.sReqRec.EndNum	= endnum;		//结束记录
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000001C   0xF8C0 0x5164      STR      R5,[R0, #+356]
    143          	
    144          	CSNC_SendData(	sCtrl.Otr.pch,						//通讯控制块
    145                            SLAVE_ADDR_OTR,						//源地址
    146                            MASTE_ADDR_HOST,					    //目标地址
    147                            sCtrl.Otr.ConnCtrl[0].SendFramNum,	//发送帧号
    148                            0,									//帧类型，默认为0，在数据区内明确		
    149                            (uint8 *)&sCtrl.Otr.Wr,				//发送缓冲区
    150                            //发送数据区长度
    151                            sizeof(sCtrl.Otr.Wr.Code)+sizeof(sCtrl.Otr.Wr.Info.sReqRec));
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0x9002             STR      R0,[SP, #+8]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000032   0xF890 0x320E      LDRB     R3,[R0, #+526]
   \   00000036   0x2280             MOVS     R2,#+128
   \   00000038   0x21C1             MOVS     R1,#+193
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000003E   0xF8D0 0x0218      LDR      R0,[R0, #+536]
   \   00000042   0x.... 0x....      BL       CSNC_SendData
    152          }
   \   00000046   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    153          
    154          
    155          /*******************************************************************************
    156          * 名    称： 取机车信息
    157          * 功    能： 
    158          * 入口参数： 
    159          * 出口参数： 无
    160          * 作　  者： redmorningcn.
    161          * 创建日期： 2017-12-06
    162          * 修    改：
    163          * 修改日期：
    164          * 备    注： 任务创建函数需要在app.h文件中声明
    165          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    166          uint8  	JudegLocoInfo(uint8   buf[])
    167          {
   \                     JudegLocoInfo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    168              uint16  crc16;
    169              stcFlshRec	*psRec;						    //数据记录     128 	
    170              psRec       = (stcFlshRec	*)buf;
   \   00000004   0x0026             MOVS     R6,R4
    171              
    172              crc16 = GetCrc16Check(buf,sizeof(stcFlshRec)-2);
   \   00000006   0x217E             MOVS     R1,#+126
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       GetCrc16Check
   \   0000000E   0x0005             MOVS     R5,R0
    173              
    174              if(crc16 == psRec->CrcCheck){               //校验正确
   \   00000010   0xF8B6 0x007E      LDRH     R0,[R6, #+126]
   \   00000014   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD133             BNE.N    ??JudegLocoInfo_0
    175                  //机车信息错误，
    176                  if(     psRec->JcRealType   != 0xffff 
    177                     &&   psRec->JcRealNo     != 0xffff
    178                         &&    psRec->JcRealType  != 0 
    179                             &&   psRec->JcRealNo     != 0    ){
   \   0000001A   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   0000001E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD02D             BEQ.N    ??JudegLocoInfo_0
   \   00000026   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   0000002A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD027             BEQ.N    ??JudegLocoInfo_0
   \   00000032   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD023             BEQ.N    ??JudegLocoInfo_0
   \   0000003A   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD01F             BEQ.N    ??JudegLocoInfo_0
    180                                 
    181                                 if(psRec->JcRealType   == sCtrl.sProductInfo.sLocoId.Type
    182                                     &&psRec->JcRealNo     == sCtrl.sProductInfo.sLocoId.Num){
   \   00000042   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000004A   0x8B89             LDRH     R1,[R1, #+28]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD108             BNE.N    ??JudegLocoInfo_1
   \   00000050   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000058   0x8BC9             LDRH     R1,[R1, #+30]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??JudegLocoInfo_1
    183                                         return 1;                       //机车信息正确
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE010             B.N      ??JudegLocoInfo_2
    184                                     }
    185                                 
    186                                 sCtrl.sProductInfo.sLocoId.Type = psRec->JcRealType ; 
   \                     ??JudegLocoInfo_1: (+1)
   \   00000062   0xF8B6 0x0064      LDRH     R0,[R6, #+100]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000006A   0x8388             STRH     R0,[R1, #+28]
    187                                 sCtrl.sProductInfo.sLocoId.Num  = psRec->JcRealNo   ;
   \   0000006C   0xF8B6 0x0066      LDRH     R0,[R6, #+102]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000074   0x83C8             STRH     R0,[R1, #+30]
    188                                 
    189                                 FRAM_StoreProductInfo((StrProductInfo  *)&sCtrl.sProductInfo);//存机车号
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   0000007A   0x.... 0x....      BL       FRAM_StoreProductInfo
    190                                 return 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??JudegLocoInfo_2
    191                             }
    192              }
    193              
    194              return 1;
   \                     ??JudegLocoInfo_0: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \                     ??JudegLocoInfo_2: (+1)
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    195          }
    196          
    197          //stcFlshRec  sFlshRecTmp;
    198          
    199          /*******************************************************************************
    200          * 名    称： comm_rec_read
    201          * 功    能： 读取数据记录
    202          * 入口参数： 
    203          * 出口参数： 无
    204          * 作　  者： redmorningcn.
    205          * 创建日期： 2017-05-26
    206          * 修    改：
    207          * 修改日期：
    208          * 备    注： 任务创建函数需要在app.h文件中声明
    209          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    210          void	comm_rec_read(StrDevOtr * sDtu,uint8 addrnum)
    211          {
   \                     comm_rec_read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    212              /***********************************************
    213              * 描述： 更具数据长度，判读接收的是否为数据记录。
    214              * 		 接收长度为128，数据记录；长度小于128,接收
    215              * 		 普通数据。
    216              */ 
    217          	static	    uint8	    errtimes = 0;
    218              static     uint8       recsmalltimes = 0;//接收到的记录号小
    219              static     uint8       recbigtimes = 0; //接收到的记录号大
    220              static     uint8       rectimes = 0;
    221          	
    222          	//数据记录长度128字节
    223          	if(sCtrl.Otr.RxCtrl.Len == sizeof(sCtrl.Otr.Rd.sRec)){		
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000000A   0xF890 0x0203      LDRB     R0,[R0, #+515]
   \   0000000E   0x2880             CMP      R0,#+128
   \   00000010   0xF040 0x80AD      BNE.W    ??comm_rec_read_0
    224          		//存数据记录
    225          		if(sCtrl.Otr.Rd.sRec.StoreCnt == sCtrl.sRecNumMgr.IcRead){//如果接收到的数据记录和想要接收的相同，则保存数据。		
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000018   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000020   0x6889             LDR      R1,[R1, #+8]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD156             BNE.N    ??comm_rec_read_1
    226          			//保存数据记录
    227                      recsmalltimes = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    228                      recbigtimes = 0;    
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    229                                     
    230          			sCtrl.sRecNumMgr.IcRead++;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000042   0x6088             STR      R0,[R1, #+8]
    231                      
    232          //            if(++rectimes == 1 )        //开机或256次后，判断一次
    233          //            {
    234          //                if(JudegLocoInfo((uint8 *)&sCtrl.Otr.Rd.sRec) == 0)//机车信息变化，记录号清零(bug如果中途变更了车号，后续数据无法读取。)
    235          //                    sCtrl.sRecNumMgr.IcRead = 0;
    236          //            }
    237                      
    238          			//如果还有数据未取完，继续请求数据。
    239          			if(sCtrl.sRecNumMgr.IcRead < sCtrl.sRecNumMgr.Current){	
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000048   0x6880             LDR      R0,[R0, #+8]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000004E   0x6849             LDR      R1,[R1, #+4]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD20D             BCS.N    ??comm_rec_read_2
    240          				errtimes = 0;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   0000005A   0x7008             STRB     R0,[R1, #+0]
    241          				DataComReadAsk(sCtrl.sRecNumMgr.IcRead,sCtrl.sRecNumMgr.IcRead +1);
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000060   0x6880             LDR      R0,[R0, #+8]
   \   00000062   0x1C41             ADDS     R1,R0,#+1
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000068   0x6880             LDR      R0,[R0, #+8]
   \   0000006A   0x.... 0x....      BL       DataComReadAsk
   \   0000006E   0xE019             B.N      ??comm_rec_read_3
    242          				
    243          			}else if(sCtrl.sRecNumMgr.IcRead > sCtrl.sRecNumMgr.Current){
   \                     ??comm_rec_read_2: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000074   0x6840             LDR      R0,[R0, #+4]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000007A   0x6889             LDR      R1,[R1, #+8]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD211             BCS.N    ??comm_rec_read_3
    244          				errtimes++;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    245          				if(errtimes > 2)									//流水号异常。
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0x2803             CMP      R0,#+3
   \   00000096   0xDB05             BLT.N    ??comm_rec_read_3
    246          					sCtrl.sRecNumMgr.IcRead = sCtrl.sRecNumMgr.Current;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000009C   0x6840             LDR      R0,[R0, #+4]
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000000A2   0x6088             STR      R0,[R1, #+8]
    247          			}
    248                      
    249          		  	uint32	FlshAddr = GetRecNumAddr(sCtrl.Otr.Rd.sRec.StoreCnt);       //先应答再存储
   \                     ??comm_rec_read_3: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable4
   \   000000A8   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   000000AC   0x.... 0x....      BL       GetRecNumAddr
   \   000000B0   0x0006             MOVS     R6,R0
    250                      
    251          			WriteFlsh(FlshAddr, (uint8 *)&sCtrl.Otr.Rd.sRec, sizeof(stcFlshRec));
   \   000000B2   0x2280             MOVS     R2,#+128
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable4_6
   \   000000B8   0x0030             MOVS     R0,R6
   \   000000BA   0x.... 0x....      BL       WriteFlsh
    252                      
    253                      ReadFlsh(FlshAddr, (uint8 *)&sCtrl.sRec, sizeof(stcFlshRec));       //存储器判断
   \   000000BE   0x2280             MOVS     R2,#+128
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   000000C4   0x0030             MOVS     R0,R6
   \   000000C6   0x.... 0x....      BL       ReadFlsh
    254                      
    255          			FRAM_StoreRecNumMgr((StrRecNumMgr *)&sCtrl.sRecNumMgr);	//存流水号
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000CE   0x.... 0x....      BL       FRAM_StoreRecNumMgr
   \   000000D2   0xE085             B.N      ??comm_rec_read_4
    256                      
    257          		}
    258                  else  if(sCtrl.Otr.Rd.sRec.StoreCnt +1 == sCtrl.sRecNumMgr.Current) //无最新记录，发前条数据，不处理
   \                     ??comm_rec_read_1: (+1)
   \   000000D4   0x....             LDR.N    R0,??DataTable4
   \   000000D6   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x....             LDR.N    R1,??DataTable4
   \   000000DE   0x6849             LDR      R1,[R1, #+4]
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xD07D             BEQ.N    ??comm_rec_read_4
    259                  {
    260                  }
    261                  else
    262                  //if(sCtrl.Otr.Rd.sRec.StoreCnt < sCtrl.sRecNumMgr.IcRead ) //流水号比已存的小，认为是新换盒体，重新更改流水号
    263                  {
    264                      recsmalltimes++;
   \   000000E4   0x....             LDR.N    R0,??DataTable4_3
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x1C40             ADDS     R0,R0,#+1
   \   000000EA   0x....             LDR.N    R1,??DataTable4_3
   \   000000EC   0x7008             STRB     R0,[R1, #+0]
    265                      if(recsmalltimes > 3){                                  //数据异常处理
   \   000000EE   0x....             LDR.N    R0,??DataTable4_3
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x2804             CMP      R0,#+4
   \   000000F4   0xDB74             BLT.N    ??comm_rec_read_4
    266                          recsmalltimes = 0;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x....             LDR.N    R1,??DataTable4_3
   \   000000FA   0x7008             STRB     R0,[R1, #+0]
    267                          
    268                          if(sCtrl.Otr.Rd.sRec.StoreCnt != 0xffffffff && sCtrl.Otr.Rd.sRec.StoreCnt != 0)
   \   000000FC   0x....             LDR.N    R0,??DataTable4
   \   000000FE   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   00000102   0xF110 0x0F01      CMN      R0,#+1
   \   00000106   0xD01B             BEQ.N    ??comm_rec_read_5
   \   00000108   0x....             LDR.N    R0,??DataTable4
   \   0000010A   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD016             BEQ.N    ??comm_rec_read_5
    269                          {     //扇区正常     
    270                              if(sCtrl.Otr.Rd.sRec.StoreCnt < sCtrl.sRecNumMgr.Current) //数据记录在已存的记录范围内
   \   00000112   0x....             LDR.N    R0,??DataTable4
   \   00000114   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   00000118   0x....             LDR.N    R1,??DataTable4
   \   0000011A   0x6849             LDR      R1,[R1, #+4]
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD209             BCS.N    ??comm_rec_read_6
    271                              {
    272                                  sCtrl.sRecNumMgr.IcRead     = sCtrl.Otr.Rd.sRec.StoreCnt;               //
   \   00000120   0x....             LDR.N    R0,??DataTable4
   \   00000122   0xF8D0 0x00BC      LDR      R0,[R0, #+188]
   \   00000126   0x....             LDR.N    R1,??DataTable4
   \   00000128   0x6088             STR      R0,[R1, #+8]
    273                                  sCtrl.sRecNumMgr.CardRead   = sCtrl.sRecNumMgr.IcRead ;                 //重新x卡
   \   0000012A   0x....             LDR.N    R0,??DataTable4
   \   0000012C   0x6880             LDR      R0,[R0, #+8]
   \   0000012E   0x....             LDR.N    R1,??DataTable4
   \   00000130   0x6108             STR      R0,[R1, #+16]
   \   00000132   0xE00A             B.N      ??comm_rec_read_7
    274                              }else{
    275                                  sCtrl.sRecNumMgr.IcRead++;                              //如果无效，则记录号++，继续执行
   \                     ??comm_rec_read_6: (+1)
   \   00000134   0x....             LDR.N    R0,??DataTable4
   \   00000136   0x6880             LDR      R0,[R0, #+8]
   \   00000138   0x1C40             ADDS     R0,R0,#+1
   \   0000013A   0x....             LDR.N    R1,??DataTable4
   \   0000013C   0x6088             STR      R0,[R1, #+8]
   \   0000013E   0xE004             B.N      ??comm_rec_read_7
    276                              }
    277                          }             
    278                          else
    279                          {
    280                              sCtrl.sRecNumMgr.IcRead++;                              //如果无效，则记录号++，继续执行
   \                     ??comm_rec_read_5: (+1)
   \   00000140   0x....             LDR.N    R0,??DataTable4
   \   00000142   0x6880             LDR      R0,[R0, #+8]
   \   00000144   0x1C40             ADDS     R0,R0,#+1
   \   00000146   0x....             LDR.N    R1,??DataTable4
   \   00000148   0x6088             STR      R0,[R1, #+8]
    281                          }
    282                          
    283                          uint32	FlshAddr = GetRecNumAddr(sCtrl.sRecNumMgr.IcRead);       //先应答再存储
   \                     ??comm_rec_read_7: (+1)
   \   0000014A   0x....             LDR.N    R0,??DataTable4
   \   0000014C   0x6880             LDR      R0,[R0, #+8]
   \   0000014E   0x.... 0x....      BL       GetRecNumAddr
   \   00000152   0x0006             MOVS     R6,R0
    284                          
    285                          WriteFlsh(FlshAddr, (uint8 *)&sCtrl.Otr.Rd.sRec, sizeof(stcFlshRec));    
   \   00000154   0x2280             MOVS     R2,#+128
   \   00000156   0x....             LDR.N    R1,??DataTable4_6
   \   00000158   0x0030             MOVS     R0,R6
   \   0000015A   0x.... 0x....      BL       WriteFlsh
    286                          
    287                          DataComReadAsk(sCtrl.sRecNumMgr.IcRead,sCtrl.sRecNumMgr.IcRead +1);
   \   0000015E   0x....             LDR.N    R0,??DataTable4
   \   00000160   0x6880             LDR      R0,[R0, #+8]
   \   00000162   0x1C41             ADDS     R1,R0,#+1
   \   00000164   0x....             LDR.N    R0,??DataTable4
   \   00000166   0x6880             LDR      R0,[R0, #+8]
   \   00000168   0x.... 0x....      BL       DataComReadAsk
   \   0000016C   0xE038             B.N      ??comm_rec_read_4
    288                      }
    289                  }
    290          //        else
    291          //        {
    292          //            recbigtimes++;
    293          //            if(sCtrl.sRecNumMgr.IcRead  > 5){       //该数据记录异常，跳过该记录   
    294          //                recbigtimes = 0;
    295          //                sCtrl.sRecNumMgr.IcRead++;
    296          //
    297          //            }
    298          //        }
    299                  
    300          	}
    301          	else if(sCtrl.Otr.RxCtrl.Len == sizeof(sCtrl.Otr.Rd.sTinyRec))	//统计模块发起查询
   \                     ??comm_rec_read_0: (+1)
   \   0000016E   0x....             LDR.N    R0,??DataTable4
   \   00000170   0xF890 0x0203      LDRB     R0,[R0, #+515]
   \   00000174   0x2814             CMP      R0,#+20
   \   00000176   0xD12C             BNE.N    ??comm_rec_read_8
    302          	{
    303          		if(sCtrl.Otr.Rd.sTinyRec.CurRecNum < sCtrl.sRecNumMgr.IcRead)
   \   00000178   0x....             LDR.N    R0,??DataTable4
   \   0000017A   0xF8D0 0x00C0      LDR      R0,[R0, #+192]
   \   0000017E   0x....             LDR.N    R1,??DataTable4
   \   00000180   0x6889             LDR      R1,[R1, #+8]
   \   00000182   0x4288             CMP      R0,R1
   \   00000184   0xD215             BCS.N    ??comm_rec_read_9
    304          		{
    305          			errtimes++;
   \   00000186   0x....             LDR.N    R0,??DataTable4_5
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0x1C40             ADDS     R0,R0,#+1
   \   0000018C   0x....             LDR.N    R1,??DataTable4_5
   \   0000018E   0x7008             STRB     R0,[R1, #+0]
    306          			if( errtimes > 2 ){										//流水号异常。
   \   00000190   0x....             LDR.N    R0,??DataTable4_5
   \   00000192   0x7800             LDRB     R0,[R0, #+0]
   \   00000194   0x2803             CMP      R0,#+3
   \   00000196   0xDB23             BLT.N    ??comm_rec_read_4
    307          				sCtrl.sRecNumMgr.Current = sCtrl.Otr.Rd.sTinyRec.CurRecNum;
   \   00000198   0x....             LDR.N    R0,??DataTable4
   \   0000019A   0xF8D0 0x00C0      LDR      R0,[R0, #+192]
   \   0000019E   0x....             LDR.N    R1,??DataTable4
   \   000001A0   0x6048             STR      R0,[R1, #+4]
    308          				sCtrl.sRecNumMgr.IcRead = sCtrl.sRecNumMgr.Current;
   \   000001A2   0x....             LDR.N    R0,??DataTable4
   \   000001A4   0x6840             LDR      R0,[R0, #+4]
   \   000001A6   0x....             LDR.N    R1,??DataTable4
   \   000001A8   0x6088             STR      R0,[R1, #+8]
    309                          
    310          				FRAM_StoreRecNumMgr((StrRecNumMgr *)&sCtrl.sRecNumMgr);	//存流水号
   \   000001AA   0x....             LDR.N    R0,??DataTable4_8
   \   000001AC   0x.... 0x....      BL       FRAM_StoreRecNumMgr
   \   000001B0   0xE016             B.N      ??comm_rec_read_4
    311          			}
    312          		}
    313          		else
    314          		{
    315          			sCtrl.sRecNumMgr.Current = sCtrl.Otr.Rd.sTinyRec.CurRecNum;
   \                     ??comm_rec_read_9: (+1)
   \   000001B2   0x....             LDR.N    R0,??DataTable4
   \   000001B4   0xF8D0 0x00C0      LDR      R0,[R0, #+192]
   \   000001B8   0x....             LDR.N    R1,??DataTable4
   \   000001BA   0x6048             STR      R0,[R1, #+4]
    316          			DataComReadAsk(sCtrl.sRecNumMgr.IcRead,sCtrl.sRecNumMgr.IcRead +1);
   \   000001BC   0x....             LDR.N    R0,??DataTable4
   \   000001BE   0x6880             LDR      R0,[R0, #+8]
   \   000001C0   0x1C41             ADDS     R1,R0,#+1
   \   000001C2   0x....             LDR.N    R0,??DataTable4
   \   000001C4   0x6880             LDR      R0,[R0, #+8]
   \   000001C6   0x.... 0x....      BL       DataComReadAsk
    317                      
    318          			FRAM_StoreRecNumMgr((StrRecNumMgr *)&sCtrl.sRecNumMgr);	//存流水号
   \   000001CA   0x....             LDR.N    R0,??DataTable4_8
   \   000001CC   0x.... 0x....      BL       FRAM_StoreRecNumMgr
   \   000001D0   0xE006             B.N      ??comm_rec_read_4
    319          		}
    320          		
    321          	}else{			
    322                  //如果其他数据，应答接受请求
    323          		DataComReadAsk(sCtrl.sRecNumMgr.IcRead,sCtrl.sRecNumMgr.IcRead +1);
   \                     ??comm_rec_read_8: (+1)
   \   000001D2   0x....             LDR.N    R0,??DataTable4
   \   000001D4   0x6880             LDR      R0,[R0, #+8]
   \   000001D6   0x1C41             ADDS     R1,R0,#+1
   \   000001D8   0x....             LDR.N    R0,??DataTable4
   \   000001DA   0x6880             LDR      R0,[R0, #+8]
   \   000001DC   0x.... 0x....      BL       DataComReadAsk
    324          	}
    325              
    326          }
   \                     ??comm_rec_read_4: (+1)
   \   000001E0   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .bss, align 1
   \                     ??errtimes:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??recsmalltimes:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??recbigtimes:
   \   00000000                      DS8 1
    327          
    328          

   \                                 In section .bss, align 4
    329          static     	uint32      modelsendnum = 0;	//模型发送序号。
   \                     modelsendnum:
   \   00000000                      DS8 4
    330          /*******************************************************************************
    331          * 名    称： ClearModelSendNum
    332          * 功    能： 清模型发送序号。
    333          * 入口参数： 
    334          * 出口参数： 无
    335          * 作　  者： redmorningcn.
    336          * 创建日期： 2017-05-31
    337          * 修    改：
    338          * 修改日期：
    339          * 备    注： 任务创建函数需要在app.h文件中声明
    340          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    341          void	ClearModelSendNum(void)
    342          {
    343          	modelsendnum = 0;
   \                     ClearModelSendNum: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable4_9
   \   00000004   0x6008             STR      R0,[R1, #+0]
    344          }
   \   00000006   0x4770             BX       LR               ;; return
    345          
    346          /*******************************************************************************
    347          * 名    称： comm_para_flow
    348          * 功    能： 参数流。根据IC卡的类型进行操作
    349          * 入口参数： 
    350          * 出口参数： 无
    351          * 作　  者： redmorningcn.
    352          * 创建日期： 2017-05-26
    353          * 修    改：
    354          * 修改日期：
    355          * 备    注： 任务创建函数需要在app.h文件中声明
    356          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    357          void    comm_para_flow(StrDevOtr * sDtu,uint8 addrnum)
    358          {
   \                     comm_para_flow: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    359          //    stcTime     sTime;
    360          //    uint8       i = 0;
    361          //    uint32      modelrecvnum =0;
    362          //    uint32      tmp32;
    363          	uint8		Infolen = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    364          	uint8		*p = (uint8 *)&m_sModelCard;
   \   0000000A   0x....             LDR.N    R6,??DataTable4_10
    365              
    366              /***********************************************
    367              * 描述： 根据IC卡类型进行相应操作。卡类型在插入卡后，赋值
    368              * 	     如果未插卡，则认为是普通数据卡。
    369              */ 
    370              sDtu->Wr.Code	=	sCtrl.sRunPara.CardType;
   \   0000000C   0x....             LDR.N    R0,??DataTable4
   \   0000000E   0xF8D0 0x00B0      LDR      R0,[R0, #+176]
   \   00000012   0xF8C4 0x00A0      STR      R0,[R4, #+160]
    371          	
    372              switch (sCtrl.sRunPara.CardType)  	
   \   00000016   0x....             LDR.N    R0,??DataTable4
   \   00000018   0xF8D0 0x00B0      LDR      R0,[R0, #+176]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xF000 0x80D5      BEQ.W    ??comm_para_flow_0
   \   00000022   0x2820             CMP      R0,#+32
   \   00000024   0xD014             BEQ.N    ??comm_para_flow_1
   \   00000026   0x2840             CMP      R0,#+64
   \   00000028   0xD051             BEQ.N    ??comm_para_flow_2
   \   0000002A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000002E   0xD017             BEQ.N    ??comm_para_flow_3
   \   00000030   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000034   0xD01C             BEQ.N    ??comm_para_flow_4
   \   00000036   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000003A   0xD021             BEQ.N    ??comm_para_flow_5
   \   0000003C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000040   0xD035             BEQ.N    ??comm_para_flow_6
   \   00000042   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000046   0xD026             BEQ.N    ??comm_para_flow_7
   \   00000048   0xF5B0 0x3F00      CMP      R0,#+131072
   \   0000004C   0xD03C             BEQ.N    ??comm_para_flow_8
   \   0000004E   0xE0BE             B.N      ??comm_para_flow_9
    373              {
    374                  //设置密度
    375              case    DENSITY_CARD: 
    376                  sDtu->Wr.Info.Density	=	sCtrl.SOilPara.Density;
   \                     ??comm_para_flow_1: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable4
   \   00000052   0xF8B0 0x00A4      LDRH     R0,[R0, #+164]
   \   00000056   0xF8A4 0x00A4      STRH     R0,[R4, #+164]
    377                  Infolen	=	sizeof(sCtrl.SOilPara.Density);
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x0005             MOVS     R5,R0
    378                  break;
   \   0000005E   0xE0B7             B.N      ??comm_para_flow_10
    379                  
    380              case    HIGHT_CARD:  
    381                  sDtu->Wr.Info.Hig	=	sCtrl.SOilPara.Hig;
   \                     ??comm_para_flow_3: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable4
   \   00000062   0xF8B0 0x00A2      LDRH     R0,[R0, #+162]
   \   00000066   0xF8A4 0x00A4      STRH     R0,[R4, #+164]
    382                  Infolen	=	sizeof(sCtrl.SOilPara.Hig);            
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x0005             MOVS     R5,R0
    383                  break;
   \   0000006E   0xE0AF             B.N      ??comm_para_flow_10
    384                  
    385                  //模型选择卡
    386              case    MODEL_SELECT_CARD:   
    387                  sDtu->Wr.Info.ModelNum	=	sCtrl.SOilPara.ModelNum;
   \                     ??comm_para_flow_4: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable4
   \   00000072   0xF890 0x00A0      LDRB     R0,[R0, #+160]
   \   00000076   0xF884 0x00A4      STRB     R0,[R4, #+164]
    388                  Infolen	=	sizeof(sCtrl.SOilPara.ModelNum);
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x0005             MOVS     R5,R0
    389                  break;
   \   0000007E   0xE0A7             B.N      ??comm_para_flow_10
    390                  
    391                  //车型车号
    392              case    FIX_CARD: 
    393                  sDtu->Wr.Info.sLocoId.Num	=	sCtrl.sProductInfo.sLocoId.Num;
   \                     ??comm_para_flow_5: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable4
   \   00000082   0x8BC0             LDRH     R0,[R0, #+30]
   \   00000084   0xF8A4 0x00A6      STRH     R0,[R4, #+166]
    394                  sDtu->Wr.Info.sLocoId.Type	=	sCtrl.sProductInfo.sLocoId.Type;
   \   00000088   0x....             LDR.N    R0,??DataTable4
   \   0000008A   0x8B80             LDRH     R0,[R0, #+28]
   \   0000008C   0xF8A4 0x00A4      STRH     R0,[R4, #+164]
    395                  
    396                  Infolen	=	sizeof(	sCtrl.sProductInfo.sLocoId.Num) +
    397                      sizeof( sCtrl.sProductInfo.sLocoId.Type	);
   \   00000090   0x2004             MOVS     R0,#+4
   \   00000092   0x0005             MOVS     R5,R0
    398                  break;
   \   00000094   0xE09C             B.N      ??comm_para_flow_10
    399                  
    400                  //读数据指示
    401              case    DATA_CARD_DIS: 
    402                  
    403                  sDtu->Wr.Info.CardRecNum	=	sCtrl.sRec.StoreCnt;
   \                     ??comm_para_flow_7: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable4
   \   00000098   0x6A00             LDR      R0,[R0, #+32]
   \   0000009A   0xF8C4 0x00A4      STR      R0,[R4, #+164]
    404                  
    405                  Infolen	=	sizeof(sCtrl.sRec.StoreCnt);
   \   0000009E   0x2004             MOVS     R0,#+4
   \   000000A0   0x0005             MOVS     R5,R0
    406                  
    407                  sDtu->ConnCtrl[0].SendFramNum++;
   \   000000A2   0xF894 0x0152      LDRB     R0,[R4, #+338]
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0xF884 0x0152      STRB     R0,[R4, #+338]
    408                  
    409                  break;
   \   000000AC   0xE090             B.N      ??comm_para_flow_10
    410                  
    411              case    DATA_CARD_ERR: 
    412                  
    413                  sDtu->Wr.Info.Buf[0]	=	sCtrl.sRunPara.CardErrData;
   \                     ??comm_para_flow_6: (+1)
   \   000000AE   0x....             LDR.N    R0,??DataTable4
   \   000000B0   0xF890 0x00B4      LDRB     R0,[R0, #+180]
   \   000000B4   0xF884 0x00A4      STRB     R0,[R4, #+164]
    414                  
    415                  Infolen	=	sizeof(sCtrl.sRunPara.CardErrData);
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x0005             MOVS     R5,R0
    416                  
    417                  sDtu->ConnCtrl[0].SendFramNum++;
   \   000000BC   0xF894 0x0152      LDRB     R0,[R4, #+338]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0xF884 0x0152      STRB     R0,[R4, #+338]
    418                  
    419                  break;
   \   000000C6   0xE083             B.N      ??comm_para_flow_10
    420                          
    421                  //读数据指示结束
    422              case    DATA_CARD_FIN: 
    423                  
    424                  Infolen = 0;
   \                     ??comm_para_flow_8: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x0005             MOVS     R5,R0
    425                  break; 
   \   000000CC   0xE080             B.N      ??comm_para_flow_10
    426                  
    427                  /***********************************************
    428                  * 描述： 设置油箱模型。
    429                  *   IC 卡模块插入IC卡后，IC卡主动应答模型。  
    430                  *   后续每200ms发送数据，序号从0开始累加。
    431                  数据发送完成后，序号为0xffffffff。
    432                  */    
    433              case    MODEL_CARD: 
    434          //        if(sizeof(stcModelCard ) > 128 * modelsendnum )
    435          //        {
    436          //            if((sizeof(stcModelCard ) - 128 * modelsendnum) > 128 ){
    437          //                if(modelsendnum == 0)
    438          //                    p = (uint8 *)&m_sModelCard;		
    439          //                //数据序号
    440          //                memcpy((uint8 *)&sDtu->Wr.Info.Buf[0],(uint8 *)&modelsendnum,sizeof(modelsendnum));	
    441          //                //数据内容
    442          //                memcpy((uint8 *)&sDtu->Wr.Info.Buf[4],&p[modelsendnum*128],128);
    443          //                modelsendnum++;
    444          //                
    445          //                Infolen = sizeof(modelsendnum)+128;
    446          //            } else {		
    447          //                //发送结束信号
    448          //                modelsendnum = 0xffffffff;
    449          //                //数据序号
    450          //                memcpy((uint8 *)&sDtu->Wr.Info.Buf[0],(uint8 *)&modelsendnum,sizeof(modelsendnum));	
    451          //                //数据内容
    452          //                memcpy((uint8 *)&sDtu->Wr.Info.Buf[4],&p[modelsendnum*128],(sizeof(stcModelCard ) - 128 * modelsendnum));
    453          //                
    454          //                Infolen = sizeof(modelsendnum) + (sizeof(stcModelCard ) - 128 * modelsendnum);
    455          //                
    456          //                //更改卡类型。退出模型卡
    457          //                modelsendnum = 0;
    458          //                sCtrl.sRunPara.CardType = DATA_CARD;
    459          //            }
    460          //        }else{
    461          //            sCtrl.sRunPara.CardType = 	DATA_CARD; //退出模型卡
    462          //            sDtu->Wr.Code			=	sCtrl.sRunPara.CardType;
    463          //            Infolen = 0;
    464          //            //不发送数据
    465          //            return;			
    466          //        }
    467          //        
    468                  
    469                  modelsendnum         = 0;
   \                     ??comm_para_flow_2: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x....             LDR.N    R1,??DataTable4_9
   \   000000D2   0x6008             STR      R0,[R1, #+0]
    470                  p = (uint8 *)&m_sModelCard;		
   \   000000D4   0x....             LDR.N    R0,??DataTable4_10
   \   000000D6   0x0006             MOVS     R6,R0
    471                  int     sendmodellen  = 0;  //已发送数据长度
   \   000000D8   0x2700             MOVS     R7,#+0
    472                  while(sizeof(stcModelCard ) > 128 * modelsendnum )
   \                     ??comm_para_flow_11: (+1)
   \   000000DA   0x....             LDR.N    R0,??DataTable4_9
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x2180             MOVS     R1,#+128
   \   000000E0   0x4348             MULS     R0,R1,R0
   \   000000E2   0xF241 0x7144      MOVW     R1,#+5956
   \   000000E6   0x4288             CMP      R0,R1
   \   000000E8   0xD26F             BCS.N    ??comm_para_flow_12
    473                  {
    474                      if((sizeof(stcModelCard ) - 128 * modelsendnum) > 128 ){
   \   000000EA   0xF241 0x7044      MOVW     R0,#+5956
   \   000000EE   0x....             LDR.N    R1,??DataTable4_9
   \   000000F0   0x6809             LDR      R1,[R1, #+0]
   \   000000F2   0x2280             MOVS     R2,#+128
   \   000000F4   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   000000F8   0x2881             CMP      R0,#+129
   \   000000FA   0xD324             BCC.N    ??comm_para_flow_13
    475                          if(modelsendnum == 0)
   \   000000FC   0x....             LDR.N    R0,??DataTable4_9
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD101             BNE.N    ??comm_para_flow_14
    476                              p = (uint8 *)&m_sModelCard;		
   \   00000104   0x....             LDR.N    R0,??DataTable4_10
   \   00000106   0x0006             MOVS     R6,R0
    477                          //数据序号
    478                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[0],(uint8 *)&modelsendnum,sizeof(modelsendnum));	
   \                     ??comm_para_flow_14: (+1)
   \   00000108   0xF05F 0x0804      MOVS     R8,#+4
   \   0000010C   0x.... 0x....      LDR.W    R9,??DataTable4_9
   \   00000110   0xF114 0x0AA4      ADDS     R10,R4,#+164
   \   00000114   0x4642             MOV      R2,R8
   \   00000116   0x4649             MOV      R1,R9
   \   00000118   0x4650             MOV      R0,R10
   \   0000011A   0x.... 0x....      BL       __aeabi_memcpy
    479                          //数据内容
    480                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[4],&p[sendmodellen],128);
   \   0000011E   0xF05F 0x0A80      MOVS     R10,#+128
   \   00000122   0x19B8             ADDS     R0,R7,R6
   \   00000124   0x9000             STR      R0,[SP, #+0]
   \   00000126   0xF114 0x0BA8      ADDS     R11,R4,#+168
   \   0000012A   0x4652             MOV      R2,R10
   \   0000012C   0x9900             LDR      R1,[SP, #+0]
   \   0000012E   0x4658             MOV      R0,R11
   \   00000130   0x.... 0x....      BL       __aeabi_memcpy
    481                          modelsendnum++;
   \   00000134   0x....             LDR.N    R0,??DataTable4_9
   \   00000136   0x6800             LDR      R0,[R0, #+0]
   \   00000138   0x1C40             ADDS     R0,R0,#+1
   \   0000013A   0x....             LDR.N    R1,??DataTable4_9
   \   0000013C   0x6008             STR      R0,[R1, #+0]
    482                          sendmodellen += 128;
   \   0000013E   0x3780             ADDS     R7,R7,#+128
    483                          
    484                          Infolen = sizeof(modelsendnum)+128;
   \   00000140   0x2084             MOVS     R0,#+132
   \   00000142   0x0005             MOVS     R5,R0
   \   00000144   0xE025             B.N      ??comm_para_flow_15
    485                      } else {		
    486                          //发送结束信号
    487                          modelsendnum = 0xffffffff;
   \                     ??comm_para_flow_13: (+1)
   \   00000146   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000014A   0x....             LDR.N    R1,??DataTable4_9
   \   0000014C   0x6008             STR      R0,[R1, #+0]
    488                          //数据序号
    489                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[0],(uint8 *)&modelsendnum,sizeof(modelsendnum));	
   \   0000014E   0xF05F 0x0804      MOVS     R8,#+4
   \   00000152   0x.... 0x....      LDR.W    R9,??DataTable4_9
   \   00000156   0xF114 0x0AA4      ADDS     R10,R4,#+164
   \   0000015A   0x4642             MOV      R2,R8
   \   0000015C   0x4649             MOV      R1,R9
   \   0000015E   0x4650             MOV      R0,R10
   \   00000160   0x.... 0x....      BL       __aeabi_memcpy
    490                          //数据内容
    491                          memcpy((uint8 *)&sDtu->Wr.Info.Buf[4],&p[sendmodellen],(sizeof(stcModelCard ) - sendmodellen));
   \   00000164   0xF241 0x7044      MOVW     R0,#+5956
   \   00000168   0x1BC0             SUBS     R0,R0,R7
   \   0000016A   0x9000             STR      R0,[SP, #+0]
   \   0000016C   0xEB17 0x0A06      ADDS     R10,R7,R6
   \   00000170   0xF114 0x0BA8      ADDS     R11,R4,#+168
   \   00000174   0x9A00             LDR      R2,[SP, #+0]
   \   00000176   0x4651             MOV      R1,R10
   \   00000178   0x4658             MOV      R0,R11
   \   0000017A   0x.... 0x....      BL       __aeabi_memcpy
    492                          
    493                          Infolen = sizeof(modelsendnum) + (sizeof(stcModelCard ) - sendmodellen);
   \   0000017E   0xF1D7 0x0048      RSBS     R0,R7,#+72
   \   00000182   0x0005             MOVS     R5,R0
    494                          
    495                          sendmodellen = sizeof(stcModelCard ) ;
   \   00000184   0xF241 0x7044      MOVW     R0,#+5956
   \   00000188   0x0007             MOVS     R7,R0
    496                          //更改卡类型。退出模型卡
    497                          //modelsendnum = 0;
    498                          sCtrl.sRunPara.CardType = DATA_CARD;
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0x....             LDR.N    R1,??DataTable4
   \   0000018E   0xF8C1 0x00B0      STR      R0,[R1, #+176]
    499                      }
    500                      
    501                      
    502                      CSNC_SendData(	    sDtu->pch,						//通讯控制块
    503                                          SLAVE_ADDR_OTR,					//源地址
    504                                          MASTE_ADDR_HOST,				//目标地址
    505                                          sDtu->ConnCtrl[0].SendFramNum,	//发送帧号
    506                                          0,								//帧类型，默认为0，在数据区内明确		
    507                                          (uint8 *)&sDtu->Wr,				//发送缓冲区
    508                                          Infolen+sizeof(sDtu->Wr.Code)	//发送数据区长度
    509                                              );
   \                     ??comm_para_flow_15: (+1)
   \   00000192   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000194   0x1D28             ADDS     R0,R5,#+4
   \   00000196   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000198   0x9002             STR      R0,[SP, #+8]
   \   0000019A   0xF114 0x00A0      ADDS     R0,R4,#+160
   \   0000019E   0x9001             STR      R0,[SP, #+4]
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0x9000             STR      R0,[SP, #+0]
   \   000001A4   0xF894 0x3152      LDRB     R3,[R4, #+338]
   \   000001A8   0x2280             MOVS     R2,#+128
   \   000001AA   0x21C1             MOVS     R1,#+193
   \   000001AC   0xF8D4 0x015C      LDR      R0,[R4, #+348]
   \   000001B0   0x.... 0x....      BL       CSNC_SendData
    510                      
    511          //            int senddelay = 10000000;
    512          //            while(senddelay--);
    513                      OS_ERR  os_err;
    514                      OSTimeDlyHMSM(0, 0, 0, 200,
    515                                    OS_OPT_TIME_HMSM_STRICT, &os_err);
   \   000001B4   0xA803             ADD      R0,SP,#+12
   \   000001B6   0x9001             STR      R0,[SP, #+4]
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x9000             STR      R0,[SP, #+0]
   \   000001BC   0x23C8             MOVS     R3,#+200
   \   000001BE   0x2200             MOVS     R2,#+0
   \   000001C0   0x2100             MOVS     R1,#+0
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0x.... 0x....      BL       OSTimeDlyHMSM
   \   000001C8   0xE787             B.N      ??comm_para_flow_11
    516                      
    517                  }
    518                  
    519                  return;
   \                     ??comm_para_flow_12: (+1)
   \   000001CA   0xE012             B.N      ??comm_para_flow_16
    520                  
    521                  break;
    522                  /***********************************************
    523                  * 描述： 数据卡(默认状态)。
    524                  *   对
    525                  *   后续每200ms发送数据，序号从0开始累加。
    526                  数据发送完成后，序号为0xffffffff。
    527                  */    		
    528                  //数据卡
    529              case    DATA_CARD: 
    530                  return;
   \                     ??comm_para_flow_0: (+1)
   \   000001CC   0xE011             B.N      ??comm_para_flow_16
    531                  break;
    532                  
    533                  //其他类型数据，直接退出
    534              default:
    535                  return;					   
   \                     ??comm_para_flow_9: (+1)
   \   000001CE   0xE010             B.N      ??comm_para_flow_16
    536                  
    537              }
    538              
    539          	CSNC_SendData(	sDtu->pch,						//通讯控制块
    540                            SLAVE_ADDR_OTR,					//源地址
    541                            MASTE_ADDR_HOST,				//目标地址
    542                            sDtu->ConnCtrl[0].SendFramNum,	//发送帧号
    543                            0,								//帧类型，默认为0，在数据区内明确		
    544                            (uint8 *)&sDtu->Wr,				//发送缓冲区
    545                            Infolen+sizeof(sDtu->Wr.Code)	//发送数据区长度
    546                                );
   \                     ??comm_para_flow_10: (+1)
   \   000001D0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D2   0x1D28             ADDS     R0,R5,#+4
   \   000001D4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001D6   0x9002             STR      R0,[SP, #+8]
   \   000001D8   0xF114 0x00A0      ADDS     R0,R4,#+160
   \   000001DC   0x9001             STR      R0,[SP, #+4]
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0x9000             STR      R0,[SP, #+0]
   \   000001E2   0xF894 0x3152      LDRB     R3,[R4, #+338]
   \   000001E6   0x2280             MOVS     R2,#+128
   \   000001E8   0x21C1             MOVS     R1,#+193
   \   000001EA   0xF8D4 0x015C      LDR      R0,[R4, #+348]
   \   000001EE   0x.... 0x....      BL       CSNC_SendData
    547          }
   \                     ??comm_para_flow_16: (+1)
   \   000001F2   0xB005             ADD      SP,SP,#+20
   \   000001F4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    548          
    549          
    550          /*******************************************************************************
    551          * 名    称： 		GetRecNumAddr
    552          * 功    能：      取数据记录地址。
    553          flash地址;更新记录号等信息。
    554          * 入口参数： 	无
    555          * 出口参数： 	无
    556          * 作　 　者： 	redmornigcn
    557          * 创建日期： 	2017-05-15
    558          * 修    改：
    559          * 修改日期：
    560          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    561          uint32  GetRecNumAddr(uint32 FlshRecNum)
    562          {				
    563              return  (uint32)(((FlshRecNum * sizeof(stcFlshRec)) % FLSH_MAX_SIZE)); 			
   \                     GetRecNumAddr: (+1)
   \   00000000   0x2180             MOVS     R1,#+128
   \   00000002   0xFB01 0xF100      MUL      R1,R1,R0
   \   00000006   0xF45F 0x0200      MOVS     R2,#+8388608
   \   0000000A   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \   0000000E   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \   00000012   0x4770             BX       LR               ;; return
    564          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     sCtrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     sCtrl+0x15C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     sCtrl+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     ??recsmalltimes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     ??recbigtimes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     ??errtimes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     sCtrl+0xBC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     sCtrl+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     sCtrl+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     modelsendnum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     m_sModelCard
    565          /*******************************************************************************
    566          * 				end of file
    567          *******************************************************************************/
    568          #endif
    569          
    570          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ClearModelSendNum
      24   DataComReadAsk
        24   -> CSNC_SendData
       0   GetRecNumAddr
      16   JudegLocoInfo
        16   -> FRAM_StoreProductInfo
        16   -> GetCrc16Check
      56   comm_para_flow
        56   -> CSNC_SendData
        56   -> OSTimeDlyHMSM
        56   -> __aeabi_memcpy
      16   comm_rec_read
        16   -> DataComReadAsk
        16   -> FRAM_StoreRecNumMgr
        16   -> GetRecNumAddr
        16   -> ReadFlsh
        16   -> WriteFlsh


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       8  ClearModelSendNum
      72  DataComReadAsk
      20  GetRecNumAddr
     134  JudegLocoInfo
     504  comm_para_flow
     482  comm_rec_read
       1  errtimes
    5956  m_sModelCard
       4  modelsendnum
       1  recbigtimes
       1  recsmalltimes

 
 5 963 bytes in section .bss
 1 264 bytes in section .text
 
 1 264 bytes of CODE memory
 5 963 bytes of DATA memory

Errors: none
Warnings: 4

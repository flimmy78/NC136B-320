###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       14/Dec/2017  10:39:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_time.c
#    Command line =  
#        "F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_time.c" -lCN
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\os_time.lst
#    Object file  =  
#        F:\iar\NC136B-320
#        IC¿¨Ä£¿é\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\os_time.o
#
###############################################################################

F:\iar\NC136B-320 IC¿¨Ä£¿é\Software\uCOS-III\Source\os_time.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2016; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TIME MANAGEMENT
     10          *
     11          * File    : OS_TIME.C
     12          * By      : JJL
     13          * Version : V3.06.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can find our product's user manual, API reference, release notes and
     30          *           more information at https://doc.micrium.com.
     31          *           You can contact us at www.micrium.com.
     32          ************************************************************************************************************************
     33          */
     34          
     35          #define  MICRIUM_SOURCE
     36          #include "os.h"
     37          
     38          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     39          const  CPU_CHAR  *os_time__c = "$Id: $";
     40          #endif
     41          
     42          /*
     43          ************************************************************************************************************************
     44          *                                                  DELAY TASK 'n' TICKS
     45          *
     46          * Description: This function is called to delay execution of the currently running task until the specified number of
     47          *              system ticks expires.  This, of course, directly equates to delaying the current task for some time to
     48          *              expire.  No delay will result if the specified delay is 0.  If the specified delay is greater than 0
     49          *              then, a context switch will result.
     50          *
     51          * Arguments  : dly       is a value in 'clock ticks' that the task will either delay for or, the target match value
     52          *                        of the tick counter (OSTickCtr).  Note that specifying 0 means the task is not to delay.
     53          *
     54          *                        depending on the option argument, the task will wake up when OSTickCtr reaches:
     55          *
     56          *                            OS_OPT_TIME_DLY      : OSTickCtr + dly
     57          *                            OS_OPT_TIME_TIMEOUT  : OSTickCtr + dly
     58          *                            OS_OPT_TIME_MATCH    : dly
     59          *                            OS_OPT_TIME_PERIODIC : OSTCBCurPtr->TickCtrPrev + dly
     60          *
     61          *              opt       specifies whether 'dly' represents absolute or relative time; default option marked with *** :
     62          *
     63          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
     64          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
     65          *                            OS_OPT_TIME_MATCH      indicates that 'dly' specifies the absolute value that OSTickCtr
     66          *                                                   must reach before the task will be resumed.
     67          *                            OS_OPT_TIME_PERIODIC   indicates that 'dly' specifies the periodic value that OSTickCtr
     68          *                                                   must reach before the task will be resumed.
     69          *
     70          *              p_err     is a pointer to a variable that will contain an error code from this call.
     71          *
     72          *                            OS_ERR_NONE              The call was successful and the delay occurred
     73          *                            OS_ERR_OPT_INVALID       If you specified an invalid option for this function
     74          *                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
     75          *                            OS_ERR_SCHED_LOCKED      Can't delay when the scheduler is locked
     76          *                            OS_ERR_TIME_DLY_ISR      If you called this function from an ISR
     77          *                            OS_ERR_TIME_ZERO_DLY     If you specified a delay of zero
     78          *
     79          * Returns    : none
     80          *
     81          * Note(s)    : none
     82          ************************************************************************************************************************
     83          */
     84          

   \                                 In section .text, align 2, keep-with-next
     85          void  OSTimeDly (OS_TICK   dly,
     86                           OS_OPT    opt,
     87                           OS_ERR   *p_err)
     88          {
   \                     OSTimeDly: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     89          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
     90              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
     91          #endif
     92          
     93          
     94          #ifdef OS_SAFETY_CRITICAL
     95              if (p_err == DEF_NULL) {
     96                  OS_SAFETY_CRITICAL_EXCEPTION();
     97                  return;
     98              }
     99          #endif
    100          
    101          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    102              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSTimeDly_0
    103                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   00000014   0xF247 0x2075      MOVW     R0,#+29301
   \   00000018   0x8030             STRH     R0,[R6, #+0]
    104                  return;
   \   0000001A   0xE03F             B.N      ??OSTimeDly_1
    105              }
    106          #endif
    107          
    108          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    109              if (OSRunning != OS_STATE_OS_RUNNING) {
    110                 *p_err = OS_ERR_OS_NOT_RUNNING;
    111                  return;
    112              }
    113          #endif
    114          
    115              if (OSSchedLockNestingCtr > 0u) {                           /* Can't delay when the scheduler is locked             */
   \                     ??OSTimeDly_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD003             BEQ.N    ??OSTimeDly_2
    116                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000026   0xF646 0x5063      MOVW     R0,#+28003
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
    117                  return;
   \   0000002C   0xE036             B.N      ??OSTimeDly_1
    118              }
    119          
    120              switch (opt) {
   \                     ??OSTimeDly_2: (+1)
   \   0000002E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD005             BEQ.N    ??OSTimeDly_3
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD003             BEQ.N    ??OSTimeDly_3
   \   0000003A   0x2804             CMP      R0,#+4
   \   0000003C   0xD008             BEQ.N    ??OSTimeDly_4
   \   0000003E   0x2808             CMP      R0,#+8
   \   00000040   0xD107             BNE.N    ??OSTimeDly_5
    121                  case OS_OPT_TIME_DLY:
    122                  case OS_OPT_TIME_TIMEOUT:
    123                  case OS_OPT_TIME_PERIODIC:
    124                       if (dly == 0u) {                                   /* 0 means no delay!                                    */
   \                     ??OSTimeDly_3: (+1)
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD103             BNE.N    ??OSTimeDly_6
    125                          *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000046   0xF247 0x207E      MOVW     R0,#+29310
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
    126                           return;
   \   0000004C   0xE026             B.N      ??OSTimeDly_1
    127                       }
    128                       break;
   \                     ??OSTimeDly_6: (+1)
   \   0000004E   0xE004             B.N      ??OSTimeDly_7
    129          
    130                  case OS_OPT_TIME_MATCH:
    131                       break;
   \                     ??OSTimeDly_4: (+1)
   \   00000050   0xE003             B.N      ??OSTimeDly_7
    132          
    133                  default:
    134                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTimeDly_5: (+1)
   \   00000052   0xF645 0x6025      MOVW     R0,#+24101
   \   00000056   0x8030             STRH     R0,[R6, #+0]
    135                       return;
   \   00000058   0xE020             B.N      ??OSTimeDly_1
    136              }
    137          
    138          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    139              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDly_7: (+1)
   \   0000005A   0x.... 0x....      BL       CPU_SR_Save
   \   0000005E   0x0007             MOVS     R7,R0
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStart
    140              OS_TickListInsertDly(OSTCBCurPtr,
    141                                   dly,
    142                                   opt,
    143                                   p_err);
   \   00000064   0x0033             MOVS     R3,R6
   \   00000066   0x002A             MOVS     R2,R5
   \   00000068   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000006A   0x0021             MOVS     R1,R4
   \   0000006C   0x....             LDR.N    R0,??DataTable5_2
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x.... 0x....      BL       OS_TickListInsertDly
    144              if (*p_err != OS_ERR_NONE) {
   \   00000074   0x8830             LDRH     R0,[R6, #+0]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD005             BEQ.N    ??OSTimeDly_8
    145                   CPU_CRITICAL_EXIT();
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007E   0x0038             MOVS     R0,R7
   \   00000080   0x.... 0x....      BL       CPU_SR_Restore
    146                   return;
   \   00000084   0xE00A             B.N      ??OSTimeDly_1
    147              }
    148          
    149              OS_TRACE_TASK_DLY(dly);
    150              OS_RdyListRemove(OSTCBCurPtr);                              /* Remove current task from ready list                  */
   \                     ??OSTimeDly_8: (+1)
   \   00000086   0x....             LDR.N    R0,??DataTable5_2
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x.... 0x....      BL       OS_RdyListRemove
    151              CPU_CRITICAL_EXIT();
   \   0000008E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0x.... 0x....      BL       CPU_SR_Restore
    152              OSSched();                                                  /* Find next task to run!                               */
   \   00000098   0x.... 0x....      BL       OSSched
    153          #endif
    154          }
   \                     ??OSTimeDly_1: (+1)
   \   0000009C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    155          
    156          
    157          /*
    158          ************************************************************************************************************************
    159          *                                             DELAY TASK FOR SPECIFIED TIME
    160          *
    161          * Description: This function is called to delay execution of the currently running task until some time expires.  This
    162          *              call allows you to specify the delay time in HOURS, MINUTES, SECONDS and MILLISECONDS instead of ticks.
    163          *
    164          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 999 if the tick rate is
    165          *                        1000 Hz or less otherwise, a higher value would overflow a 32-bit unsigned counter).
    166          *
    167          *              minutes   specifies the number of minutes (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    168          *
    169          *              seconds   specifies the number of seconds (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    170          *
    171          *              milli     specifies the number of milliseconds (max. 999 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    172          *
    173          *              opt       specifies time delay bit-field options logically OR'd; default options marked with *** :
    174          *
    175          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
    176          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
    177          *                            OS_OPT_TIME_MATCH      indicates that the delay specifies the absolute value that OSTickCtr
    178          *                                                   must reach before the task will be resumed.
    179          *                            OS_OPT_TIME_PERIODIC   indicates that the delay specifies the periodic value that OSTickCtr
    180          *                                                   must reach before the task will be resumed.
    181          *
    182          *                        *** OS_OPT_TIME_HMSM_STRICT            strictly allow only hours        (0...99)
    183          *                                                                                   minutes      (0...59)
    184          *                                                                                   seconds      (0...59)
    185          *                                                                                   milliseconds (0...999)
    186          *                            OS_OPT_TIME_HMSM_NON_STRICT        allow any value of  hours        (0...999)
    187          *                                                                                   minutes      (0...9999)
    188          *                                                                                   seconds      (0...65535)
    189          *                                                                                   milliseconds (0...4294967295)
    190          *
    191          *              p_err     is a pointer to a variable that will receive an error code from this call.
    192          *
    193          *                            OS_ERR_NONE                        If the function returns from the desired delay
    194          *                            OS_ERR_OPT_INVALID                 If you specified an invalid option for 'opt'
    195          *                            OS_ERR_OS_NOT_RUNNING              If uC/OS-III is not running yet
    196          *                            OS_ERR_SCHED_LOCKED                Can't delay when the scheduler is locked
    197          *                            OS_ERR_TIME_DLY_ISR                If called from an ISR
    198          *                            OS_ERR_TIME_INVALID_HOURS          If you didn't specify a valid value for 'hours'
    199          *                            OS_ERR_TIME_INVALID_MINUTES        If you didn't specify a valid value for 'minutes'
    200          *                            OS_ERR_TIME_INVALID_SECONDS        If you didn't specify a valid value for 'seconds'
    201          *                            OS_ERR_TIME_INVALID_MILLISECONDS   If you didn't specify a valid value for 'milli'
    202          *                            OS_ERR_TIME_ZERO_DLY               If hours, minutes, seconds and milli are all 0
    203          *
    204          * Returns    : none
    205          *
    206          * Note(s)    : 1) The resolution on the milliseconds depends on the tick rate.  For example, you can't do a 10 mS delay
    207          *                 if the ticker interrupts every 100 mS.  In this case, the delay would be set to 0.  The actual delay
    208          *                 is rounded to the nearest tick.
    209          *
    210          *              2) Although this function allows you to delay a task for many, many hours, it's not recommended to put
    211          *                 a task to sleep for that long.
    212          ************************************************************************************************************************
    213          */
    214          
    215          #if (OS_CFG_TIME_DLY_HMSM_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    216          void  OSTimeDlyHMSM (CPU_INT16U   hours,
    217                               CPU_INT16U   minutes,
    218                               CPU_INT16U   seconds,
    219                               CPU_INT32U   milli,
    220                               OS_OPT       opt,
    221                               OS_ERR      *p_err)
    222          {
   \                     OSTimeDlyHMSM: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4693             MOV      R11,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C0C             LDR      R4,[SP, #+48]
   \   0000000E   0xF8DD 0x8034      LDR      R8,[SP, #+52]
    223          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)
    224              CPU_BOOLEAN  opt_invalid;
    225              CPU_BOOLEAN  opt_non_strict;
    226          #endif
    227              OS_OPT       opt_time;
    228              OS_RATE_HZ   tick_rate;
    229              OS_TICK      ticks;
    230          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    231              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0A00      MOVS     R10,#+0
    232          #endif
    233          
    234          
    235          
    236          #ifdef OS_SAFETY_CRITICAL
    237              if (p_err == DEF_NULL) {
    238                  OS_SAFETY_CRITICAL_EXCEPTION();
    239                  return;
    240              }
    241          #endif
    242          
    243          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    244              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000016   0x....             LDR.N    R0,??DataTable5
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD004             BEQ.N    ??OSTimeDlyHMSM_0
    245                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   0000001E   0xF247 0x2075      MOVW     R0,#+29301
   \   00000022   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    246                  return;
   \   00000026   0xE0D0             B.N      ??OSTimeDlyHMSM_1
    247              }
    248          #endif
    249          
    250          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    251              if (OSRunning != OS_STATE_OS_RUNNING) {
    252                 *p_err = OS_ERR_OS_NOT_RUNNING;
    253                  return;
    254              }
    255          #endif
    256          
    257              if (OSSchedLockNestingCtr > 0u) {                           /* Can't delay when the scheduler is locked             */
   \                     ??OSTimeDlyHMSM_0: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable5_1
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD004             BEQ.N    ??OSTimeDlyHMSM_2
    258                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000030   0xF646 0x5063      MOVW     R0,#+28003
   \   00000034   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    259                  return;
   \   00000038   0xE0C7             B.N      ??OSTimeDlyHMSM_1
    260              }
    261          
    262              opt_time = opt & OS_OPT_TIME_MASK;                          /* Retrieve time options only.                          */
   \                     ??OSTimeDlyHMSM_2: (+1)
   \   0000003A   0xF014 0x000E      ANDS     R0,R4,#0xE
   \   0000003E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    263              switch (opt_time) {
   \   00000042   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD005             BEQ.N    ??OSTimeDlyHMSM_3
   \   0000004A   0x2802             CMP      R0,#+2
   \   0000004C   0xD003             BEQ.N    ??OSTimeDlyHMSM_3
   \   0000004E   0x2804             CMP      R0,#+4
   \   00000050   0xD014             BEQ.N    ??OSTimeDlyHMSM_4
   \   00000052   0x2808             CMP      R0,#+8
   \   00000054   0xD113             BNE.N    ??OSTimeDlyHMSM_5
    264                  case OS_OPT_TIME_DLY:
    265                  case OS_OPT_TIME_TIMEOUT:
    266                  case OS_OPT_TIME_PERIODIC:
    267                       if (milli == 0u) {                                 /* Make sure we didn't specify a 0 delay                */
   \                     ??OSTimeDlyHMSM_3: (+1)
   \   00000056   0x2F00             CMP      R7,#+0
   \   00000058   0xD10F             BNE.N    ??OSTimeDlyHMSM_6
    268                           if (seconds == 0u) {
   \   0000005A   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000005E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000062   0xD10A             BNE.N    ??OSTimeDlyHMSM_6
    269                               if (minutes == 0u) {
   \   00000064   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000066   0x2E00             CMP      R6,#+0
   \   00000068   0xD107             BNE.N    ??OSTimeDlyHMSM_6
    270                                   if (hours == 0u) {
   \   0000006A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006C   0x2D00             CMP      R5,#+0
   \   0000006E   0xD104             BNE.N    ??OSTimeDlyHMSM_6
    271                                      *p_err = OS_ERR_TIME_ZERO_DLY;
   \   00000070   0xF247 0x207E      MOVW     R0,#+29310
   \   00000074   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    272                                       return;
   \   00000078   0xE0A7             B.N      ??OSTimeDlyHMSM_1
    273                                   }
    274                               }
    275                           }
    276                       }
    277                       break;
   \                     ??OSTimeDlyHMSM_6: (+1)
   \   0000007A   0xE005             B.N      ??OSTimeDlyHMSM_7
    278          
    279                  case OS_OPT_TIME_MATCH:
    280                       break;
   \                     ??OSTimeDlyHMSM_4: (+1)
   \   0000007C   0xE004             B.N      ??OSTimeDlyHMSM_7
    281          
    282                  default:
    283                      *p_err = OS_ERR_OPT_INVALID;
   \                     ??OSTimeDlyHMSM_5: (+1)
   \   0000007E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000082   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    284                       return;
   \   00000086   0xE0A0             B.N      ??OSTimeDlyHMSM_1
    285              }
    286          
    287          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* Validate arguments to be within range                */
    288              opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
   \                     ??OSTimeDlyHMSM_7: (+1)
   \   00000088   0xF64F 0x71E1      MOVW     R1,#+65505
   \   0000008C   0x420C             TST      R4,R1
   \   0000008E   0xD102             BNE.N    ??OSTimeDlyHMSM_8
   \   00000090   0xF05F 0x0900      MOVS     R9,#+0
   \   00000094   0xE001             B.N      ??OSTimeDlyHMSM_9
   \                     ??OSTimeDlyHMSM_8: (+1)
   \   00000096   0xF05F 0x0901      MOVS     R9,#+1
    289              if (opt_invalid == DEF_YES) {
   \                     ??OSTimeDlyHMSM_9: (+1)
   \   0000009A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000009E   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000A2   0xD104             BNE.N    ??OSTimeDlyHMSM_10
    290                 *p_err = OS_ERR_OPT_INVALID;
   \   000000A4   0xF645 0x6025      MOVW     R0,#+24101
   \   000000A8   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    291                  return;
   \   000000AC   0xE08D             B.N      ??OSTimeDlyHMSM_1
    292              }
    293          
    294              opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
   \                     ??OSTimeDlyHMSM_10: (+1)
   \   000000AE   0xF3C4 0x1000      UBFX     R0,R4,#+4,#+1
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000B8   0xF88D 0x0002      STRB     R0,[SP, #+2]
    295              if (opt_non_strict != DEF_YES) {
   \   000000BC   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD021             BEQ.N    ??OSTimeDlyHMSM_11
    296                   if (milli   > 999u) {
   \   000000C4   0xF5B7 0x7F7A      CMP      R7,#+1000
   \   000000C8   0xD304             BCC.N    ??OSTimeDlyHMSM_12
    297                      *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
   \   000000CA   0xF247 0x207B      MOVW     R0,#+29307
   \   000000CE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    298                       return;
   \   000000D2   0xE07A             B.N      ??OSTimeDlyHMSM_1
    299                   }
    300                   if (seconds > 59u) {
   \                     ??OSTimeDlyHMSM_12: (+1)
   \   000000D4   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000D8   0xF1BB 0x0F3C      CMP      R11,#+60
   \   000000DC   0xD304             BCC.N    ??OSTimeDlyHMSM_13
    301                      *p_err = OS_ERR_TIME_INVALID_SECONDS;
   \   000000DE   0xF247 0x207A      MOVW     R0,#+29306
   \   000000E2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    302                       return;
   \   000000E6   0xE070             B.N      ??OSTimeDlyHMSM_1
    303                   }
    304                   if (minutes > 59u) {
   \                     ??OSTimeDlyHMSM_13: (+1)
   \   000000E8   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000EA   0x2E3C             CMP      R6,#+60
   \   000000EC   0xD304             BCC.N    ??OSTimeDlyHMSM_14
    305                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   000000EE   0xF247 0x2079      MOVW     R0,#+29305
   \   000000F2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    306                       return;
   \   000000F6   0xE068             B.N      ??OSTimeDlyHMSM_1
    307                   }
    308                   if (hours   > 99u) {
   \                     ??OSTimeDlyHMSM_14: (+1)
   \   000000F8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000FA   0x2D64             CMP      R5,#+100
   \   000000FC   0xD317             BCC.N    ??OSTimeDlyHMSM_15
    309                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   000000FE   0xF247 0x2078      MOVW     R0,#+29304
   \   00000102   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    310                       return;
   \   00000106   0xE060             B.N      ??OSTimeDlyHMSM_1
    311                   }
    312              } else {
    313                   if (minutes > 9999u) {
   \                     ??OSTimeDlyHMSM_11: (+1)
   \   00000108   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000010A   0xF242 0x7010      MOVW     R0,#+10000
   \   0000010E   0x4286             CMP      R6,R0
   \   00000110   0xD304             BCC.N    ??OSTimeDlyHMSM_16
    314                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   00000112   0xF247 0x2079      MOVW     R0,#+29305
   \   00000116   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    315                       return;
   \   0000011A   0xE056             B.N      ??OSTimeDlyHMSM_1
    316                   }
    317                   if (hours   > 999u) {
   \                     ??OSTimeDlyHMSM_16: (+1)
   \   0000011C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000011E   0xF5B5 0x7F7A      CMP      R5,#+1000
   \   00000122   0xD304             BCC.N    ??OSTimeDlyHMSM_15
    318                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   00000124   0xF247 0x2078      MOVW     R0,#+29304
   \   00000128   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    319                       return;
   \   0000012C   0xE04D             B.N      ??OSTimeDlyHMSM_1
    320                   }
    321              }
    322          #endif
    323          
    324                                                                          /* Compute the total number of clock ticks required..   */
    325                                                                          /* .. (rounded to the nearest tick)                     */
    326              tick_rate = OSCfg_TickRate_Hz;
   \                     ??OSTimeDlyHMSM_15: (+1)
   \   0000012E   0x....             LDR.N    R0,??DataTable5_3
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0x9001             STR      R0,[SP, #+4]
    327              ticks     = ((((OS_TICK)hours * (OS_TICK)3600u) + ((OS_TICK)minutes * (OS_TICK)60u) + (OS_TICK)seconds) * tick_rate)
    328                        + ((tick_rate * ((OS_TICK)milli + ((OS_TICK)500u / tick_rate))) / (OS_TICK)1000u);
   \   00000134   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000136   0xF44F 0x6061      MOV      R0,#+3600
   \   0000013A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000013C   0x213C             MOVS     R1,#+60
   \   0000013E   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000142   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000146   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000014A   0xEB1B 0x0000      ADDS     R0,R11,R0
   \   0000014E   0x9901             LDR      R1,[SP, #+4]
   \   00000150   0x9A01             LDR      R2,[SP, #+4]
   \   00000152   0xF44F 0x73FA      MOV      R3,#+500
   \   00000156   0xF8DD 0xC004      LDR      R12,[SP, #+4]
   \   0000015A   0xFBB3 0xF3FC      UDIV     R3,R3,R12
   \   0000015E   0x19DB             ADDS     R3,R3,R7
   \   00000160   0x435A             MULS     R2,R3,R2
   \   00000162   0xF44F 0x737A      MOV      R3,#+1000
   \   00000166   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000016A   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000016E   0x9002             STR      R0,[SP, #+8]
    329          
    330              if (ticks > 0u) {
   \   00000170   0x9802             LDR      R0,[SP, #+8]
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD025             BEQ.N    ??OSTimeDlyHMSM_17
    331          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    332                  CPU_CRITICAL_ENTER();
   \   00000176   0x.... 0x....      BL       CPU_SR_Save
   \   0000017A   0x4682             MOV      R10,R0
   \   0000017C   0x.... 0x....      BL       CPU_IntDisMeasStart
    333                  OS_TickListInsertDly(OSTCBCurPtr,
    334                                       ticks,
    335                                       opt_time,
    336                                       p_err);
   \   00000180   0x4643             MOV      R3,R8
   \   00000182   0xF8BD 0x2000      LDRH     R2,[SP, #+0]
   \   00000186   0x9902             LDR      R1,[SP, #+8]
   \   00000188   0x....             LDR.N    R0,??DataTable5_2
   \   0000018A   0x6800             LDR      R0,[R0, #+0]
   \   0000018C   0x.... 0x....      BL       OS_TickListInsertDly
    337                  if (*p_err != OS_ERR_NONE) {
   \   00000190   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000194   0x2800             CMP      R0,#+0
   \   00000196   0xD005             BEQ.N    ??OSTimeDlyHMSM_18
    338                       CPU_CRITICAL_EXIT();
   \   00000198   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000019C   0x4650             MOV      R0,R10
   \   0000019E   0x.... 0x....      BL       CPU_SR_Restore
    339                       return;
   \   000001A2   0xE012             B.N      ??OSTimeDlyHMSM_1
    340                  }
    341          
    342                  OS_TRACE_TASK_DLY(ticks);
    343                  OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                  */
   \                     ??OSTimeDlyHMSM_18: (+1)
   \   000001A4   0x....             LDR.N    R0,??DataTable5_2
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x.... 0x....      BL       OS_RdyListRemove
    344                  CPU_CRITICAL_EXIT();
   \   000001AC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001B0   0x4650             MOV      R0,R10
   \   000001B2   0x.... 0x....      BL       CPU_SR_Restore
    345                  OSSched();                                              /* Find next task to run!                               */
   \   000001B6   0x.... 0x....      BL       OSSched
    346          #endif
    347                 *p_err = OS_ERR_NONE;
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000001C0   0xE003             B.N      ??OSTimeDlyHMSM_19
    348              } else {
    349                 *p_err = OS_ERR_TIME_ZERO_DLY;
   \                     ??OSTimeDlyHMSM_17: (+1)
   \   000001C2   0xF247 0x207E      MOVW     R0,#+29310
   \   000001C6   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    350              }
    351          }
   \                     ??OSTimeDlyHMSM_19: (+1)
   \                     ??OSTimeDlyHMSM_1: (+1)
   \   000001CA   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    352          #endif
    353          
    354          /*
    355          ************************************************************************************************************************
    356          *                                                RESUME A DELAYED TASK
    357          *
    358          * Description: This function is used resume a task that has been delayed through a call to either OSTimeDly() or
    359          *              OSTimeDlyHMSM().  Note that you cannot call this function to resume a task that is waiting for an event
    360          *              with timeout.
    361          *
    362          * Arguments  : p_tcb    is a pointer to the TCB of the task to resume.
    363          *
    364          *              p_err    is a pointer to a variable that will receive an error code
    365          *
    366          *                           OS_ERR_NONE                  Task has been resumed
    367          *                           OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    368          *                           OS_ERR_STATE_INVALID         Task is in an invalid state
    369          *                           OS_ERR_TASK_NOT_DLY          Task is not waiting for time to expire
    370          *                           OS_ERR_TASK_SUSPENDED        Task cannot be resumed, it was suspended by OSTaskSuspend()
    371          *                           OS_ERR_TCB_INVALID           If 'p_tcb' is a NULL pointer
    372          *                           OS_ERR_TIME_DLY_RESUME_ISR   If called from an ISR
    373          *
    374          * Returns    : none
    375          *
    376          * Note(s)    : none
    377          ************************************************************************************************************************
    378          */
    379          
    380          #if (OS_CFG_TIME_DLY_RESUME_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    381          void  OSTimeDlyResume (OS_TCB  *p_tcb,
    382                                 OS_ERR  *p_err)
    383          {
   \                     OSTimeDlyResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    384              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    385          
    386          
    387          
    388          #ifdef OS_SAFETY_CRITICAL
    389              if (p_err == DEF_NULL) {
    390                  OS_SAFETY_CRITICAL_EXCEPTION();
    391                  return;
    392              }
    393          #endif
    394          
    395          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN == DEF_ENABLED)
    396              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSTimeDlyResume_0
    397                 *p_err = OS_ERR_TIME_DLY_RESUME_ISR;
   \   00000010   0xF247 0x2076      MOVW     R0,#+29302
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    398                  return;
   \   00000016   0xE04C             B.N      ??OSTimeDlyResume_1
    399              }
    400          #endif
    401          
    402          #if (OS_CFG_ARG_CHK_EN == DEF_ENABLED)                          /* ---------------- VALIDATE ARGUMENTS ---------------- */
    403              if (p_tcb == DEF_NULL) {                                    /* User must supply a valid OS_TCB                      */
   \                     ??OSTimeDlyResume_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD103             BNE.N    ??OSTimeDlyResume_2
    404                 *p_err = OS_ERR_TCB_INVALID;
   \   0000001C   0xF247 0x10AD      MOVW     R0,#+29101
   \   00000020   0x8028             STRH     R0,[R5, #+0]
    405                  return;
   \   00000022   0xE046             B.N      ??OSTimeDlyResume_1
    406              }
    407          #endif
    408          
    409          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN == DEF_ENABLED)             /* Is the kernel running?                               */
    410              if (OSRunning != OS_STATE_OS_RUNNING) {
    411                 *p_err = OS_ERR_OS_NOT_RUNNING;
    412                  return;
    413              }
    414          #endif
    415          
    416              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDlyResume_2: (+1)
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStart
    417              switch (p_tcb->TaskState) {
   \   0000002E   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD00A             BEQ.N    ??OSTimeDlyResume_3
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD008             BEQ.N    ??OSTimeDlyResume_3
   \   0000003A   0xD310             BCC.N    ??OSTimeDlyResume_4
   \   0000003C   0x2804             CMP      R0,#+4
   \   0000003E   0xD005             BEQ.N    ??OSTimeDlyResume_3
   \   00000040   0xD304             BCC.N    ??OSTimeDlyResume_3
   \   00000042   0x2806             CMP      R0,#+6
   \   00000044   0xD002             BEQ.N    ??OSTimeDlyResume_3
   \   00000046   0xD31B             BCC.N    ??OSTimeDlyResume_5
   \   00000048   0x2807             CMP      R0,#+7
   \   0000004A   0xD128             BNE.N    ??OSTimeDlyResume_6
    418                  case OS_TASK_STATE_RDY:                                 /* Cannot Abort delay if task is ready                  */
    419                  case OS_TASK_STATE_PEND:
    420                  case OS_TASK_STATE_PEND_TIMEOUT:
    421                  case OS_TASK_STATE_SUSPENDED:
    422                  case OS_TASK_STATE_PEND_SUSPENDED:
    423                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    424                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_3: (+1)
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    425                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000056   0xF247 0x1051      MOVW     R0,#+29009
   \   0000005A   0x8028             STRH     R0,[R5, #+0]
    426                       break;
   \   0000005C   0xE027             B.N      ??OSTimeDlyResume_7
    427          
    428                  case OS_TASK_STATE_DLY:
    429                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \                     ??OSTimeDlyResume_4: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x003E      STRB     R0,[R4, #+62]
    430          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    431                       OS_TickListRemove(p_tcb);                          /* Remove task from tick list                           */
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       OS_TickListRemove
    432                       OS_RdyListInsert(p_tcb);                           /* Add to ready list                                    */
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       OS_RdyListInsert
    433          #endif
    434                       CPU_CRITICAL_EXIT();
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    435                      *p_err = OS_ERR_NONE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x8028             STRH     R0,[R5, #+0]
    436                       break;
   \   0000007E   0xE016             B.N      ??OSTimeDlyResume_7
    437          
    438                  case OS_TASK_STATE_DLY_SUSPENDED:
    439                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OSTimeDlyResume_5: (+1)
   \   00000080   0x2004             MOVS     R0,#+4
   \   00000082   0xF884 0x003E      STRB     R0,[R4, #+62]
    440          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    441                       OS_TickListRemove(p_tcb);                          /* Remove task from tick list                           */
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       OS_TickListRemove
    442          #endif
    443                       CPU_CRITICAL_EXIT();
   \   0000008C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    444                      *p_err            = OS_ERR_TASK_SUSPENDED;
   \   00000096   0xF247 0x105A      MOVW     R0,#+29018
   \   0000009A   0x8028             STRH     R0,[R5, #+0]
    445                       break;
   \   0000009C   0xE007             B.N      ??OSTimeDlyResume_7
    446          
    447                  default:
    448                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_6: (+1)
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0x0030             MOVS     R0,R6
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
    449                      *p_err = OS_ERR_STATE_INVALID;
   \   000000A8   0xF646 0x602D      MOVW     R0,#+28205
   \   000000AC   0x8028             STRH     R0,[R5, #+0]
    450                       break;
    451              }
    452          
    453              OSSched();
   \                     ??OSTimeDlyResume_7: (+1)
   \   000000AE   0x.... 0x....      BL       OSSched
    454          }
   \                     ??OSTimeDlyResume_1: (+1)
   \   000000B2   0xBD70             POP      {R4-R6,PC}       ;; return
    455          #endif
    456          
    457          /*
    458          ************************************************************************************************************************
    459          *                                               GET CURRENT SYSTEM TIME
    460          *
    461          * Description: This function is used by your application to obtain the current value of the counter which keeps track of
    462          *              the number of clock ticks.
    463          *
    464          * Arguments  : p_err    is a pointer to a variable that will receive an error code
    465          *
    466          *                           OS_ERR_NONE           If the call was successful
    467          *
    468          * Returns    : The current value of OSTickCtr
    469          *
    470          * Note(s)    : none
    471          ************************************************************************************************************************
    472          */
    473          

   \                                 In section .text, align 2, keep-with-next
    474          OS_TICK  OSTimeGet (OS_ERR  *p_err)
    475          {
   \                     OSTimeGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    476              OS_TICK  ticks;
    477          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    478              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    479          #endif
    480          
    481          
    482          #ifdef OS_SAFETY_CRITICAL
    483              if (p_err == DEF_NULL) {
    484                  OS_SAFETY_CRITICAL_EXCEPTION();
    485                  return (0u);
    486              }
    487          #endif
    488          
    489          
    490          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    491              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    492          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    493              if (OSRunning == OS_STATE_OS_RUNNING) {
    494                  ticks = BSP_OS_TickGet();
    495              } else {
    496                  ticks = OSTickCtr;
    497              }
    498          #else
    499              ticks = OSTickCtr;
   \   00000010   0x....             LDR.N    R0,??DataTable5_4
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x0005             MOVS     R5,R0
    500          #endif
    501              CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
    502          #else
    503              ticks = 0u;
    504          #endif
    505          
    506          
    507             *p_err = OS_ERR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x8020             STRH     R0,[R4, #+0]
    508              return (ticks);
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    509          }
    510          
    511          /*
    512          ************************************************************************************************************************
    513          *                                                   SET SYSTEM CLOCK
    514          *
    515          * Description: This function sets the counter which keeps track of the number of clock ticks.
    516          *
    517          * Arguments  : ticks    is the desired tick value
    518          *
    519          *              p_err    is a pointer to a variable that will receive an error code
    520          *
    521          *                           OS_ERR_NONE           If the call was successful
    522          *
    523          * Returns    : none
    524          *
    525          * Note(s)    : none
    526          ************************************************************************************************************************
    527          */
    528          

   \                                 In section .text, align 2, keep-with-next
    529          void  OSTimeSet (OS_TICK   ticks,
    530                           OS_ERR   *p_err)
    531          {
   \                     OSTimeSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    532          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    533              CPU_SR_ALLOC();
   \   00000006   0x2600             MOVS     R6,#+0
    534          #endif
    535          
    536          
    537          #ifdef OS_SAFETY_CRITICAL
    538              if (p_err == DEF_NULL) {
    539                  OS_SAFETY_CRITICAL_EXCEPTION();
    540                  return;
    541              }
    542          #endif
    543          
    544          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    545              CPU_CRITICAL_ENTER();
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0006             MOVS     R6,R0
   \   0000000E   0x.... 0x....      BL       CPU_IntDisMeasStart
    546              OSTickCtr = ticks;
   \   00000012   0x....             LDR.N    R0,??DataTable5_4
   \   00000014   0x6004             STR      R4,[R0, #+0]
    547              CPU_CRITICAL_EXIT();
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
    548          #endif
    549          
    550             *p_err     = OS_ERR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x8028             STRH     R0,[R5, #+0]
    551          }
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    552          
    553          
    554          /*
    555          ************************************************************************************************************************
    556          *                                                 PROCESS SYSTEM TICK
    557          *
    558          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    559          *              'clock tick').  This function should be called by the tick ISR.
    560          *
    561          * Arguments  : none
    562          *
    563          * Returns    : none
    564          *
    565          * Note(s)    : none
    566          ************************************************************************************************************************
    567          */
    568          

   \                                 In section .text, align 2, keep-with-next
    569          void  OSTimeTick (void)
    570          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    571          #if ((OS_CFG_TASK_TICK_EN == DEF_ENABLED) || (OS_CFG_TMR_EN == DEF_ENABLED))
    572              OS_ERR  err;
    573          #endif
    574          
    575          
    576              if (OSRunning != OS_STATE_OS_RUNNING) {
   \   00000002   0x....             LDR.N    R0,??DataTable5_5
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD106             BNE.N    ??OSTimeTick_0
    577                  return;
    578              }
    579          
    580              OSTimeTickHook();                                           /* Call user definable hook                             */
   \                     ??OSTimeTick_1: (+1)
   \   0000000A   0x.... 0x....      BL       OSTimeTickHook
    581          
    582          #if (OS_CFG_TASK_TICK_EN == DEF_ENABLED)
    583          
    584             (void)OSTaskSemPost(&OSTickTaskTCB,                          /* Signal tick task                                     */
    585                                  OS_OPT_POST_NONE,
    586                                 &err);
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R0,??DataTable5_6
   \   00000014   0x.... 0x....      BL       OSTaskSemPost
    587          
    588          
    589          #if (OS_CFG_SCHED_ROUND_ROBIN_EN == DEF_ENABLED)
    590              OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);
    591          #endif
    592          
    593          #if (OS_CFG_TMR_EN == DEF_ENABLED)
    594              OSTmrUpdateCtr--;
    595              if (OSTmrUpdateCtr == 0u) {
    596                  OSTmrUpdateCtr = OSTmrUpdateCnt;
    597                  (void)OSTaskSemPost(&OSTmrTaskTCB,                      /* Signal timer task                                    */
    598                                       OS_OPT_POST_NONE,
    599                                      &err);
    600              }
    601          #endif
    602          #endif
    603          }
   \                     ??OSTimeTick_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     OSTickTaskTCB
    604          
    605          
    606          /*
    607          ************************************************************************************************************************
    608          *                                             PROCESS SYSTEM TICK (DYNAMIC)
    609          *
    610          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    611          *              'clock tick').  This function should be called by the tick ISR.
    612          *
    613          * Arguments  : none
    614          *
    615          * Returns    : none
    616          *
    617          * Note(s)    : none
    618          ************************************************************************************************************************
    619          */
    620          
    621          #if (OS_CFG_DYN_TICK_EN == DEF_ENABLED)
    622          void OSTimeDynTick (OS_TICK ticks)
    623          {
    624              OS_ERR  err;
    625              CPU_SR_ALLOC();
    626          
    627          
    628              if (OSRunning != OS_STATE_OS_RUNNING) {
    629                  return;
    630              }
    631          
    632              OSTimeTickHook();
    633          
    634              CPU_CRITICAL_ENTER();
    635              OSTickCtrPend += ticks;
    636              CPU_CRITICAL_EXIT();
    637          
    638              (void)OSTaskSemPost(&OSTickTaskTCB,                          /* Signal tick task                                     */
    639                                   OS_OPT_POST_NONE,
    640                                  &err);
    641          
    642          }
    643          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTimeDly
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsertDly
      48   OSTimeDlyHMSM
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> OSSched
        48   -> OS_RdyListRemove
        48   -> OS_TickListInsertDly
      16   OSTimeDlyResume
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListInsert
        16   -> OS_TickListRemove
      16   OSTimeGet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSTimeSet
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       8   OSTimeTick
         8   -> OSTaskSemPost
         8   -> OSTimeTickHook


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
     158  OSTimeDly
     462  OSTimeDlyHMSM
     180  OSTimeDlyResume
      40  OSTimeGet
      38  OSTimeSet
      26  OSTimeTick

 
 932 bytes in section .text
 
 932 bytes of CODE memory

Errors: none
Warnings: none
